<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://mongoosejs.com"

    >mongoose (v4.9.3)</a>
</h1>
<h4>Mongoose MongoDB ODM</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose">module mongoose</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.ES6Promise">
            function <span class="apidocSignatureSpan">mongoose.</span>ES6Promise
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate">
            function <span class="apidocSignatureSpan">mongoose.</span>aggregate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browserDocument">
            function <span class="apidocSignatureSpan">mongoose.</span>browserDocument
            <span class="apidocSignatureSpan">(obj, schema, fields, skipId, skipInit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.collection">
            function <span class="apidocSignatureSpan">mongoose.</span>collection
            <span class="apidocSignatureSpan">(name, conn, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection">
            function <span class="apidocSignatureSpan">mongoose.</span>connection
            <span class="apidocSignatureSpan">(base)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document">
            function <span class="apidocSignatureSpan">mongoose.</span>document
            <span class="apidocSignatureSpan">(obj, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.error">
            function <span class="apidocSignatureSpan">mongoose.</span>error
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model">
            function <span class="apidocSignatureSpan">mongoose.</span>model
            <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.promise">
            function <span class="apidocSignatureSpan">mongoose.</span>promise
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query">
            function <span class="apidocSignatureSpan">mongoose.</span>query
            <span class="apidocSignatureSpan">(conditions, options, model, collection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querycursor">
            function <span class="apidocSignatureSpan">mongoose.</span>querycursor
            <span class="apidocSignatureSpan">(query, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querystream">
            function <span class="apidocSignatureSpan">mongoose.</span>querystream
            <span class="apidocSignatureSpan">(query, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema">
            function <span class="apidocSignatureSpan">mongoose.</span>schema
            <span class="apidocSignatureSpan">(obj, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype">
            function <span class="apidocSignatureSpan">mongoose.</span>schematype
            <span class="apidocSignatureSpan">(path, options, instance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.statemachine">
            function <span class="apidocSignatureSpan">mongoose.</span>statemachine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.virtualtype">
            function <span class="apidocSignatureSpan">mongoose.</span>virtualtype
            <span class="apidocSignatureSpan">(options, name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>aggregate.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>browser</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>browserDocument.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>collection.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>connection.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>connections</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>document.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>error.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>model.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>modelSchemas</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>models</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>plugins</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>promise.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>promise_provider</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>query.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>querycursor.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>queryhelpers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>querystream.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>schema.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>schematype.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>statemachine.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.</span>virtualtype.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.ES6Promise">module mongoose.ES6Promise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.ES6Promise.ES6Promise">
            function <span class="apidocSignatureSpan">mongoose.</span>ES6Promise
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.ES6Promise.use">
            function <span class="apidocSignatureSpan">mongoose.ES6Promise.</span>use
            <span class="apidocSignatureSpan">(Promise)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.aggregate">module mongoose.aggregate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.aggregate">
            function <span class="apidocSignatureSpan">mongoose.</span>aggregate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.aggregate.prototype">module mongoose.aggregate.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.addCursorFlag">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>addCursorFlag
            <span class="apidocSignatureSpan">(flag, value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.allowDiskUse">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>allowDiskUse
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.append">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>append
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.collation">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>collation
            <span class="apidocSignatureSpan">(collation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.cursor">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>cursor
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.exec">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>exec
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.explain">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>explain
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.facet">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>facet
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.graphLookup">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>graphLookup
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.group">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>group
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.limit">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>limit
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.lookup">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>lookup
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.match">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>match
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.model">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>model
            <span class="apidocSignatureSpan">(model)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.near">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>near
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.out">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>out
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.project">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>project
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.read">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>read
            <span class="apidocSignatureSpan">(pref, tags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.sample">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>sample
            <span class="apidocSignatureSpan">(size)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.skip">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>skip
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.sort">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>sort
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.then">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>then
            <span class="apidocSignatureSpan">(resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.aggregate.prototype.unwind">
            function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>unwind
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.browser">module mongoose.browser</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browser.Document">
            function <span class="apidocSignatureSpan">mongoose.browser.</span>Document
            <span class="apidocSignatureSpan">(obj, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browser.Error">
            function <span class="apidocSignatureSpan">mongoose.browser.</span>Error
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browser.Schema">
            function <span class="apidocSignatureSpan">mongoose.browser.</span>Schema
            <span class="apidocSignatureSpan">(obj, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browser.SchemaType">
            function <span class="apidocSignatureSpan">mongoose.browser.</span>SchemaType
            <span class="apidocSignatureSpan">(path, options, instance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browser.VirtualType">
            function <span class="apidocSignatureSpan">mongoose.browser.</span>VirtualType
            <span class="apidocSignatureSpan">(options, name)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.browser.</span>PromiseProvider</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.browser.</span>Types</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.browser.</span>utils</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.browserDocument">module mongoose.browserDocument</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browserDocument.browserDocument">
            function <span class="apidocSignatureSpan">mongoose.</span>browserDocument
            <span class="apidocSignatureSpan">(obj, schema, fields, skipId, skipInit)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browserDocument.ValidationError">
            function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>ValidationError
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browserDocument.addListener">
            function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browserDocument.emit">
            function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browserDocument.listeners">
            function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browserDocument.on">
            function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browserDocument.once">
            function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browserDocument.removeAllListeners">
            function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browserDocument.removeListener">
            function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browserDocument.setMaxListeners">
            function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.browserDocument.prototype">module mongoose.browserDocument.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.browserDocument.prototype.constructor">
            function <span class="apidocSignatureSpan">mongoose.browserDocument.prototype.</span>constructor
            <span class="apidocSignatureSpan">(obj, schema, fields, skipId, skipInit)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.collection">module mongoose.collection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.collection.collection">
            function <span class="apidocSignatureSpan">mongoose.</span>collection
            <span class="apidocSignatureSpan">(name, conn, opts)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.collection.prototype">module mongoose.collection.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.collection.prototype.addQueue">
            function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>addQueue
            <span class="apidocSignatureSpan">(name, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.collection.prototype.doQueue">
            function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>doQueue
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.collection.prototype.ensureIndex">
            function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>ensureIndex
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.collection.prototype.find">
            function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>find
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.collection.prototype.findAndModify">
            function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>findAndModify
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.collection.prototype.findOne">
            function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>findOne
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.collection.prototype.getIndexes">
            function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>getIndexes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.collection.prototype.insert">
            function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>insert
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.collection.prototype.mapReduce">
            function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>mapReduce
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.collection.prototype.onClose">
            function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>onClose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.collection.prototype.onOpen">
            function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>onOpen
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.collection.prototype.save">
            function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>save
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.collection.prototype.update">
            function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>update
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.connection">module mongoose.connection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection.connection">
            function <span class="apidocSignatureSpan">mongoose.</span>connection
            <span class="apidocSignatureSpan">(base)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.connection.</span>STATES</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.connection.prototype">module mongoose.connection.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection.prototype._close">
            function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>_close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection.prototype._open">
            function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>_open
            <span class="apidocSignatureSpan">(emit, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection.prototype.authMechanismDoesNotRequirePassword">
            function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>authMechanismDoesNotRequirePassword
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection.prototype.close">
            function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection.prototype.collection">
            function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>collection
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection.prototype.dropDatabase">
            function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>dropDatabase
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection.prototype.error">
            function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>error
            <span class="apidocSignatureSpan">(err, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection.prototype.model">
            function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>model
            <span class="apidocSignatureSpan">(name, schema, collection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection.prototype.modelNames">
            function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>modelNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection.prototype.onClose">
            function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>onClose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection.prototype.onOpen">
            function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>onOpen
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection.prototype.open">
            function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>open
            <span class="apidocSignatureSpan">(host, database, port, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection.prototype.openSet">
            function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>openSet
            <span class="apidocSignatureSpan">(uris, database, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection.prototype.optionsProvideAuthenticationData">
            function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>optionsProvideAuthenticationData
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.connection.prototype.shouldAuthenticate">
            function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>shouldAuthenticate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.document">module mongoose.document</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.document">
            function <span class="apidocSignatureSpan">mongoose.</span>document
            <span class="apidocSignatureSpan">(obj, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.ValidationError">
            function <span class="apidocSignatureSpan">mongoose.document.</span>ValidationError
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document._lazySetupHooks">
            function <span class="apidocSignatureSpan">mongoose.document.</span>_lazySetupHooks
            <span class="apidocSignatureSpan">(proto, methodName, errorCb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.removePost">
            function <span class="apidocSignatureSpan">mongoose.document.</span>removePost
            <span class="apidocSignatureSpan">(name, fnToRemove)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.removePre">
            function <span class="apidocSignatureSpan">mongoose.document.</span>removePre
            <span class="apidocSignatureSpan">(name, fnToRemove)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.document.prototype">module mongoose.document.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype._lazySetupHooks">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>_lazySetupHooks
            <span class="apidocSignatureSpan">(proto, methodName, errorCb)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.addListener">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>addListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.depopulate">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>depopulate
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.emit">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>emit
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.equals">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>equals
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.execPopulate">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>execPopulate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.get">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>get
            <span class="apidocSignatureSpan">(path, type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.getValue">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>getValue
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.init">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>init
            <span class="apidocSignatureSpan">(doc, opts, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.inspect">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>inspect
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.invalidate">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>invalidate
            <span class="apidocSignatureSpan">(path, err, val, kind)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.isDirectModified">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>isDirectModified
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.isDirectSelected">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>isDirectSelected
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.isInit">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>isInit
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.isModified">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>isModified
            <span class="apidocSignatureSpan">(paths)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.isSelected">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>isSelected
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.listeners">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>listeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.markModified">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>markModified
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.modifiedPaths">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>modifiedPaths
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.on">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>on
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.once">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>once
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.populate">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>populate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.populated">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>populated
            <span class="apidocSignatureSpan">(path, val, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.removeAllListeners">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>removeAllListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.removeListener">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>removeListener
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.removePost">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>removePost
            <span class="apidocSignatureSpan">(name, fnToRemove)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.removePre">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>removePre
            <span class="apidocSignatureSpan">(name, fnToRemove)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.set">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>set
            <span class="apidocSignatureSpan">(path, val, type, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.setMaxListeners">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>setMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.setValue">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>setValue
            <span class="apidocSignatureSpan">(path, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.toBSON">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>toBSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.toJSON">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>toJSON
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.toObject">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>toObject
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.toString">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>toString
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.unmarkModified">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>unmarkModified
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.update">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>update
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.validate">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>validate
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.document.prototype.validateSync">
            function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>validateSync
            <span class="apidocSignatureSpan">(pathsToValidate)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.error">module mongoose.error</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.error.error">
            function <span class="apidocSignatureSpan">mongoose.</span>error
            <span class="apidocSignatureSpan">(msg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.error.CastError">
            function <span class="apidocSignatureSpan">mongoose.error.</span>CastError
            <span class="apidocSignatureSpan">(type, value, path, reason)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.error.DivergentArrayError">
            function <span class="apidocSignatureSpan">mongoose.error.</span>DivergentArrayError
            <span class="apidocSignatureSpan">(paths)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.error.DocumentNotFoundError">
            function <span class="apidocSignatureSpan">mongoose.error.</span>DocumentNotFoundError
            <span class="apidocSignatureSpan">(query)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.error.MissingSchemaError">
            function <span class="apidocSignatureSpan">mongoose.error.</span>MissingSchemaError
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.error.OverwriteModelError">
            function <span class="apidocSignatureSpan">mongoose.error.</span>OverwriteModelError
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.error.ValidationError">
            function <span class="apidocSignatureSpan">mongoose.error.</span>ValidationError
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.error.ValidatorError">
            function <span class="apidocSignatureSpan">mongoose.error.</span>ValidatorError
            <span class="apidocSignatureSpan">(properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.error.VersionError">
            function <span class="apidocSignatureSpan">mongoose.error.</span>VersionError
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.error.</span>Messages</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.error.</span>messages</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.error.prototype">module mongoose.error.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.error.prototype.constructor">
            function <span class="apidocSignatureSpan">mongoose.error.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.model">module mongoose.model</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.model">
            function <span class="apidocSignatureSpan">mongoose.</span>model
            <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.__subclass">
            function <span class="apidocSignatureSpan">mongoose.model.</span>__subclass
            <span class="apidocSignatureSpan">(conn, schema, collection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model._getSchema">
            function <span class="apidocSignatureSpan">mongoose.model.</span>_getSchema
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.addListener">
            function <span class="apidocSignatureSpan">mongoose.model.</span>addListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.aggregate">
            function <span class="apidocSignatureSpan">mongoose.model.</span>aggregate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.bulkWrite">
            function <span class="apidocSignatureSpan">mongoose.model.</span>bulkWrite
            <span class="apidocSignatureSpan">(ops, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.compile">
            function <span class="apidocSignatureSpan">mongoose.model.</span>compile
            <span class="apidocSignatureSpan">(name, schema, collectionName, connection, base)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.count">
            function <span class="apidocSignatureSpan">mongoose.model.</span>count
            <span class="apidocSignatureSpan">(conditions, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.create">
            function <span class="apidocSignatureSpan">mongoose.model.</span>create
            <span class="apidocSignatureSpan">(doc, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.deleteMany">
            function <span class="apidocSignatureSpan">mongoose.model.</span>deleteMany
            <span class="apidocSignatureSpan">(conditions, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.deleteOne">
            function <span class="apidocSignatureSpan">mongoose.model.</span>deleteOne
            <span class="apidocSignatureSpan">(conditions, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.discriminator">
            function <span class="apidocSignatureSpan">mongoose.model.</span>discriminator
            <span class="apidocSignatureSpan">(name, schema)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.distinct">
            function <span class="apidocSignatureSpan">mongoose.model.</span>distinct
            <span class="apidocSignatureSpan">(field, conditions, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.emit">
            function <span class="apidocSignatureSpan">mongoose.model.</span>emit
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.ensureIndexes">
            function <span class="apidocSignatureSpan">mongoose.model.</span>ensureIndexes
            <span class="apidocSignatureSpan">(options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.eventNames">
            function <span class="apidocSignatureSpan">mongoose.model.</span>eventNames
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.find">
            function <span class="apidocSignatureSpan">mongoose.model.</span>find
            <span class="apidocSignatureSpan">(conditions, projection, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.findById">
            function <span class="apidocSignatureSpan">mongoose.model.</span>findById
            <span class="apidocSignatureSpan">(id, projection, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.findByIdAndRemove">
            function <span class="apidocSignatureSpan">mongoose.model.</span>findByIdAndRemove
            <span class="apidocSignatureSpan">(id, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.findByIdAndUpdate">
            function <span class="apidocSignatureSpan">mongoose.model.</span>findByIdAndUpdate
            <span class="apidocSignatureSpan">(id, update, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.findOne">
            function <span class="apidocSignatureSpan">mongoose.model.</span>findOne
            <span class="apidocSignatureSpan">(conditions, projection, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.findOneAndRemove">
            function <span class="apidocSignatureSpan">mongoose.model.</span>findOneAndRemove
            <span class="apidocSignatureSpan">(conditions, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.findOneAndUpdate">
            function <span class="apidocSignatureSpan">mongoose.model.</span>findOneAndUpdate
            <span class="apidocSignatureSpan">(conditions, update, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.geoNear">
            function <span class="apidocSignatureSpan">mongoose.model.</span>geoNear
            <span class="apidocSignatureSpan">(near, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.geoSearch">
            function <span class="apidocSignatureSpan">mongoose.model.</span>geoSearch
            <span class="apidocSignatureSpan">(conditions, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.getMaxListeners">
            function <span class="apidocSignatureSpan">mongoose.model.</span>getMaxListeners
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.hydrate">
            function <span class="apidocSignatureSpan">mongoose.model.</span>hydrate
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.init">
            function <span class="apidocSignatureSpan">mongoose.model.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.insertMany">
            function <span class="apidocSignatureSpan">mongoose.model.</span>insertMany
            <span class="apidocSignatureSpan">(arr, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.listenerCount">
            function <span class="apidocSignatureSpan">mongoose.model.</span>listenerCount
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.listeners">
            function <span class="apidocSignatureSpan">mongoose.model.</span>listeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.mapReduce">
            function <span class="apidocSignatureSpan">mongoose.model.</span>mapReduce
            <span class="apidocSignatureSpan">(o, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.on">
            function <span class="apidocSignatureSpan">mongoose.model.</span>on
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.once">
            function <span class="apidocSignatureSpan">mongoose.model.</span>once
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.populate">
            function <span class="apidocSignatureSpan">mongoose.model.</span>populate
            <span class="apidocSignatureSpan">(docs, paths, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.prependListener">
            function <span class="apidocSignatureSpan">mongoose.model.</span>prependListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.prependOnceListener">
            function <span class="apidocSignatureSpan">mongoose.model.</span>prependOnceListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.remove">
            function <span class="apidocSignatureSpan">mongoose.model.</span>remove
            <span class="apidocSignatureSpan">(conditions, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.removeAllListeners">
            function <span class="apidocSignatureSpan">mongoose.model.</span>removeAllListeners
            <span class="apidocSignatureSpan">(type)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.removeListener">
            function <span class="apidocSignatureSpan">mongoose.model.</span>removeListener
            <span class="apidocSignatureSpan">(type, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.replaceOne">
            function <span class="apidocSignatureSpan">mongoose.model.</span>replaceOne
            <span class="apidocSignatureSpan">(conditions, doc, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.setMaxListeners">
            function <span class="apidocSignatureSpan">mongoose.model.</span>setMaxListeners
            <span class="apidocSignatureSpan">(n)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.update">
            function <span class="apidocSignatureSpan">mongoose.model.</span>update
            <span class="apidocSignatureSpan">(conditions, doc, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.updateMany">
            function <span class="apidocSignatureSpan">mongoose.model.</span>updateMany
            <span class="apidocSignatureSpan">(conditions, doc, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.updateOne">
            function <span class="apidocSignatureSpan">mongoose.model.</span>updateOne
            <span class="apidocSignatureSpan">(conditions, doc, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.where">
            function <span class="apidocSignatureSpan">mongoose.model.</span>where
            <span class="apidocSignatureSpan">(path, val)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">undefined <span class="apidocSignatureSpan">mongoose.model.</span>domain</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.model.prototype">module mongoose.model.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.prototype.increment">
            function <span class="apidocSignatureSpan">mongoose.model.prototype.</span>increment
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.prototype.model">
            function <span class="apidocSignatureSpan">mongoose.model.prototype.</span>model
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.prototype.remove">
            function <span class="apidocSignatureSpan">mongoose.model.prototype.</span>remove
            <span class="apidocSignatureSpan">(options, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.model.prototype.save">
            function <span class="apidocSignatureSpan">mongoose.model.prototype.</span>save
            <span class="apidocSignatureSpan">(options, fn)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.promise">module mongoose.promise</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.promise.promise">
            function <span class="apidocSignatureSpan">mongoose.</span>promise
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.promise.ES6">
            function <span class="apidocSignatureSpan">mongoose.promise.</span>ES6
            <span class="apidocSignatureSpan">(resolver)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mongoose.promise.</span>FAILURE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">mongoose.promise.</span>SUCCESS</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.promise.prototype">module mongoose.promise.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.promise.prototype.addBack">
            function <span class="apidocSignatureSpan">mongoose.promise.prototype.</span>addBack
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.promise.prototype.addCallback">
            function <span class="apidocSignatureSpan">mongoose.promise.prototype.</span>addCallback
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.promise.prototype.addErrback">
            function <span class="apidocSignatureSpan">mongoose.promise.prototype.</span>addErrback
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.promise.prototype.catch">
            function <span class="apidocSignatureSpan">mongoose.promise.prototype.</span>catch
            <span class="apidocSignatureSpan">(onReject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.promise.prototype.complete">
            function <span class="apidocSignatureSpan">mongoose.promise.prototype.</span>complete
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.promise.prototype.error">
            function <span class="apidocSignatureSpan">mongoose.promise.prototype.</span>error
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.promise.prototype.resolve">
            function <span class="apidocSignatureSpan">mongoose.promise.prototype.</span>resolve
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.promise.prototype.then">
            function <span class="apidocSignatureSpan">mongoose.promise.prototype.</span>then
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.promise_provider">module mongoose.promise_provider</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.promise_provider._promise">
            function <span class="apidocSignatureSpan">mongoose.promise_provider.</span>_promise
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.promise_provider.get">
            function <span class="apidocSignatureSpan">mongoose.promise_provider.</span>get
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.promise_provider.reset">
            function <span class="apidocSignatureSpan">mongoose.promise_provider.</span>reset
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.promise_provider.set">
            function <span class="apidocSignatureSpan">mongoose.promise_provider.</span>set
            <span class="apidocSignatureSpan">(lib)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.query">module mongoose.query</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.query">
            function <span class="apidocSignatureSpan">mongoose.</span>query
            <span class="apidocSignatureSpan">(conditions, options, model, collection)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.query.</span>base</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.query.prototype">module mongoose.query.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype._applyPaths">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_applyPaths
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype._castFields">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_castFields
            <span class="apidocSignatureSpan">(fields)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype._castUpdate">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_castUpdate
            <span class="apidocSignatureSpan">(obj, overwrite)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype._count">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_count
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype._execUpdate">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_execUpdate
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype._find">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_find
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype._findAndModify">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_findAndModify
            <span class="apidocSignatureSpan">(type, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype._findOne">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_findOne
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype._findOneAndRemove">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_findOneAndRemove
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype._findOneAndUpdate">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_findOneAndUpdate
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype._mergeUpdate">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_mergeUpdate
            <span class="apidocSignatureSpan">(doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype._optionsForExec">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_optionsForExec
            <span class="apidocSignatureSpan">(model)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype._replaceOne">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_replaceOne
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype._updateForExec">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_updateForExec
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype._updateMany">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_updateMany
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype._updateOne">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_updateOne
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.box">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>box
            <span class="apidocSignatureSpan">(ll, ur)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.cast">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>cast
            <span class="apidocSignatureSpan">(model, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.catch">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>catch
            <span class="apidocSignatureSpan">(reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.center">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>center
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.centerSphere">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>centerSphere
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.collation">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>collation
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.constructor">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>constructor
            <span class="apidocSignatureSpan">(conditions, options, model, collection)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.count">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>count
            <span class="apidocSignatureSpan">(conditions, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.cursor">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>cursor
            <span class="apidocSignatureSpan">(opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.deleteMany">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>deleteMany
            <span class="apidocSignatureSpan">(cond, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.deleteOne">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>deleteOne
            <span class="apidocSignatureSpan">(cond, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.distinct">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>distinct
            <span class="apidocSignatureSpan">(field, conditions, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.exec">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>exec
            <span class="apidocSignatureSpan">(op, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.find">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>find
            <span class="apidocSignatureSpan">(conditions, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.findOne">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>findOne
            <span class="apidocSignatureSpan">(conditions, projection, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.findOneAndRemove">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>findOneAndRemove
            <span class="apidocSignatureSpan">(conditions, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.findOneAndUpdate">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>findOneAndUpdate
            <span class="apidocSignatureSpan">(criteria, doc, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.getQuery">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>getQuery
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.getUpdate">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>getUpdate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.lean">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>lean
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.maxscan">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>maxscan
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.merge">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>merge
            <span class="apidocSignatureSpan">(source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.mongooseOptions">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>mongooseOptions
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.near">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>near
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.nearSphere">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>nearSphere
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.populate">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>populate
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.read">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>read
            <span class="apidocSignatureSpan">(pref, tags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.remove">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>remove
            <span class="apidocSignatureSpan">(cond, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.replaceOne">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>replaceOne
            <span class="apidocSignatureSpan">(conditions, doc, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.setOptions">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>setOptions
            <span class="apidocSignatureSpan">(options, overwrite)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.sort">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>sort
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.stream">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>stream
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.tailable">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>tailable
            <span class="apidocSignatureSpan">(val, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.then">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>then
            <span class="apidocSignatureSpan">(resolve, reject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.toConstructor">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>toConstructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.update">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>update
            <span class="apidocSignatureSpan">(conditions, doc, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.updateMany">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>updateMany
            <span class="apidocSignatureSpan">(conditions, doc, options, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.query.prototype.updateOne">
            function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>updateOne
            <span class="apidocSignatureSpan">(conditions, doc, options, callback)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_conditions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.query.prototype.</span>options</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.querycursor">module mongoose.querycursor</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querycursor.querycursor">
            function <span class="apidocSignatureSpan">mongoose.</span>querycursor
            <span class="apidocSignatureSpan">(query, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querycursor.super_">
            function <span class="apidocSignatureSpan">mongoose.querycursor.</span>super_
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.querycursor.prototype">module mongoose.querycursor.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querycursor.prototype._markError">
            function <span class="apidocSignatureSpan">mongoose.querycursor.prototype.</span>_markError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querycursor.prototype._read">
            function <span class="apidocSignatureSpan">mongoose.querycursor.prototype.</span>_read
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querycursor.prototype.close">
            function <span class="apidocSignatureSpan">mongoose.querycursor.prototype.</span>close
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querycursor.prototype.eachAsync">
            function <span class="apidocSignatureSpan">mongoose.querycursor.prototype.</span>eachAsync
            <span class="apidocSignatureSpan">(fn, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querycursor.prototype.map">
            function <span class="apidocSignatureSpan">mongoose.querycursor.prototype.</span>map
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querycursor.prototype.next">
            function <span class="apidocSignatureSpan">mongoose.querycursor.prototype.</span>next
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.queryhelpers">module mongoose.queryhelpers</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.queryhelpers.applyPaths">
            function <span class="apidocSignatureSpan">mongoose.queryhelpers.</span>applyPaths
            <span class="apidocSignatureSpan">(fields, schema)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.queryhelpers.createModel">
            function <span class="apidocSignatureSpan">mongoose.queryhelpers.</span>createModel
            <span class="apidocSignatureSpan">(model, doc, fields)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.queryhelpers.preparePopulationOptions">
            function <span class="apidocSignatureSpan">mongoose.queryhelpers.</span>preparePopulationOptions
            <span class="apidocSignatureSpan">(query, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.queryhelpers.preparePopulationOptionsMQ">
            function <span class="apidocSignatureSpan">mongoose.queryhelpers.</span>preparePopulationOptionsMQ
            <span class="apidocSignatureSpan">(query, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.querystream">module mongoose.querystream</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querystream.querystream">
            function <span class="apidocSignatureSpan">mongoose.</span>querystream
            <span class="apidocSignatureSpan">(query, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.querystream.prototype">module mongoose.querystream.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querystream.prototype.__next">
            function <span class="apidocSignatureSpan">mongoose.querystream.prototype.</span>__next
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querystream.prototype._init">
            function <span class="apidocSignatureSpan">mongoose.querystream.prototype.</span>_init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querystream.prototype._next">
            function <span class="apidocSignatureSpan">mongoose.querystream.prototype.</span>_next
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querystream.prototype._onNextObject">
            function <span class="apidocSignatureSpan">mongoose.querystream.prototype.</span>_onNextObject
            <span class="apidocSignatureSpan">(err, doc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querystream.prototype.destroy">
            function <span class="apidocSignatureSpan">mongoose.querystream.prototype.</span>destroy
            <span class="apidocSignatureSpan">(err)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querystream.prototype.pause">
            function <span class="apidocSignatureSpan">mongoose.querystream.prototype.</span>pause
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.querystream.prototype.resume">
            function <span class="apidocSignatureSpan">mongoose.querystream.prototype.</span>resume
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.schema">module mongoose.schema</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.schema">
            function <span class="apidocSignatureSpan">mongoose.</span>schema
            <span class="apidocSignatureSpan">(obj, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.ObjectId">
            function <span class="apidocSignatureSpan">mongoose.schema.</span>ObjectId
            <span class="apidocSignatureSpan">(key, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.interpretAsType">
            function <span class="apidocSignatureSpan">mongoose.schema.</span>interpretAsType
            <span class="apidocSignatureSpan">(path, obj, options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.schema.</span>Types</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.schema.</span>reserved</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.schema.prototype">module mongoose.schema.prototype</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>instanceOfSchema</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype._getPathType">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>_getPathType
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype._getSchema">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>_getSchema
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype._getVirtual">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>_getVirtual
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.add">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>add
            <span class="apidocSignatureSpan">(obj, prefix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.clone">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>clone
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.constructor">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>constructor
            <span class="apidocSignatureSpan">(obj, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.defaultOptions">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>defaultOptions
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.eachPath">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>eachPath
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.get">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>get
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.hasMixedParent">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>hasMixedParent
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.index">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>index
            <span class="apidocSignatureSpan">(fields, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.indexedPaths">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>indexedPaths
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.indexes">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>indexes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.loadClass">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>loadClass
            <span class="apidocSignatureSpan">(model, virtualsOnly)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.method">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>method
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.path">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>path
            <span class="apidocSignatureSpan">(path, obj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.pathType">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>pathType
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.plugin">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>plugin
            <span class="apidocSignatureSpan">(fn, opts)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.post">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>post
            <span class="apidocSignatureSpan">(method, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.pre">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>pre
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.queue">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>queue
            <span class="apidocSignatureSpan">(name, args)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.remove">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>remove
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.requiredPaths">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>requiredPaths
            <span class="apidocSignatureSpan">(invalidate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.set">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>set
            <span class="apidocSignatureSpan">(key, value, _tags)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.setupTimestamp">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>setupTimestamp
            <span class="apidocSignatureSpan">(timestamps)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.static">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>static
            <span class="apidocSignatureSpan">(name, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.virtual">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>virtual
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schema.prototype.virtualpath">
            function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>virtualpath
            <span class="apidocSignatureSpan">(name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.schematype">module mongoose.schematype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.schematype">
            function <span class="apidocSignatureSpan">mongoose.</span>schematype
            <span class="apidocSignatureSpan">(path, options, instance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.CastError">
            function <span class="apidocSignatureSpan">mongoose.schematype.</span>CastError
            <span class="apidocSignatureSpan">(type, value, path, reason)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.ValidatorError">
            function <span class="apidocSignatureSpan">mongoose.schematype.</span>ValidatorError
            <span class="apidocSignatureSpan">(properties)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype._isRef">
            function <span class="apidocSignatureSpan">mongoose.schematype.</span>_isRef
            <span class="apidocSignatureSpan">(self, value, doc, init)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.schematype.prototype">module mongoose.schematype.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.applyGetters">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>applyGetters
            <span class="apidocSignatureSpan">(value, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.applySetters">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>applySetters
            <span class="apidocSignatureSpan">(value, scope, init, priorVal, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.castForQuery">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>castForQuery
            <span class="apidocSignatureSpan">($conditional, val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.checkRequired">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>checkRequired
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.default">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>default
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.doValidate">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>doValidate
            <span class="apidocSignatureSpan">(value, fn, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.doValidateSync">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>doValidateSync
            <span class="apidocSignatureSpan">(value, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.get">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>get
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.getDefault">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>getDefault
            <span class="apidocSignatureSpan">(scope, init)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.index">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>index
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.required">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>required
            <span class="apidocSignatureSpan">(required, message)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.select">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>select
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.set">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>set
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.sparse">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>sparse
            <span class="apidocSignatureSpan">(bool)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.text">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>text
            <span class="apidocSignatureSpan">(bool)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.unique">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>unique
            <span class="apidocSignatureSpan">(bool)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.schematype.prototype.validate">
            function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>validate
            <span class="apidocSignatureSpan">(obj, message, type)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.statemachine">module mongoose.statemachine</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.statemachine.statemachine">
            function <span class="apidocSignatureSpan">mongoose.</span>statemachine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.statemachine.ctor">
            function <span class="apidocSignatureSpan">mongoose.statemachine.</span>ctor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.statemachine.prototype">module mongoose.statemachine.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.statemachine.prototype._changeState">
            function <span class="apidocSignatureSpan">mongoose.statemachine.prototype.</span>_changeState
            <span class="apidocSignatureSpan">(path, nextState)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.statemachine.prototype._iter">
            function <span class="apidocSignatureSpan">mongoose.statemachine.prototype.</span>_iter
            <span class="apidocSignatureSpan">(iterMethod)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.statemachine.prototype.clear">
            function <span class="apidocSignatureSpan">mongoose.statemachine.prototype.</span>clear
            <span class="apidocSignatureSpan">(state)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.statemachine.prototype.forEach">
            function <span class="apidocSignatureSpan">mongoose.statemachine.prototype.</span>forEach
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.statemachine.prototype.map">
            function <span class="apidocSignatureSpan">mongoose.statemachine.prototype.</span>map
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.statemachine.prototype.some">
            function <span class="apidocSignatureSpan">mongoose.statemachine.prototype.</span>some
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.utils">module mongoose.utils</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.PopulateOptions">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>PopulateOptions
            <span class="apidocSignatureSpan">(path, select, match, options, model, subPopulate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.args">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>args
            <span class="apidocSignatureSpan">(args, slice, sliceEnd)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.clone">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>clone
            <span class="apidocSignatureSpan">(obj, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.decorate">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>decorate
            <span class="apidocSignatureSpan">(destination, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.deepEqual">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>deepEqual
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.each">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>each
            <span class="apidocSignatureSpan">(arr, fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.expires">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>expires
            <span class="apidocSignatureSpan">(object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.getFunctionName">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>getFunctionName
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.getValue">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>getValue
            <span class="apidocSignatureSpan">(path, obj, map)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.isMongooseObject">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>isMongooseObject
            <span class="apidocSignatureSpan">(v)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.isNullOrUndefined">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>isNullOrUndefined
            <span class="apidocSignatureSpan">(val)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.isObject">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>isObject
            <span class="apidocSignatureSpan">(arg)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.merge">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>merge
            <span class="apidocSignatureSpan">(to, from, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.mergeClone">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>mergeClone
            <span class="apidocSignatureSpan">(to, fromObj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.options">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>options
            <span class="apidocSignatureSpan">(defaults, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.populate">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>populate
            <span class="apidocSignatureSpan">(path, select, model, match, options, subPopulate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.random">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>random
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.setValue">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>setValue
            <span class="apidocSignatureSpan">(path, val, obj, map)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.tick">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>tick
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.toCollectionName">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>toCollectionName
            <span class="apidocSignatureSpan">(name, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.utils.toObject">
            function <span class="apidocSignatureSpan">mongoose.utils.</span>toObject
            <span class="apidocSignatureSpan">(obj)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.utils.</span>array</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.utils.</span>buffer</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.utils.</span>object</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.utils.</span>pluralization</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">mongoose.utils.</span>uncountables</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.virtualtype">module mongoose.virtualtype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.virtualtype.virtualtype">
            function <span class="apidocSignatureSpan">mongoose.</span>virtualtype
            <span class="apidocSignatureSpan">(options, name)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.mongoose.virtualtype.prototype">module mongoose.virtualtype.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.virtualtype.prototype.applyGetters">
            function <span class="apidocSignatureSpan">mongoose.virtualtype.prototype.</span>applyGetters
            <span class="apidocSignatureSpan">(value, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.virtualtype.prototype.applySetters">
            function <span class="apidocSignatureSpan">mongoose.virtualtype.prototype.</span>applySetters
            <span class="apidocSignatureSpan">(value, scope)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.virtualtype.prototype.get">
            function <span class="apidocSignatureSpan">mongoose.virtualtype.prototype.</span>get
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.mongoose.virtualtype.prototype.set">
            function <span class="apidocSignatureSpan">mongoose.virtualtype.prototype.</span>set
            <span class="apidocSignatureSpan">(fn)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose" id="apidoc.module.mongoose">module mongoose</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.ES6Promise" id="apidoc.element.mongoose.ES6Promise">
        function <span class="apidocSignatureSpan">mongoose.</span>ES6Promise
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ES6Promise() {
  throw new Error(&#x27;Can\&#x27;t use ES6 promise with mpromise style constructor&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate" id="apidoc.element.mongoose.aggregate">
        function <span class="apidocSignatureSpan">mongoose.</span>aggregate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Aggregate() {
  this._pipeline = [];
  this._model = undefined;
  this.options = undefined;

  if (arguments.length === 1 &#x26;&#x26; util.isArray(arguments[0])) {
    this.append.apply(this, arguments[0]);
  } else {
    this.append.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* ####Example:
*
*     new Aggregate();
*     new Aggregate({ $project: { a: 1, b: 1 } });
*     new Aggregate({ $project: { a: 1, b: 1 } }, { $skip: 5 });
*     new Aggregate([{ $project: { a: 1, b: 1 } }, { $skip: 5 }]);
*
* Returned when calling Model.<span class="apidocCodeKeywordSpan">aggregate</span>().
*
* ####Example:
*
*     Model
*     .aggregate({ $match: { age: { $gte: 21 }}})
*     .unwind(&#x27;tags&#x27;)
*     .exec(callback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.browserDocument" id="apidoc.element.mongoose.browserDocument">
        function <span class="apidocSignatureSpan">mongoose.</span>browserDocument
        <span class="apidocSignatureSpan">(obj, schema, fields, skipId, skipInit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Document(obj, schema, fields, skipId, skipInit) {
  if (!(this instanceof Document)) {
    return new Document(obj, schema, fields, skipId, skipInit);
  }


  if (utils.isObject(schema) &#x26;&#x26; !schema.instanceOfSchema) {
    schema = new Schema(schema);
  }

  // When creating EmbeddedDocument, it already has the schema and he doesn&#x27;t need the _id
  schema = this.schema || schema;

  // Generate ObjectId if it is missing, but it requires a scheme
  if (!this.schema &#x26;&#x26; schema.options._id) {
    obj = obj || {};

    if (obj._id === undefined) {
      obj._id = new ObjectId();
    }
  }

  if (!schema) {
    throw new MongooseError.MissingSchemaError();
  }

  this.$__setSchema(schema);

  this.$__ = new InternalCache;
  this.$__.emitter = new EventEmitter();
  this.isNew = true;
  this.errors = undefined;

  if (typeof fields === &#x27;boolean&#x27;) {
    this.$__.strictMode = fields;
    fields = undefined;
  } else {
    this.$__.strictMode = this.schema.options &#x26;&#x26; this.schema.options.strict;
    this.$__.selected = fields;
  }

  var required = this.schema.requiredPaths();
  for (var i = 0; i &#x3c; required.length; ++i) {
    this.$__.activePaths.require(required[i]);
  }

  this.$__.emitter.setMaxListeners(0);
  this._doc = this.$__buildDoc(obj, fields, skipId);

  if (!skipInit &#x26;&#x26; obj) {
    this.init(obj);
  }

  this.$__registerHooksFromSchema();

  // apply methods
  for (var m in schema.methods) {
    this[m] = schema.methods[m];
  }
  // apply statics
  for (var s in schema.statics) {
    this[s] = schema.statics[s];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.collection" id="apidoc.element.mongoose.collection">
        function <span class="apidocSignatureSpan">mongoose.</span>collection
        <span class="apidocSignatureSpan">(name, conn, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Collection(name, conn, opts) {
  if (opts === void 0) {
    opts = {};
  }
  if (opts.capped === void 0) {
    opts.capped = {};
  }

  opts.bufferCommands = undefined === opts.bufferCommands
      ? true
      : opts.bufferCommands;

  if (typeof opts.capped === &#x27;number&#x27;) {
    opts.capped = {size: opts.capped};
  }

  this.opts = opts;
  this.name = name;
  this.collectionName = name;
  this.conn = conn;
  this.queue = [];
  this.buffer = this.opts.bufferCommands;
  this.emitter = new EventEmitter();

  if (STATES.connected === this.conn.readyState) {
    this.onOpen();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
model.prototype.$__setSchema(schema);

var collectionOptions = {
  bufferCommands: schema.options.bufferCommands,
  capped: schema.options.capped
};

model.prototype.collection = connection.<span class="apidocCodeKeywordSpan">collection</span>(
    collectionName
    , collectionOptions
);

// apply methods and statics
applyMethods(model, schema);
applyStatics(model, schema);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.connection" id="apidoc.element.mongoose.connection">
        function <span class="apidocSignatureSpan">mongoose.</span>connection
        <span class="apidocSignatureSpan">(base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Connection(base) {
  this.base = base;
  this.collections = {};
  this.models = {};
  this.config = {autoIndex: true};
  this.replica = false;
  this.hosts = null;
  this.host = null;
  this.port = null;
  this.user = null;
  this.pass = null;
  this.name = null;
  this.options = null;
  this.otherDbs = [];
  this._readyState = STATES.disconnected;
  this._closeCalled = false;
  this._hasOpened = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document" id="apidoc.element.mongoose.document">
        function <span class="apidocSignatureSpan">mongoose.</span>document
        <span class="apidocSignatureSpan">(obj, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Document(obj, fields, skipId) {
  this.$__ = new InternalCache;
  this.$__.emitter = new EventEmitter();
  this.isNew = true;
  this.errors = undefined;

  var schema = this.schema;

  if (typeof fields === &#x27;boolean&#x27;) {
    this.$__.strictMode = fields;
    fields = undefined;
  } else {
    this.$__.strictMode = schema.options &#x26;&#x26; schema.options.strict;
    this.$__.selected = fields;
  }

  var required = schema.requiredPaths(true);
  for (var i = 0; i &#x3c; required.length; ++i) {
    this.$__.activePaths.require(required[i]);
  }

  this.$__.emitter.setMaxListeners(0);
  this._doc = this.$__buildDoc(obj, fields, skipId);

  if (obj) {
    if (obj instanceof Document) {
      this.isNew = obj.isNew;
    }
    // Skip set hooks
    if (this.$__original_set) {
      this.$__original_set(obj, undefined, true);
    } else {
      this.set(obj, undefined, true);
    }
  }

  if (!schema.options.strict &#x26;&#x26; obj) {
    var _this = this,
        keys = Object.keys(this._doc);

    keys.forEach(function(key) {
      if (!(key in schema.tree)) {
        defineKey(key, null, _this);
      }
    });
  }

  applyQueue(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.error" id="apidoc.element.mongoose.error">
        function <span class="apidocSignatureSpan">mongoose.</span>error
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MongooseError(msg) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this);
  } else {
    this.stack = new Error().stack;
  }
  this.message = msg;
  this.name = &#x27;MongooseError&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!rgxProtocol.test(host)) {
  host = &#x27;mongodb://&#x27; + host;
}

try {
  parsed = muri(host);
} catch (err) {
  this.<span class="apidocCodeKeywordSpan">error</span>(err, callback);
  return new Promise.ES6(function(resolve, reject) {
    reject(err);
  });
}

database = parsed.db;
host = parsed.hosts[0].host || parsed.hosts[0].ipc;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model" id="apidoc.element.mongoose.model">
        function <span class="apidocSignatureSpan">mongoose.</span>model
        <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Model(doc, fields, skipId) {
  Document.call(this, doc, fields, skipId, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

Take a look at the example in `examples/schema.js` for an end-to-end example of a typical setup.

### Accessing a Model

Once we define a model through `mongoose.<span class="apidocCodeKeywordSpan">model</span>(&#x27;ModelName&#x27;, mySchema)`, we
can access it through the same function

```js
var myModel = mongoose.model(&#x27;ModelName&#x27;);
```

Or just do it all at once
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.promise" id="apidoc.element.mongoose.promise">
        function <span class="apidocSignatureSpan">mongoose.</span>promise
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise(fn) {
  MPromise.call(this, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query" id="apidoc.element.mongoose.query">
        function <span class="apidocSignatureSpan">mongoose.</span>query
        <span class="apidocSignatureSpan">(conditions, options, model, collection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Query(conditions, options, model, collection) {
  // this stuff is for dealing with custom queries created by #toConstructor
  if (!this._mongooseOptions) {
    this._mongooseOptions = {};
  }

  // this is the case where we have a CustomQuery, we need to check if we got
  // options passed in, and if we did, merge them in
  if (options) {
    var keys = Object.keys(options);
    for (var i = 0; i &#x3c; keys.length; ++i) {
      var k = keys[i];
      this._mongooseOptions[k] = options[k];
    }
  }

  if (collection) {
    this.mongooseCollection = collection;
  }

  if (model) {
    this.model = model;
    this.schema = model.schema;
  }

  // this is needed because map reduce returns a model that can be queried, but
  // all of the queries on said model should be lean
  if (this.model &#x26;&#x26; this.model._mapreduce) {
    this.lean();
  }

  // inherit mquery
  mquery.call(this, this.mongooseCollection, options);

  if (conditions) {
    this.find(conditions);
  }

  if (this.schema) {
    var kareemOptions = {
      useErrorHandlers: true,
      numCallbackParams: 1
    };
    this._count = this.model.hooks.createWrapper(&#x27;count&#x27;,
        Query.prototype._count, this, kareemOptions);
    this._execUpdate = this.model.hooks.createWrapper(&#x27;update&#x27;,
        Query.prototype._execUpdate, this, kareemOptions);
    this._find = this.model.hooks.createWrapper(&#x27;find&#x27;,
        Query.prototype._find, this, kareemOptions);
    this._findOne = this.model.hooks.createWrapper(&#x27;findOne&#x27;,
        Query.prototype._findOne, this, kareemOptions);
    this._findOneAndRemove = this.model.hooks.createWrapper(&#x27;findOneAndRemove&#x27;,
        Query.prototype._findOneAndRemove, this, kareemOptions);
    this._findOneAndUpdate = this.model.hooks.createWrapper(&#x27;findOneAndUpdate&#x27;,
        Query.prototype._findOneAndUpdate, this, kareemOptions);
    this._replaceOne = this.model.hooks.createWrapper(&#x27;replaceOne&#x27;,
        Query.prototype._replaceOne, this, kareemOptions);
    this._updateMany = this.model.hooks.createWrapper(&#x27;updateMany&#x27;,
        Query.prototype._updateMany, this, kareemOptions);
    this._updateOne = this.model.hooks.createWrapper(&#x27;updateOne&#x27;,
        Query.prototype._updateOne, this, kareemOptions);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.querycursor" id="apidoc.element.mongoose.querycursor">
        function <span class="apidocSignatureSpan">mongoose.</span>querycursor
        <span class="apidocSignatureSpan">(query, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QueryCursor(query, options) {
  Readable.call(this, { objectMode: true });

  this.cursor = null;
  this.query = query;
  this._transforms = options.transform ? [options.transform] : [];
  var _this = this;
  var model = query.model;
  model.hooks.execPre(&#x27;find&#x27;, query, function() {
    model.collection.find(query._conditions, options, function(err, cursor) {
      if (_this._error) {
        cursor.close(function() {});
        _this.listeners(&#x27;error&#x27;).length &#x3e; 0 &#x26;&#x26; _this.emit(&#x27;error&#x27;, _this._error);
      }
      if (err) {
        return _this.emit(&#x27;error&#x27;, err);
      }
      _this.cursor = cursor;
      _this.emit(&#x27;cursor&#x27;, cursor);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.querystream" id="apidoc.element.mongoose.querystream">
        function <span class="apidocSignatureSpan">mongoose.</span>querystream
        <span class="apidocSignatureSpan">(query, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QueryStream(query, options) {
  Stream.call(this);

  this.query = query;
  this.readable = true;
  this.paused = false;
  this._cursor = null;
  this._destroyed = null;
  this._fields = null;
  this._buffer = null;
  this._inline = T_INIT;
  this._running = false;
  this._transform = options &#x26;&#x26; typeof options.transform === &#x27;function&#x27;
      ? options.transform
      : K;

  // give time to hook up events
  var _this = this;
  process.nextTick(function() {
    _this._init();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema" id="apidoc.element.mongoose.schema">
        function <span class="apidocSignatureSpan">mongoose.</span>schema
        <span class="apidocSignatureSpan">(obj, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Schema(obj, options) {
  if (!(this instanceof Schema)) {
    return new Schema(obj, options);
  }

  this.obj = obj;
  this.paths = {};
  this.subpaths = {};
  this.virtuals = {};
  this.singleNestedPaths = {};
  this.nested = {};
  this.inherits = {};
  this.callQueue = [];
  this._indexes = [];
  this.methods = {};
  this.statics = {};
  this.tree = {};
  this.query = {};
  this.childSchemas = [];

  this.s = {
    hooks: new Kareem(),
    kareemHooks: IS_KAREEM_HOOK
  };

  this.options = this.defaultOptions(options);

  // build paths
  if (obj) {
    this.add(obj);
  }

  // check if _id&#x27;s value is a subdocument (gh-2276)
  var _idSubDoc = obj &#x26;&#x26; obj._id &#x26;&#x26; utils.isObject(obj._id);

  // ensure the documents get an auto _id unless disabled
  var auto_id = !this.paths[&#x27;_id&#x27;] &#x26;&#x26;
      (!this.options.noId &#x26;&#x26; this.options._id) &#x26;&#x26; !_idSubDoc;

  if (auto_id) {
    obj = {_id: {auto: true}};
    obj._id[this.options.typeKey] = Schema.ObjectId;
    this.add(obj);
  }

  // ensure the documents receive an id getter unless disabled
  var autoid = !this.paths[&#x27;id&#x27;] &#x26;&#x26;
      (!this.options.noVirtualId &#x26;&#x26; this.options.id);
  if (autoid) {
    this.virtual(&#x27;id&#x27;).get(idGetter);
  }

  for (var i = 0; i &#x3c; this._defaultMiddleware.length; ++i) {
    var m = this._defaultMiddleware[i];
    this[m.kind](m.hook, !!m.isAsync, m.fn);
  }

  if (this.options.timestamps) {
    this.setupTimestamp(this.options.timestamps);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype" id="apidoc.element.mongoose.schematype">
        function <span class="apidocSignatureSpan">mongoose.</span>schematype
        <span class="apidocSignatureSpan">(path, options, instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SchemaType(path, options, instance) {
  this.path = path;
  this.instance = instance;
  this.validators = [];
  this.setters = [];
  this.getters = [];
  this.options = options;
  this._index = null;
  this.selected;

  for (var i in options) {
    if (this[i] &#x26;&#x26; typeof this[i] === &#x27;function&#x27;) {
      // { unique: true, index: true }
      if (i === &#x27;index&#x27; &#x26;&#x26; this._index) {
        continue;
      }

      var opts = Array.isArray(options[i])
          ? options[i]
          : [options[i]];

      this[i].apply(this, opts);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.statemachine" id="apidoc.element.mongoose.statemachine">
        function <span class="apidocSignatureSpan">mongoose.</span>statemachine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StateMachine() {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.virtualtype" id="apidoc.element.mongoose.virtualtype">
        function <span class="apidocSignatureSpan">mongoose.</span>virtualtype
        <span class="apidocSignatureSpan">(options, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VirtualType(options, name) {
  this.path = name;
  this.getters = [];
  this.setters = [];
  this.options = options || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


















































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.ES6Promise" id="apidoc.module.mongoose.ES6Promise">module mongoose.ES6Promise</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.ES6Promise.ES6Promise" id="apidoc.element.mongoose.ES6Promise.ES6Promise">
        function <span class="apidocSignatureSpan">mongoose.</span>ES6Promise
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ES6Promise() {
  throw new Error(&#x27;Can\&#x27;t use ES6 promise with mpromise style constructor&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.ES6Promise.use" id="apidoc.element.mongoose.ES6Promise.use">
        function <span class="apidocSignatureSpan">mongoose.ES6Promise.</span>use
        <span class="apidocSignatureSpan">(Promise)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">use = function (Promise) {
  ES6Promise.ES6 = Promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/

Promise.set = function(lib) {
 if (lib === MPromise) {
   return Promise.reset();
 }
 Promise._promise = require(&#x27;./ES6Promise&#x27;);
 Promise._promise.<span class="apidocCodeKeywordSpan">use</span>(lib);
 require(&#x27;mquery&#x27;).Promise = Promise._promise.ES6;
};

/**
* Resets to using mpromise
*
* @api private
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.aggregate" id="apidoc.module.mongoose.aggregate">module mongoose.aggregate</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.aggregate.aggregate" id="apidoc.element.mongoose.aggregate.aggregate">
        function <span class="apidocSignatureSpan">mongoose.</span>aggregate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Aggregate() {
  this._pipeline = [];
  this._model = undefined;
  this.options = undefined;

  if (arguments.length === 1 &#x26;&#x26; util.isArray(arguments[0])) {
    this.append.apply(this, arguments[0]);
  } else {
    this.append.apply(this, arguments);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* ####Example:
*
*     new Aggregate();
*     new Aggregate({ $project: { a: 1, b: 1 } });
*     new Aggregate({ $project: { a: 1, b: 1 } }, { $skip: 5 });
*     new Aggregate([{ $project: { a: 1, b: 1 } }, { $skip: 5 }]);
*
* Returned when calling Model.<span class="apidocCodeKeywordSpan">aggregate</span>().
*
* ####Example:
*
*     Model
*     .aggregate({ $match: { age: { $gte: 21 }}})
*     .unwind(&#x27;tags&#x27;)
*     .exec(callback)
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.aggregate.prototype" id="apidoc.module.mongoose.aggregate.prototype">module mongoose.aggregate.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.addCursorFlag" id="apidoc.element.mongoose.aggregate.prototype.addCursorFlag">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>addCursorFlag
        <span class="apidocSignatureSpan">(flag, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addCursorFlag = function (flag, value) {
  if (!this.options) {
    this.options = {};
  }
  this.options[flag] = value;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Adds a [cursor flag](http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#addCursorFlag)
 *
 * ####Example:
 *
 *     Model.aggregate(..).<span class="apidocCodeKeywordSpan">addCursorFlag</span>(&#x27;noCursorTimeout&#x27;, true).exec();
 *
 * @param {String} flag
 * @param {Boolean} value
 * @see mongodb http://mongodb.github.io/node-mongodb-native/2.1/api/Cursor.html#addCursorFlag
 */

Aggregate.prototype.addCursorFlag = function(flag, value) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.allowDiskUse" id="apidoc.element.mongoose.aggregate.prototype.allowDiskUse">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>allowDiskUse
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">allowDiskUse = function (value) {
  if (!this.options) {
    this.options = {};
  }
  this.options.allowDiskUse = value;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Sets the allowDiskUse option for the aggregation query (ignored for &#x3c; 2.6.0)
 *
 * ####Example:
 *
 *     Model.aggregate(..).<span class="apidocCodeKeywordSpan">allowDiskUse</span>(true).exec(callback)
 *
 * @param {Boolean} value Should tell server it can use hard drive to store data during aggregation.
 * @param {Array} [tags] optional tags for this query
 * @see mongodb http://docs.mongodb.org/manual/reference/command/aggregate/
 */

Aggregate.prototype.allowDiskUse = function(value) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.append" id="apidoc.element.mongoose.aggregate.prototype.append">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>append
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">append = function () {
  var args = (arguments.length === 1 &#x26;&#x26; util.isArray(arguments[0]))
      ? arguments[0]
      : utils.args(arguments);

  if (!args.every(isOperator)) {
    throw new Error(&#x27;Arguments must be aggregate pipeline operators&#x27;);
  }

  this._pipeline = this._pipeline.concat(args);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Appends new operators to this aggregate pipeline
*
* ####Examples:
*
*     aggregate.<span class="apidocCodeKeywordSpan">append</span>({ $project: { field: 1 }}, { $limit: 2 });
*
*     // or pass an array
*     var pipeline = [{ $match: { daw: &#x27;Logic Audio X&#x27; }} ];
*     aggregate.append(pipeline);
*
* @param {Object} ops operator(s) to append
* @return {Aggregate}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.collation" id="apidoc.element.mongoose.aggregate.prototype.collation">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>collation
        <span class="apidocSignatureSpan">(collation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collation = function (collation) {
  if (!this.options) {
    this.options = {};
  }
  this.options.collation = collation;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Adds a collation
 *
 * ####Example:
 *
 *     Model.aggregate(..).<span class="apidocCodeKeywordSpan">collation</span>({ locale: &#x27;en_US&#x27;, strength: 1 }).exec
();
 *
 * @param {Object} collation options
 * @param {Boolean} value
 * @see mongodb http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#aggregate
 */

Aggregate.prototype.collation = function(collation) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.cursor" id="apidoc.element.mongoose.aggregate.prototype.cursor">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>cursor
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cursor = function (options) {
  if (!this.options) {
    this.options = {};
  }
  this.options.cursor = options || {};
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Sets the cursor option option for the aggregation query (ignored for &#x3c; 2.6.0).
* Note the different syntax below: .exec() returns a cursor object, and no callback
* is necessary.
*
* ####Example:
*
*     var cursor = Model.aggregate(..).<span class="apidocCodeKeywordSpan">cursor</span>({ batchSize: 1000 }).exec();
*     cursor.each(function(error, doc) {
*       // use doc
*     });
*
* @param {Object} options set the cursor batch size
* @see mongodb http://mongodb.github.io/node-mongodb-native/2.0/api/AggregationCursor.html
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.exec" id="apidoc.element.mongoose.aggregate.prototype.exec">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>exec
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exec = function (callback) {
  if (!this._model) {
    throw new Error(&#x27;Aggregate not bound to any Model&#x27;);
  }
  var _this = this;
  var Promise = PromiseProvider.get();
  var options = utils.clone(this.options);

  if (options &#x26;&#x26; options.cursor) {
    if (options.cursor.async) {
      delete options.cursor.async;
      return new Promise.ES6(function(resolve) {
        if (!_this._model.collection.buffer) {
          process.nextTick(function() {
            var cursor = _this._model.collection.
              aggregate(_this._pipeline, options || {});
            decorateCursor(cursor);
            resolve(cursor);
            callback &#x26;&#x26; callback(null, cursor);
          });
          return;
        }
        _this._model.collection.emitter.once(&#x27;queue&#x27;, function() {
          var cursor = _this._model.collection.
            aggregate(_this._pipeline, options || {});
          decorateCursor(cursor);
          resolve(cursor);
          callback &#x26;&#x26; callback(null, cursor);
        });
      });
    }
    var cursor = this._model.collection.
      aggregate(this._pipeline, this.options || {});
    decorateCursor(cursor);
    return cursor;
  }

  return new Promise.ES6(function(resolve, reject) {
    if (!_this._pipeline.length) {
      var err = new Error(&#x27;Aggregate has empty pipeline&#x27;);
      if (callback) {
        callback(err);
      }
      reject(err);
      return;
    }

    prepareDiscriminatorPipeline(_this);

    _this._model
        .collection
        .aggregate(_this._pipeline, _this.options || {}, function(error, result) {
          if (error) {
            if (callback) {
              callback(error);
            }
            reject(error);
            return;
          }

          if (callback) {
            callback(null, result);
          }
          resolve(result);
        });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* ES6 Promise wrapper constructor.
*
* Promises are returned from executed queries. Example:
*
*     var query = Candy.find({ bar: true });
*     var promise = query.<span class="apidocCodeKeywordSpan">exec</span>();
*
* DEPRECATED. Mongoose 5.0 will use native promises by default (or bluebird,
* if native promises are not present) but still
* support plugging in your own ES6-compatible promises library. Mongoose 5.0
* will **not** support mpromise.
*
* @param {Function} fn a function which will be called when the promise is resolved that accepts `fn(err, ...){}` as signature
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.explain" id="apidoc.element.mongoose.aggregate.prototype.explain">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>explain
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">explain = function (callback) {
  var _this = this;
  var Promise = PromiseProvider.get();
  return new Promise.ES6(function(resolve, reject) {
    if (!_this._pipeline.length) {
      var err = new Error(&#x27;Aggregate has empty pipeline&#x27;);
      if (callback) {
        callback(err);
      }
      reject(err);
      return;
    }

    prepareDiscriminatorPipeline(_this);

    _this._model
        .collection
        .aggregate(_this._pipeline, _this.options || {})
        .explain(function(error, result) {
          if (error) {
            if (callback) {
              callback(error);
            }
            reject(error);
            return;
          }

          if (callback) {
            callback(null, result);
          }
          resolve(result);
        });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Execute the aggregation with explain
 *
 * ####Example:
 *
 *     Model.aggregate(..).<span class="apidocCodeKeywordSpan">explain</span>(callback)
 *
 * @param {Function} callback
 * @return {Promise}
 */

Aggregate.prototype.explain = function(callback) {
var _this = this;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.facet" id="apidoc.element.mongoose.aggregate.prototype.facet">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>facet
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">facet = function (options) {
  return this.append({$facet: options});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Combines multiple aggregation pipelines.
*
* ####Example:
*     Model.aggregate(...)
*      .<span class="apidocCodeKeywordSpan">facet</span>({
*        books: [{ groupBy: &#x27;$author&#x27; }],
*        price: [{ $bucketAuto: { groupBy: &#x27;$price&#x27;, buckets: 2 } }]
*      })
*      .exec();
*
*     // Output: { books: [...], price: [{...}, {...}] }
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.graphLookup" id="apidoc.element.mongoose.aggregate.prototype.graphLookup">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>graphLookup
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">graphLookup = function (options) {
  var cloneOptions = {};
  if (options) {
    if (!utils.isObject(options)) {
      throw new TypeError(&#x27;Invalid graphLookup() argument. Must be an object.&#x27;);
    }

    utils.mergeClone(cloneOptions, options);
    var startWith = cloneOptions.startWith;

    if (startWith &#x26;&#x26; typeof startWith === &#x27;string&#x27;) {
      cloneOptions.startWith = cloneOptions.startWith.charAt(0) === &#x27;$&#x27; ?
        cloneOptions.startWith :
        &#x27;$&#x27; + cloneOptions.startWith;
    }

  }
  return this.append({ $graphLookup: cloneOptions });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Appends new custom $graphLookup operator(s) to this aggregate pipeline, performing a recursive search on a collection.
*
* Note that graphLookup can only consume at most 100MB of memory, and does not allow disk use even if `{ allowDiskUse: true }` is
 specified.
*
* #### Examples:
*      // Suppose we have a collection of courses, where a document might look like `{ _id: 0, name: &#x27;Calculus&#x27;, prerequisite
: &#x27;Trigonometry&#x27;}` and `{ _id: 0, name: &#x27;Trigonometry&#x27;, prerequisite: &#x27;Algebra&#x27; }`
*      aggregate.<span class="apidocCodeKeywordSpan">graphLookup</span>({ from: &#x27;courses&#x27;, startWith: &#x27;$prerequisite
&#x27;, connectFromField: &#x27;prerequisite&#x27;, connectToField: &#x27;name&#x27;, as: &#x27;prerequisites&#x27;, maxDepth: 3
 }) // this will recursively search the &#x27;courses&#x27; collection up to 3 prerequisites
*
* @see $graphLookup https://docs.mongodb.com/manual/reference/operator/aggregation/graphLookup/#pipe._S_graphLookup
* @param {Object} options to $graphLookup as described in the above link
* @return {Aggregate}
* @api public
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.group" id="apidoc.element.mongoose.aggregate.prototype.group">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>group
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">group = function (arg) {
  var op = {};
  op[&#x27;$&#x27; + $operator] = arg;
  return this.append(op);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Appends a new custom $group operator to this aggregate pipeline.
*
* ####Examples:
*
*     aggregate.<span class="apidocCodeKeywordSpan">group</span>({ _id: &#x22;$department&#x22; });
*
* @see $group http://docs.mongodb.org/manual/reference/aggregation/group/
* @method group
* @memberOf Aggregate
* @param {Object} arg $group operator contents
* @return {Aggregate}
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.limit" id="apidoc.element.mongoose.aggregate.prototype.limit">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>limit
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">limit = function (arg) {
  var op = {};
  op[&#x27;$&#x27; + $operator] = arg;
  return this.append(op);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/

/**
* Appends a new $limit operator to this aggregate pipeline.
*
* ####Examples:
*
*     aggregate.<span class="apidocCodeKeywordSpan">limit</span>(10);
*
* @see $limit http://docs.mongodb.org/manual/reference/aggregation/limit/
* @method limit
* @memberOf Aggregate
* @param {Number} num maximum number of records to pass to the next stage
* @return {Aggregate}
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.lookup" id="apidoc.element.mongoose.aggregate.prototype.lookup">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>lookup
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lookup = function (options) {
  return this.append({$lookup: options});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Appends new custom $lookup operator(s) to this aggregate pipeline.
*
* ####Examples:
*
*     aggregate.<span class="apidocCodeKeywordSpan">lookup</span>({ from: &#x27;users&#x27;, localField: &#x27;userId&#x27;, foreignField
: &#x27;_id&#x27;, as: &#x27;users&#x27; });
*
* @see $lookup https://docs.mongodb.org/manual/reference/operator/aggregation/lookup/#pipe._S_lookup
* @param {Object} options to $lookup as described in the above link
* @return {Aggregate}
* @api public
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.match" id="apidoc.element.mongoose.aggregate.prototype.match">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>match
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">match = function (arg) {
  var op = {};
  op[&#x27;$&#x27; + $operator] = arg;
  return this.append(op);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/

/**
* Appends a new custom $match operator to this aggregate pipeline.
*
* ####Examples:
*
*     aggregate.<span class="apidocCodeKeywordSpan">match</span>({ department: { $in: [ &#x22;sales&#x22;, &#x22;engineering&#x22
; } } });
*
* @see $match http://docs.mongodb.org/manual/reference/aggregation/match/
* @method match
* @memberOf Aggregate
* @param {Object} arg $match operator contents
* @return {Aggregate}
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.model" id="apidoc.element.mongoose.aggregate.prototype.model">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>model
        <span class="apidocSignatureSpan">(model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">model = function (model) {
  this._model = model;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

Take a look at the example in `examples/schema.js` for an end-to-end example of a typical setup.

### Accessing a Model

Once we define a model through `mongoose.<span class="apidocCodeKeywordSpan">model</span>(&#x27;ModelName&#x27;, mySchema)`, we
can access it through the same function

```js
var myModel = mongoose.model(&#x27;ModelName&#x27;);
```

Or just do it all at once
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.near" id="apidoc.element.mongoose.aggregate.prototype.near">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>near
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">near = function (arg) {
  var op = {};
  op.$geoNear = arg;
  return this.append(op);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* ####NOTE:
*
* **MUST** be used as the first operator in the pipeline.
*
* ####Examples:
*
*     aggregate.<span class="apidocCodeKeywordSpan">near</span>({
*       near: [40.724, -73.997],
*       distanceField: &#x22;dist.calculated&#x22;, // required
*       maxDistance: 0.008,
*       query: { type: &#x22;public&#x22; },
*       includeLocs: &#x22;dist.location&#x22;,
*       uniqueDocs: true,
*       num: 5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.out" id="apidoc.element.mongoose.aggregate.prototype.out">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>out
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">out = function (arg) {
  var op = {};
  op[&#x27;$&#x27; + $operator] = arg;
  return this.append(op);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.project" id="apidoc.element.mongoose.aggregate.prototype.project">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>project
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">project = function (arg) {
  var fields = {};

  if (typeof arg === &#x27;object&#x27; &#x26;&#x26; !util.isArray(arg)) {
    Object.keys(arg).forEach(function(field) {
      fields[field] = arg[field];
    });
  } else if (arguments.length === 1 &#x26;&#x26; typeof arg === &#x27;string&#x27;) {
    arg.split(/\s+/).forEach(function(field) {
      if (!field) {
        return;
      }
      var include = field[0] === &#x27;-&#x27; ? 0 : 1;
      if (include === 0) {
        field = field.substring(1);
      }
      fields[field] = include;
    });
  } else {
    throw new Error(&#x27;Invalid project() argument. Must be string or object&#x27;);
  }

  return this.append({$project: fields});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Appends a new $project operator to this aggregate pipeline.
*
* Mongoose query [selection syntax](#query_Query-select) is also supported.
*
* ####Examples:
*
*     // include a, include b, exclude _id
*     aggregate.<span class="apidocCodeKeywordSpan">project</span>(&#x22;a b -_id&#x22;);
*
*     // or you may use object notation, useful when
*     // you have keys already prefixed with a &#x22;-&#x22;
*     aggregate.project({a: 1, b: 1, _id: 0});
*
*     // reshaping documents
*     aggregate.project({
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.read" id="apidoc.element.mongoose.aggregate.prototype.read">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>read
        <span class="apidocSignatureSpan">(pref, tags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">read = function (pref, tags) {
  if (!this.options) {
    this.options = {};
  }
  read.call(this, pref, tags);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Sets the readPreference option for the aggregation query.
*
* ####Example:
*
*     Model.aggregate(..).<span class="apidocCodeKeywordSpan">read</span>(&#x27;primaryPreferred&#x27;).exec(callback)
*
* @param {String} pref one of the listed preference options or their aliases
* @param {Array} [tags] optional tags for this query
* @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
* @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.sample" id="apidoc.element.mongoose.aggregate.prototype.sample">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>sample
        <span class="apidocSignatureSpan">(size)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sample = function (size) {
  return this.append({$sample: {size: size}});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Appepnds new custom $sample operator(s) to this aggregate pipeline.
*
* ####Examples:
*
*     aggregate.<span class="apidocCodeKeywordSpan">sample</span>(3); // Add a pipeline that picks 3 random documents
*
* @see $sample https://docs.mongodb.org/manual/reference/operator/aggregation/sample/#pipe._S_sample
* @param {Number} size number of random documents to pick
* @return {Aggregate}
* @api public
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.skip" id="apidoc.element.mongoose.aggregate.prototype.skip">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>skip
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">skip = function (arg) {
  var op = {};
  op[&#x27;$&#x27; + $operator] = arg;
  return this.append(op);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/

/**
* Appends a new $skip operator to this aggregate pipeline.
*
* ####Examples:
*
*     aggregate.<span class="apidocCodeKeywordSpan">skip</span>(10);
*
* @see $skip http://docs.mongodb.org/manual/reference/aggregation/skip/
* @method skip
* @memberOf Aggregate
* @param {Number} num number of records to skip before next stage
* @return {Aggregate}
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.sort" id="apidoc.element.mongoose.aggregate.prototype.sort">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>sort
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sort = function (arg) {
  // TODO refactor to reuse the query builder logic

  var sort = {};

  if (arg.constructor.name === &#x27;Object&#x27;) {
    var desc = [&#x27;desc&#x27;, &#x27;descending&#x27;, -1];
    Object.keys(arg).forEach(function(field) {
      sort[field] = desc.indexOf(arg[field]) === -1 ? 1 : -1;
    });
  } else if (arguments.length === 1 &#x26;&#x26; typeof arg === &#x27;string&#x27;) {
    arg.split(/\s+/).forEach(function(field) {
      if (!field) {
        return;
      }
      var ascend = field[0] === &#x27;-&#x27; ? -1 : 1;
      if (ascend === -1) {
        field = field.substring(1);
      }
      sort[field] = ascend;
    });
  } else {
    throw new TypeError(&#x27;Invalid sort() argument. Must be a string or object.&#x27;);
  }

  return this.append({$sort: sort});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.
*
* If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path
 name is prefixed with `-` which will be treated as descending.
*
* ####Examples:
*
*     // these are equivalent
*     aggregate.<span class="apidocCodeKeywordSpan">sort</span>({ field: &#x27;asc&#x27;, test: -1 });
*     aggregate.sort(&#x27;field -test&#x27;);
*
* @see $sort http://docs.mongodb.org/manual/reference/aggregation/sort/
* @param {Object|String} arg
* @return {Aggregate} this
* @api public
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.then" id="apidoc.element.mongoose.aggregate.prototype.then">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>then
        <span class="apidocSignatureSpan">(resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">then = function (resolve, reject) {
  return this.exec().then(resolve, reject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* ####Example:
*
*     aggregate.exec(callback);
*
*     // Because a promise is returned, the `callback` is optional.
*     var promise = aggregate.exec();
*     promise.<span class="apidocCodeKeywordSpan">then</span>(..);
*
* @see Promise #promise_Promise
* @param {Function} [callback]
* @return {Promise}
* @api public
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.aggregate.prototype.unwind" id="apidoc.element.mongoose.aggregate.prototype.unwind">
        function <span class="apidocSignatureSpan">mongoose.aggregate.prototype.</span>unwind
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwind = function () {
  var args = utils.args(arguments);

  var res = [];
  for (var i = 0; i &#x3c; args.length; ++i) {
    var arg = args[i];
    if (arg &#x26;&#x26; typeof arg === &#x27;object&#x27;) {
      res.push({ $unwind: arg });
    } else if (typeof arg === &#x27;string&#x27;) {
      res.push({
        $unwind: (arg &#x26;&#x26; arg.charAt(0) === &#x27;$&#x27;) ? arg : &#x27;$&#x27; + arg
      });
    } else {
      throw new Error(&#x27;Invalid arg &#x22;&#x27; + arg + &#x27;&#x22; to unwind(), &#x27; +
        &#x27;must be string or object&#x27;);
    }
  }

  return this.append.apply(this, res);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Returned when calling Model.aggregate().
*
* ####Example:
*
*     Model
*     .aggregate({ $match: { age: { $gte: 21 }}})
*     .<span class="apidocCodeKeywordSpan">unwind</span>(&#x27;tags&#x27;)
*     .exec(callback)
*
* ####Note:
*
* - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).
* - Requires MongoDB &#x3e;= 2.1
* - Mongoose does **not** cast pipeline stages. `new Aggregate({ $match: { _id: &#x27;00000000000000000000000a&#x27; } });` will
 not work unless `_id` is a string in the database. Use `new Aggregate({ $match: { _id: mongoose.Types.ObjectId(&#x27;00000000000000000000000a
&#x27;) } });` instead.
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.browser" id="apidoc.module.mongoose.browser">module mongoose.browser</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.browser.Document" id="apidoc.element.mongoose.browser.Document">
        function <span class="apidocSignatureSpan">mongoose.browser.</span>Document
        <span class="apidocSignatureSpan">(obj, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Document(obj, fields, skipId) {
  this.$__ = new InternalCache;
  this.$__.emitter = new EventEmitter();
  this.isNew = true;
  this.errors = undefined;

  var schema = this.schema;

  if (typeof fields === &#x27;boolean&#x27;) {
    this.$__.strictMode = fields;
    fields = undefined;
  } else {
    this.$__.strictMode = schema.options &#x26;&#x26; schema.options.strict;
    this.$__.selected = fields;
  }

  var required = schema.requiredPaths(true);
  for (var i = 0; i &#x3c; required.length; ++i) {
    this.$__.activePaths.require(required[i]);
  }

  this.$__.emitter.setMaxListeners(0);
  this._doc = this.$__buildDoc(obj, fields, skipId);

  if (obj) {
    if (obj instanceof Document) {
      this.isNew = obj.isNew;
    }
    // Skip set hooks
    if (this.$__original_set) {
      this.$__original_set(obj, undefined, true);
    } else {
      this.set(obj, undefined, true);
    }
  }

  if (!schema.options.strict &#x26;&#x26; obj) {
    var _this = this,
        keys = Object.keys(this._doc);

    keys.forEach(function(key) {
      if (!(key in schema.tree)) {
        defineKey(key, null, _this);
      }
    });
  }

  applyQueue(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.browser.Error" id="apidoc.element.mongoose.browser.Error">
        function <span class="apidocSignatureSpan">mongoose.browser.</span>Error
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MongooseError(msg) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this);
  } else {
    this.stack = new Error().stack;
  }
  this.message = msg;
  this.name = &#x27;MongooseError&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.browser.Schema" id="apidoc.element.mongoose.browser.Schema">
        function <span class="apidocSignatureSpan">mongoose.browser.</span>Schema
        <span class="apidocSignatureSpan">(obj, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Schema(obj, options) {
  if (!(this instanceof Schema)) {
    return new Schema(obj, options);
  }

  this.obj = obj;
  this.paths = {};
  this.subpaths = {};
  this.virtuals = {};
  this.singleNestedPaths = {};
  this.nested = {};
  this.inherits = {};
  this.callQueue = [];
  this._indexes = [];
  this.methods = {};
  this.statics = {};
  this.tree = {};
  this.query = {};
  this.childSchemas = [];

  this.s = {
    hooks: new Kareem(),
    kareemHooks: IS_KAREEM_HOOK
  };

  this.options = this.defaultOptions(options);

  // build paths
  if (obj) {
    this.add(obj);
  }

  // check if _id&#x27;s value is a subdocument (gh-2276)
  var _idSubDoc = obj &#x26;&#x26; obj._id &#x26;&#x26; utils.isObject(obj._id);

  // ensure the documents get an auto _id unless disabled
  var auto_id = !this.paths[&#x27;_id&#x27;] &#x26;&#x26;
      (!this.options.noId &#x26;&#x26; this.options._id) &#x26;&#x26; !_idSubDoc;

  if (auto_id) {
    obj = {_id: {auto: true}};
    obj._id[this.options.typeKey] = Schema.ObjectId;
    this.add(obj);
  }

  // ensure the documents receive an id getter unless disabled
  var autoid = !this.paths[&#x27;id&#x27;] &#x26;&#x26;
      (!this.options.noVirtualId &#x26;&#x26; this.options.id);
  if (autoid) {
    this.virtual(&#x27;id&#x27;).get(idGetter);
  }

  for (var i = 0; i &#x3c; this._defaultMiddleware.length; ++i) {
    var m = this._defaultMiddleware[i];
    this[m.kind](m.hook, !!m.isAsync, m.fn);
  }

  if (this.options.timestamps) {
    this.setupTimestamp(this.options.timestamps);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * - [Date](#schema-date-js)
 * - [ObjectId](#schema-objectid-js) | Oid
 * - [Mixed](#schema-mixed-js)
 *
 * Using this exposed access to the `Mixed` SchemaType, we can use them in our schema.
 *
 *     var Mixed = mongoose.Schema.Types.Mixed;
 *     new mongoose.<span class="apidocCodeKeywordSpan">Schema</span>({ _user: Mixed })
 *
 * @api public
 */

Schema.Types = MongooseTypes = require(&#x27;./schema/index&#x27;);

/*!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.browser.SchemaType" id="apidoc.element.mongoose.browser.SchemaType">
        function <span class="apidocSignatureSpan">mongoose.browser.</span>SchemaType
        <span class="apidocSignatureSpan">(path, options, instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SchemaType(path, options, instance) {
  this.path = path;
  this.instance = instance;
  this.validators = [];
  this.setters = [];
  this.getters = [];
  this.options = options;
  this._index = null;
  this.selected;

  for (var i in options) {
    if (this[i] &#x26;&#x26; typeof this[i] === &#x27;function&#x27;) {
      // { unique: true, index: true }
      if (i === &#x27;index&#x27; &#x26;&#x26; this._index) {
        continue;
      }

      var opts = Array.isArray(options[i])
          ? options[i]
          : [options[i]];

      this[i].apply(this, opts);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.browser.VirtualType" id="apidoc.element.mongoose.browser.VirtualType">
        function <span class="apidocSignatureSpan">mongoose.browser.</span>VirtualType
        <span class="apidocSignatureSpan">(options, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VirtualType(options, name) {
  this.path = name;
  this.getters = [];
  this.setters = [];
  this.options = options || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.browserDocument" id="apidoc.module.mongoose.browserDocument">module mongoose.browserDocument</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.browserDocument.browserDocument" id="apidoc.element.mongoose.browserDocument.browserDocument">
        function <span class="apidocSignatureSpan">mongoose.</span>browserDocument
        <span class="apidocSignatureSpan">(obj, schema, fields, skipId, skipInit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Document(obj, schema, fields, skipId, skipInit) {
  if (!(this instanceof Document)) {
    return new Document(obj, schema, fields, skipId, skipInit);
  }


  if (utils.isObject(schema) &#x26;&#x26; !schema.instanceOfSchema) {
    schema = new Schema(schema);
  }

  // When creating EmbeddedDocument, it already has the schema and he doesn&#x27;t need the _id
  schema = this.schema || schema;

  // Generate ObjectId if it is missing, but it requires a scheme
  if (!this.schema &#x26;&#x26; schema.options._id) {
    obj = obj || {};

    if (obj._id === undefined) {
      obj._id = new ObjectId();
    }
  }

  if (!schema) {
    throw new MongooseError.MissingSchemaError();
  }

  this.$__setSchema(schema);

  this.$__ = new InternalCache;
  this.$__.emitter = new EventEmitter();
  this.isNew = true;
  this.errors = undefined;

  if (typeof fields === &#x27;boolean&#x27;) {
    this.$__.strictMode = fields;
    fields = undefined;
  } else {
    this.$__.strictMode = this.schema.options &#x26;&#x26; this.schema.options.strict;
    this.$__.selected = fields;
  }

  var required = this.schema.requiredPaths();
  for (var i = 0; i &#x3c; required.length; ++i) {
    this.$__.activePaths.require(required[i]);
  }

  this.$__.emitter.setMaxListeners(0);
  this._doc = this.$__buildDoc(obj, fields, skipId);

  if (!skipInit &#x26;&#x26; obj) {
    this.init(obj);
  }

  this.$__registerHooksFromSchema();

  // apply methods
  for (var m in schema.methods) {
    this[m] = schema.methods[m];
  }
  // apply statics
  for (var s in schema.statics) {
    this[s] = schema.statics[s];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.browserDocument.ValidationError" id="apidoc.element.mongoose.browserDocument.ValidationError">
        function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>ValidationError
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(instance) {
  this.errors = {};
  if (instance &#x26;&#x26; instance.constructor.name === &#x27;model&#x27;) {
    MongooseError.call(this, instance.constructor.modelName + &#x27; validation failed&#x27;);
  } else {
    MongooseError.call(this, &#x27;Validation failed&#x27;);
  }
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this);
  } else {
    this.stack = new Error().stack;
  }
  this.name = &#x27;ValidationError&#x27;;
  if (instance) {
    instance.errors = this.errors;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.browserDocument.addListener" id="apidoc.element.mongoose.browserDocument.addListener">
        function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () {
  return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.browserDocument.emit" id="apidoc.element.mongoose.browserDocument.emit">
        function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () {
  return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
You can intercept method arguments via middleware.

For example, this would allow you to broadcast changes about your Documents every time someone `set`s a path in your Document to
 a new value:

```js
schema.pre(&#x27;set&#x27;, function (next, path, val, typel) {
  // `this` is the current Document
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;set&#x27;, path, val);

  // Pass control to the next pre
  next();
});
```

Moreover, you can mutate the incoming `method` arguments so that subsequent middleware see different values for those arguments.
To do so, just pass the new values to `next`:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.browserDocument.listeners" id="apidoc.element.mongoose.browserDocument.listeners">
        function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () {
  return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      doc[pair[0]].apply(doc, pair[1]);
    }
  }
}

Document.prototype.$__handleReject = function handleReject(err) {
  // emit on the Model if listening
  if (this.<span class="apidocCodeKeywordSpan">listeners</span>(&#x27;error&#x27;).length) {
    this.emit(&#x27;error&#x27;, err);
  } else if (this.constructor.listeners &#x26;&#x26; this.constructor.listeners(&#x27;error&#x27;).length) {
    this.constructor.emit(&#x27;error&#x27;, err);
  } else if (this.listeners &#x26;&#x26; this.listeners(&#x27;error&#x27;).length) {
    this.emit(&#x27;error&#x27;, err);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.browserDocument.on" id="apidoc.element.mongoose.browserDocument.on">
        function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () {
  return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * - 2 = connecting
 * - 3 = disconnecting
 *
 * Each state change emits its associated event name.
 *
 * ####Example
 *
 *     conn.<span class="apidocCodeKeywordSpan">on</span>(&#x27;connected&#x27;, callback);
 *     conn.on(&#x27;disconnected&#x27;, callback);
 *
 * @property readyState
 * @api public
 */

Object.defineProperty(Connection.prototype, &#x27;readyState&#x27;, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.browserDocument.once" id="apidoc.element.mongoose.browserDocument.once">
        function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () {
  return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        aggregate(_this._pipeline, options || {});
      decorateCursor(cursor);
      resolve(cursor);
      callback &#x26;&#x26; callback(null, cursor);
    });
    return;
  }
  _this._model.collection.emitter.<span class="apidocCodeKeywordSpan">once</span>(&#x27;queue&#x27;, function() {
    var cursor = _this._model.collection.
      aggregate(_this._pipeline, options || {});
    decorateCursor(cursor);
    resolve(cursor);
    callback &#x26;&#x26; callback(null, cursor);
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.browserDocument.removeAllListeners" id="apidoc.element.mongoose.browserDocument.removeAllListeners">
        function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () {
  return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.browserDocument.removeListener" id="apidoc.element.mongoose.browserDocument.removeListener">
        function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () {
  return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.browserDocument.setMaxListeners" id="apidoc.element.mongoose.browserDocument.setMaxListeners">
        function <span class="apidocSignatureSpan">mongoose.browserDocument.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () {
  return Document.$emitter[emitterFn].apply(Document.$emitter, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var required = this.schema.requiredPaths();
for (var i = 0; i &#x3c; required.length; ++i) {
  this.$__.activePaths.require(required[i]);
}

this.$__.emitter.<span class="apidocCodeKeywordSpan">setMaxListeners</span>(0);
this._doc = this.$__buildDoc(obj, fields, skipId);

if (!skipInit &#x26;&#x26; obj) {
  this.init(obj);
}

this.$__registerHooksFromSchema();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.browserDocument.prototype" id="apidoc.module.mongoose.browserDocument.prototype">module mongoose.browserDocument.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.browserDocument.prototype.constructor" id="apidoc.element.mongoose.browserDocument.prototype.constructor">
        function <span class="apidocSignatureSpan">mongoose.browserDocument.prototype.</span>constructor
        <span class="apidocSignatureSpan">(obj, schema, fields, skipId, skipInit)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Document(obj, schema, fields, skipId, skipInit) {
  if (!(this instanceof Document)) {
    return new Document(obj, schema, fields, skipId, skipInit);
  }


  if (utils.isObject(schema) &#x26;&#x26; !schema.instanceOfSchema) {
    schema = new Schema(schema);
  }

  // When creating EmbeddedDocument, it already has the schema and he doesn&#x27;t need the _id
  schema = this.schema || schema;

  // Generate ObjectId if it is missing, but it requires a scheme
  if (!this.schema &#x26;&#x26; schema.options._id) {
    obj = obj || {};

    if (obj._id === undefined) {
      obj._id = new ObjectId();
    }
  }

  if (!schema) {
    throw new MongooseError.MissingSchemaError();
  }

  this.$__setSchema(schema);

  this.$__ = new InternalCache;
  this.$__.emitter = new EventEmitter();
  this.isNew = true;
  this.errors = undefined;

  if (typeof fields === &#x27;boolean&#x27;) {
    this.$__.strictMode = fields;
    fields = undefined;
  } else {
    this.$__.strictMode = this.schema.options &#x26;&#x26; this.schema.options.strict;
    this.$__.selected = fields;
  }

  var required = this.schema.requiredPaths();
  for (var i = 0; i &#x3c; required.length; ++i) {
    this.$__.activePaths.require(required[i]);
  }

  this.$__.emitter.setMaxListeners(0);
  this._doc = this.$__buildDoc(obj, fields, skipId);

  if (!skipInit &#x26;&#x26; obj) {
    this.init(obj);
  }

  this.$__registerHooksFromSchema();

  // apply methods
  for (var m in schema.methods) {
    this[m] = schema.methods[m];
  }
  // apply statics
  for (var s in schema.statics) {
    this[s] = schema.statics[s];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (obj.constructor) {
  switch (exports.getFunctionName(obj.constructor)) {
    case &#x27;Object&#x27;:
      return cloneObject(obj, options);
    case &#x27;Date&#x27;:
      return new obj.<span class="apidocCodeKeywordSpan">constructor</span>(+obj);
    case &#x27;RegExp&#x27;:
      return cloneRegExp(obj);
    default:
      // ignore
      break;
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.collection" id="apidoc.module.mongoose.collection">module mongoose.collection</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.collection.collection" id="apidoc.element.mongoose.collection.collection">
        function <span class="apidocSignatureSpan">mongoose.</span>collection
        <span class="apidocSignatureSpan">(name, conn, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Collection(name, conn, opts) {
  if (opts === void 0) {
    opts = {};
  }
  if (opts.capped === void 0) {
    opts.capped = {};
  }

  opts.bufferCommands = undefined === opts.bufferCommands
      ? true
      : opts.bufferCommands;

  if (typeof opts.capped === &#x27;number&#x27;) {
    opts.capped = {size: opts.capped};
  }

  this.opts = opts;
  this.name = name;
  this.collectionName = name;
  this.conn = conn;
  this.queue = [];
  this.buffer = this.opts.bufferCommands;
  this.emitter = new EventEmitter();

  if (STATES.connected === this.conn.readyState) {
    this.onOpen();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
model.prototype.$__setSchema(schema);

var collectionOptions = {
  bufferCommands: schema.options.bufferCommands,
  capped: schema.options.capped
};

model.prototype.collection = connection.<span class="apidocCodeKeywordSpan">collection</span>(
    collectionName
    , collectionOptions
);

// apply methods and statics
applyMethods(model, schema);
applyStatics(model, schema);
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.collection.prototype" id="apidoc.module.mongoose.collection.prototype">module mongoose.collection.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.collection.prototype.addQueue" id="apidoc.element.mongoose.collection.prototype.addQueue">
        function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>addQueue
        <span class="apidocSignatureSpan">(name, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addQueue = function (name, args) {
  this.queue.push([name, args]);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      create();
    }));
  };

  setImmediate(function() {
    // If buffering is off, do this manually.
    if (options._automatic &#x26;&#x26; !model.collection.collection) {
      model.collection.<span class="apidocCodeKeywordSpan">addQueue</span>(create, []);
    } else {
      create();
    }
  });
}

function _handleSafe(options) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.collection.prototype.doQueue" id="apidoc.element.mongoose.collection.prototype.doQueue">
        function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>doQueue
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doQueue = function () {
  for (var i = 0, l = this.queue.length; i &#x3c; l; i++) {
    if (typeof this.queue[i][0] === &#x27;function&#x27;) {
      this.queue[i][0].apply(this, this.queue[i][1]);
    } else {
      this[this.queue[i][0]].apply(this, this.queue[i][1]);
    }
  }
  this.queue = [];
  var _this = this;
  process.nextTick(function() {
    _this.emitter.emit(&#x27;queue&#x27;);
  });
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Called when the database connects
*
* @api private
*/

Collection.prototype.onOpen = function() {
 this.buffer = false;
 this.<span class="apidocCodeKeywordSpan">doQueue</span>();
};

/**
* Called when the database disconnects
*
* @api private
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.collection.prototype.ensureIndex" id="apidoc.element.mongoose.collection.prototype.ensureIndex">
        function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>ensureIndex
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureIndex = function () {
  throw new Error(&#x27;Collection#ensureIndex unimplemented by driver&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var indexFields = index[0];
  var options = index[1];
  _handleSafe(options);

  indexSingleStart(indexFields, options);

  model.collection.<span class="apidocCodeKeywordSpan">ensureIndex</span>(indexFields, options, utils.tick(function(err, name) {
    indexSingleDone(err, indexFields, options, name);
    if (err) {
      return done(err);
    }
    create();
  }));
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.collection.prototype.find" id="apidoc.element.mongoose.collection.prototype.find">
        function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>find
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function () {
  throw new Error(&#x27;Collection#find unimplemented by driver&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  //
});
```

Or we can find documents from the same collection

```js
MyModel.<span class="apidocCodeKeywordSpan">find</span>({}, function (err, docs) {
  // docs.forEach
});
```

You can also `findOne`, `findById`, `update`, etc. For more details check out [the docs](http://mongoosejs.com/docs/queries.html
).

**Important!** If you opened a separate connection using `mongoose.createConnection()` but attempt to access the model through `
mongoose.model(&#x27;ModelName&#x27;)` it will not work as expected since it is not hooked up to an active db connection. In this
 case access your model through the connection you created:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.collection.prototype.findAndModify" id="apidoc.element.mongoose.collection.prototype.findAndModify">
        function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>findAndModify
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findAndModify = function () {
  throw new Error(&#x27;Collection#findAndModify unimplemented by driver&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };

  if (opts.runValidators &#x26;&#x26; doValidate) {
var _callback = function(error) {
  if (error) {
    return callback(error);
  }
  _this._collection.<span class="apidocCodeKeywordSpan">findAndModify</span>(castedQuery, castedDoc, opts, utils.tick(function(error
, res) {
    return cb(error, res ? res.value : res, res);
  }));
};

try {
  doValidate(_callback);
} catch (error) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.collection.prototype.findOne" id="apidoc.element.mongoose.collection.prototype.findOne">
        function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>findOne
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findOne = function () {
  throw new Error(&#x27;Collection#findOne unimplemented by driver&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Checks if `path` was selected in the source query which initialized this document.
*
* ####Example
*
*     Thing.<span class="apidocCodeKeywordSpan">findOne</span>().select(&#x27;name&#x27;).exec(function (err, doc) {
*        doc.isSelected(&#x27;name&#x27;) // true
*        doc.isSelected(&#x27;age&#x27;)  // false
*     })
*
* @param {String} path
* @return {Boolean}
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.collection.prototype.getIndexes" id="apidoc.element.mongoose.collection.prototype.getIndexes">
        function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>getIndexes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getIndexes = function () {
  throw new Error(&#x27;Collection#getIndexes unimplemented by driver&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.collection.prototype.insert" id="apidoc.element.mongoose.collection.prototype.insert">
        function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>insert
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function () {
  throw new Error(&#x27;Collection#insert unimplemented by driver&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      setTimeout(function() {
callback(new Error(&#x27;document must have an _id before saving&#x27;));
      }, 0);
      return;
    }

    this.$__version(true, obj);
    this.collection.<span class="apidocCodeKeywordSpan">insert</span>(obj, options.safe, function(err, ret) {
      if (err) {
_this.isNew = true;
_this.emit(&#x27;isNew&#x27;, true);
_this.constructor.emit(&#x27;isNew&#x27;, true);

callback(err);
return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.collection.prototype.mapReduce" id="apidoc.element.mongoose.collection.prototype.mapReduce">
        function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>mapReduce
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mapReduce = function () {
  throw new Error(&#x27;Collection#mapReduce unimplemented by driver&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `o` is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver
 implementation. See [node-mongodb-native mapReduce() documentation](http://mongodb.github.io/node-mongodb-native/api-generated/
collection.html#mapreduce) for more detail about options.
*
* ####Example:
*
*     var o = {};
*     o.map = function () { emit(this.name, 1) }
*     o.reduce = function (k, vals) { return vals.length }
*     User.<span class="apidocCodeKeywordSpan">mapReduce</span>(o, function (err, results) {
*       console.log(results)
*     })
*
* ####Other options:
*
* - `query` {Object} query filter object.
* - `sort` {Object} sort input objects using this key
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.collection.prototype.onClose" id="apidoc.element.mongoose.collection.prototype.onClose">
        function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>onClose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onClose = function () {
  if (this.opts.bufferCommands) {
    this.buffer = true;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 1: // connected
case 4: // unauthorized
  this.readyState = STATES.disconnecting;
  this.doClose(function(err) {
    if (err) {
      _this.error(err, callback);
    } else {
      _this.<span class="apidocCodeKeywordSpan">onClose</span>();
      callback &#x26;&#x26; callback();
    }
  });
  break;

case 2: // connecting
  this.once(&#x27;open&#x27;, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.collection.prototype.onOpen" id="apidoc.element.mongoose.collection.prototype.onOpen">
        function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>onOpen
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onOpen = function () {
  this.buffer = false;
  this.doQueue();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 this.collectionName = name;
 this.conn = conn;
 this.queue = [];
 this.buffer = this.opts.bufferCommands;
 this.emitter = new EventEmitter();

 if (STATES.connected === this.conn.readyState) {
   this.<span class="apidocCodeKeywordSpan">onOpen</span>();
 }
}

/**
* The collection name
*
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.collection.prototype.save" id="apidoc.element.mongoose.collection.prototype.save">
        function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>save
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">save = function () {
  throw new Error(&#x27;Collection#save unimplemented by driver&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Then Mongoose will create the model for your __tickets__ collection, not your __ticket__ collection.

Once we have our model, we can then instantiate it, and save it:

```js
var instance = new MyModel();
instance.my.key = &#x27;hello&#x27;;
instance.<span class="apidocCodeKeywordSpan">save</span>(function (err) {
  //
});
```

Or we can find documents from the same collection

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.collection.prototype.update" id="apidoc.element.mongoose.collection.prototype.update">
        function <span class="apidocSignatureSpan">mongoose.collection.prototype.</span>update
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function () {
  throw new Error(&#x27;Collection#update unimplemented by driver&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

/**
* Sends an update command with this document `_id` as the query selector.
*
* ####Example:
*
*     weirdCar.<span class="apidocCodeKeywordSpan">update</span>({$inc: {wheels:1}}, { w: 1 }, callback);
*
* ####Valid options:
*
*  - same as in [Model.update](#model_Model.update)
*
* @see Model.update #model_Model.update
* @param {Object} doc
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.connection" id="apidoc.module.mongoose.connection">module mongoose.connection</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.connection.connection" id="apidoc.element.mongoose.connection.connection">
        function <span class="apidocSignatureSpan">mongoose.</span>connection
        <span class="apidocSignatureSpan">(base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Connection(base) {
  this.base = base;
  this.collections = {};
  this.models = {};
  this.config = {autoIndex: true};
  this.replica = false;
  this.hosts = null;
  this.host = null;
  this.port = null;
  this.user = null;
  this.pass = null;
  this.name = null;
  this.options = null;
  this.otherDbs = [];
  this._readyState = STATES.disconnected;
  this._closeCalled = false;
  this._hasOpened = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.connection.prototype" id="apidoc.module.mongoose.connection.prototype">module mongoose.connection.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.connection.prototype._close" id="apidoc.element.mongoose.connection.prototype._close">
        function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>_close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_close = function (callback) {
  var _this = this;
  this._closeCalled = true;

  switch (this.readyState) {
    case 0: // disconnected
      callback &#x26;&#x26; callback();
      break;

    case 1: // connected
    case 4: // unauthorized
      this.readyState = STATES.disconnecting;
      this.doClose(function(err) {
        if (err) {
          _this.error(err, callback);
        } else {
          _this.onClose();
          callback &#x26;&#x26; callback();
        }
      });
      break;

    case 2: // connecting
      this.once(&#x27;open&#x27;, function() {
        _this.close(callback);
      });
      break;

    case 3: // disconnecting
      if (!callback) {
        break;
      }
      this.once(&#x27;close&#x27;, function() {
        callback();
      });
      break;
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @api public
 */

Connection.prototype.close = function(callback) {
var _this = this;
var Promise = PromiseProvider.get();
return new Promise.ES6(function(resolve, reject) {
  _this.<span class="apidocCodeKeywordSpan">_close</span>(function(error) {
    callback &#x26;&#x26; callback(error);
    if (error) {
      reject(error);
      return;
    }
    resolve();
  });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.connection.prototype._open" id="apidoc.element.mongoose.connection.prototype._open">
        function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>_open
        <span class="apidocSignatureSpan">(emit, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_open = function (emit, callback) {
  this.readyState = STATES.connecting;
  this._closeCalled = false;

  var _this = this;

  var method = this.replica
      ? &#x27;doOpenSet&#x27;
      : &#x27;doOpen&#x27;;

  // open connection
  this[method](function(err) {
    if (err) {
      _this.readyState = STATES.disconnected;
      if (_this._hasOpened) {
        if (callback) {
          callback(err);
        }
      } else {
        _this.error(err, emit &#x26;&#x26; callback);
      }
      return;
    }

    _this.onOpen(callback);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

this.name = database;
this.host = host;
this.port = port;

var _this = this;
var promise = new Promise.ES6(function(resolve, reject) {
  _this.<span class="apidocCodeKeywordSpan">_open</span>(true, function(error) {
    callback &#x26;&#x26; callback(error);
    if (error) {
      // Error can be on same tick re: christkv/mongodb-core#157
      setImmediate(function() {
        reject(error);
        if (!callback &#x26;&#x26; !promise.$hasHandler) {
          _this.emit(&#x27;error&#x27;, error);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.connection.prototype.authMechanismDoesNotRequirePassword" id="apidoc.element.mongoose.connection.prototype.authMechanismDoesNotRequirePassword">
        function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>authMechanismDoesNotRequirePassword
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">authMechanismDoesNotRequirePassword = function () {
  if (this.options &#x26;&#x26; this.options.auth) {
    return authMechanismsWhichDontRequirePassword.indexOf(this.options.auth.authMechanism) &#x3e;= 0;
  }
  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* username and password are both provided than authentication is needed, but in some cases a
* password is not required.
* @api private
* @return {Boolean} true if the connection should be authenticated after it is opened, otherwise false.
*/
Connection.prototype.shouldAuthenticate = function() {
 return (this.user !== null &#x26;&#x26; this.user !== void 0) &#x26;&#x26;
     ((this.pass !== null || this.pass !== void 0) || this.<span class="apidocCodeKeywordSpan">authMechanismDoesNotRequirePassword
</span>());
};

/**
* @brief Returns a boolean value that specifies if the current authentication mechanism needs a
* password to authenticate according to the auth objects passed into the open/openSet methods.
* @api private
* @return {Boolean} true if the authentication mechanism specified in the options object requires
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.connection.prototype.close" id="apidoc.element.mongoose.connection.prototype.close">
        function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback) {
  var _this = this;
  var Promise = PromiseProvider.get();
  return new Promise.ES6(function(resolve, reject) {
    _this._close(function(error) {
      callback &#x26;&#x26; callback(error);
      if (error) {
        reject(error);
        return;
      }
      resolve();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* For practical reasons, a Connection equals a Db.
*
* @param {Mongoose} base a mongoose instance
* @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
* @event `connecting`: Emitted when `connection.{open,openSet}()` is executed on this connection.
* @event `connected`: Emitted when this connection successfully connects to the db. May be emitted _multiple_ times in `reconnected
` scenarios.
* @event `open`: Emitted after we `connected` and `onOpen` is executed on all of this connections models.
* @event `disconnecting`: Emitted when `connection.<span class="apidocCodeKeywordSpan">close</span>()` was executed.
* @event `disconnected`: Emitted after getting disconnected from the db.
* @event `close`: Emitted after we `disconnected` and `onClose` executed on all of this connections models.
* @event `reconnected`: Emitted after we `connected` and subsequently `disconnected`, followed by successfully another successfull
 connection.
* @event `error`: Emitted when an error occurs on this connection.
* @event `fullsetup`: Emitted in a replica-set scenario, when primary and at least one seconaries specified in the connection string
 are connected.
* @event `all`: Emitted in a replica-set scenario, when all nodes specified in the connection string are connected.
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.connection.prototype.collection" id="apidoc.element.mongoose.connection.prototype.collection">
        function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>collection
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collection = function (name, options) {
  if (!(name in this.collections)) {
    this.collections[name] = new Collection(name, this, options);
  }
  return this.collections[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
model.prototype.$__setSchema(schema);

var collectionOptions = {
  bufferCommands: schema.options.bufferCommands,
  capped: schema.options.capped
};

model.prototype.collection = connection.<span class="apidocCodeKeywordSpan">collection</span>(
    collectionName
    , collectionOptions
);

// apply methods and statics
applyMethods(model, schema);
applyStatics(model, schema);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.connection.prototype.dropDatabase" id="apidoc.element.mongoose.connection.prototype.dropDatabase">
        function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>dropDatabase
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dropDatabase = function (callback) {
  var Promise = PromiseProvider.get();
  var _this = this;
  var promise = new Promise.ES6(function(resolve, reject) {
    if (_this.readyState !== STATES.connected) {
      _this.on(&#x27;open&#x27;, function() {
        _this.db.dropDatabase(function(error) {
          if (error) {
            reject(error);
          } else {
            resolve();
          }
        });
      });
    } else {
      _this.db.dropDatabase(function(error) {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    }
  });
  if (callback) {
    promise.then(function() { callback(); }, callback);
  }
  return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Connection.prototype.dropDatabase = function(callback) {
var Promise = PromiseProvider.get();
var _this = this;
var promise = new Promise.ES6(function(resolve, reject) {
  if (_this.readyState !== STATES.connected) {
    _this.on(&#x27;open&#x27;, function() {
      _this.db.<span class="apidocCodeKeywordSpan">dropDatabase</span>(function(error) {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.connection.prototype.error" id="apidoc.element.mongoose.connection.prototype.error">
        function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>error
        <span class="apidocSignatureSpan">(err, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (err, callback) {
  if (callback) {
    return callback(err);
  }
  this.emit(&#x27;error&#x27;, err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!rgxProtocol.test(host)) {
  host = &#x27;mongodb://&#x27; + host;
}

try {
  parsed = muri(host);
} catch (err) {
  this.<span class="apidocCodeKeywordSpan">error</span>(err, callback);
  return new Promise.ES6(function(resolve, reject) {
    reject(err);
  });
}

database = parsed.db;
host = parsed.hosts[0].host || parsed.hosts[0].ipc;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.connection.prototype.model" id="apidoc.element.mongoose.connection.prototype.model">
        function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>model
        <span class="apidocSignatureSpan">(name, schema, collection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">model = function (name, schema, collection) {
  // collection name discovery
  if (typeof schema === &#x27;string&#x27;) {
    collection = schema;
    schema = false;
  }

  if (utils.isObject(schema) &#x26;&#x26; !schema.instanceOfSchema) {
    schema = new Schema(schema);
  }
  if (schema &#x26;&#x26; !schema.instanceOfSchema) {
    throw new Error(&#x27;The 2nd parameter to `mongoose.model()` should be a &#x27; +
      &#x27;schema or a POJO&#x27;);
  }

  if (this.models[name] &#x26;&#x26; !collection) {
    // model exists but we are not subclassing with custom collection
    if (schema &#x26;&#x26; schema.instanceOfSchema &#x26;&#x26; schema !== this.models[name].schema) {
      throw new MongooseError.OverwriteModelError(name);
    }
    return this.models[name];
  }

  var opts = {cache: false, connection: this};
  var model;

  if (schema &#x26;&#x26; schema.instanceOfSchema) {
    // compile a model
    model = this.base.model(name, schema, collection, opts);

    // only the first model with this name is cached to allow
    // for one-offs with custom collection names etc.
    if (!this.models[name]) {
      this.models[name] = model;
    }

    model.init();
    return model;
  }

  if (this.models[name] &#x26;&#x26; collection) {
    // subclassing current model with alternate collection
    model = this.models[name];
    schema = model.prototype.schema;
    var sub = model.__subclass(this, schema, collection);
    // do not cache the sub model
    return sub;
  }

  // lookup model in mongoose module
  model = this.base.models[name];

  if (!model) {
    throw new MongooseError.MissingSchemaError(name);
  }

  if (this === model.prototype.db
      &#x26;&#x26; (!collection || collection === model.collection.name)) {
    // model already uses this connection.

    // only the first model with this name is cached to allow
    // for one-offs with custom collection names etc.
    if (!this.models[name]) {
      this.models[name] = model;
    }

    return model;
  }
  this.models[name] = model.__subclass(this, schema, collection);
  return this.models[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

Take a look at the example in `examples/schema.js` for an end-to-end example of a typical setup.

### Accessing a Model

Once we define a model through `mongoose.<span class="apidocCodeKeywordSpan">model</span>(&#x27;ModelName&#x27;, mySchema)`, we
can access it through the same function

```js
var myModel = mongoose.model(&#x27;ModelName&#x27;);
```

Or just do it all at once
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.connection.prototype.modelNames" id="apidoc.element.mongoose.connection.prototype.modelNames">
        function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>modelNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">modelNames = function () {
  return Object.keys(this.models);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.connection.prototype.onClose" id="apidoc.element.mongoose.connection.prototype.onClose">
        function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>onClose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onClose = function () {
  this.readyState = STATES.disconnected;

  // avoid having the collection subscribe to our event emitter
  // to prevent 0.3 warning
  for (var i in this.collections) {
    if (utils.object.hasOwnProperty(this.collections, i)) {
      this.collections[i].onClose();
    }
  }

  this.emit(&#x27;close&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
case 1: // connected
case 4: // unauthorized
  this.readyState = STATES.disconnecting;
  this.doClose(function(err) {
    if (err) {
      _this.error(err, callback);
    } else {
      _this.<span class="apidocCodeKeywordSpan">onClose</span>();
      callback &#x26;&#x26; callback();
    }
  });
  break;

case 2: // connecting
  this.once(&#x27;open&#x27;, function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.connection.prototype.onOpen" id="apidoc.element.mongoose.connection.prototype.onOpen">
        function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>onOpen
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onOpen = function (callback) {
  var _this = this;

  function open(err, isAuth) {
    if (err) {
      _this.readyState = isAuth ? STATES.unauthorized : STATES.disconnected;
      _this.error(err, callback);
      return;
    }

    _this.readyState = STATES.connected;

    // avoid having the collection subscribe to our event emitter
    // to prevent 0.3 warning
    for (var i in _this.collections) {
      if (utils.object.hasOwnProperty(_this.collections, i)) {
        _this.collections[i].onOpen();
      }
    }

    callback &#x26;&#x26; callback();
    _this.emit(&#x27;open&#x27;);
  }

  // re-authenticate if we&#x27;re not already connected #3871
  if (this._readyState !== STATES.connected &#x26;&#x26; this.shouldAuthenticate()) {
    _this.db.authenticate(_this.user, _this.pass, _this.options.auth, function(err) {
      open(err, true);
    });
  } else {
    open();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 this.collectionName = name;
 this.conn = conn;
 this.queue = [];
 this.buffer = this.opts.bufferCommands;
 this.emitter = new EventEmitter();

 if (STATES.connected === this.conn.readyState) {
   this.<span class="apidocCodeKeywordSpan">onOpen</span>();
 }
}

/**
* The collection name
*
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.connection.prototype.open" id="apidoc.element.mongoose.connection.prototype.open">
        function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>open
        <span class="apidocSignatureSpan">(host, database, port, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">open = function (host, database, port, options, callback) {
  var parsed;
  var Promise = PromiseProvider.get();
  var err;

  if (typeof database === &#x27;string&#x27;) {
    switch (arguments.length) {
      case 2:
        port = 27017;
        break;
      case 3:
        switch (typeof port) {
          case &#x27;function&#x27;:
            callback = port;
            port = 27017;
            break;
          case &#x27;object&#x27;:
            options = port;
            port = 27017;
            break;
        }
        break;
      case 4:
        if (typeof options === &#x27;function&#x27;) {
          callback = options;
          options = {};
        }
    }
  } else {
    switch (typeof database) {
      case &#x27;function&#x27;:
        callback = database;
        database = undefined;
        break;
      case &#x27;object&#x27;:
        options = database;
        database = undefined;
        callback = port;
        break;
    }

    if (!rgxProtocol.test(host)) {
      host = &#x27;mongodb://&#x27; + host;
    }

    try {
      parsed = muri(host);
    } catch (err) {
      this.error(err, callback);
      return new Promise.ES6(function(resolve, reject) {
        reject(err);
      });
    }

    database = parsed.db;
    host = parsed.hosts[0].host || parsed.hosts[0].ipc;
    port = parsed.hosts[0].port || 27017;
  }

  this.options = this.parseOptions(options, parsed &#x26;&#x26; parsed.options);

  // make sure we can open
  if (STATES.disconnected !== this.readyState) {
    err = new Error(&#x27;Trying to open unclosed connection.&#x27;);
    err.state = this.readyState;
    this.error(err, callback);
    return new Promise.ES6(function(resolve, reject) {
      reject(err);
    });
  }

  if (!host) {
    err = new Error(&#x27;Missing hostname.&#x27;);
    this.error(err, callback);
    return new Promise.ES6(function(resolve, reject) {
      reject(err);
    });
  }

  if (!database) {
    err = new Error(&#x27;Missing database name.&#x27;);
    this.error(err, callback);
    return new Promise.ES6(function(resolve, reject) {
      reject(err);
    });
  }

  // authentication
  if (this.optionsProvideAuthenticationData(options)) {
    this.user = options.user;
    this.pass = options.pass;
  } else if (parsed &#x26;&#x26; parsed.auth) {
    this.user = parsed.auth.user;
    this.pass = parsed.auth.pass;

    // Check hostname for user/pass
  } else if (/@/.test(host) &#x26;&#x26; /:/.test(host.split(&#x27;@&#x27;)[0])) {
    host = host.split(&#x27;@&#x27;);
    if (host.length &#x3e; 2) {
      err = new Error(&#x27;Username and password must be URI encoded if they &#x27; +
        &#x27;contain &#x22;@&#x22;, see http://bit.ly/2nRYRyq&#x27;);
      this.error(err, callback);
      return new Promise.ES6(function(resolve, reject) {
        reject(err);
      });
    }
    var auth = host.shift().split(&#x27;:&#x27;);
    if (auth.length &#x3e; 2) {
      err = new Error(&#x27;Username and password must be URI encoded if they &#x27; +
        &#x27;contain &#x22;:&#x22;, see http://bit.ly/2nRYRyq&#x27;);
      this.error(err, callback);
      return new Promise.ES6(function(resolve, reject) {
        reject(err);
      });
    }
    host = host.pop();
    this.user = auth[0];
    this.pass = auth[1];
  } else {
    this.user = this.pass = undefined;
  }

  // global configuration options
  if (options &#x26;&#x26; options.config) {
    this.config.autoIndex = options.config.autoIndex !== false;
  }

  this.name = database;
  this.host = host;
  this.port = port;

  var _this = this;
  var promise = new Promise.ES6(function(resolve, reject) {
    _this._open(true, function(error) {
      callback &#x26;&#x26; callback(error);
      if (error) {
        // Error can be on same tick re: christkv/mongodb-core#157
        setImmediate(function() {
          reject(error);
          if (!callback &#x26;&#x26; !promise.$hasHandler) {
            _this.emit(&#x27;error&#x27;, error);
          }
        });
        return;
      }
      resolve();
    });
  });
  return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* _Options passed take precedence over options included in connection strings._
*
* ####Notes:
*
* _If connecting to multiple mongos servers, set the `mongos` option to true._
*
*     conn.<span class="apidocCodeKeywordSpan">open</span>(&#x27;mongodb://mongosA:27501,mongosB:27501&#x27;, { mongos: true },
cb);
*
* Mongoose forces the db option `forceServerObjectId` false and cannot be overridden.
* Mongoose defaults the server `auto_reconnect` options to true which can be overridden.
* See the node-mongodb-native driver instance for options that it understands.
*
* _Options passed take precedence over options included in connection strings._
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.connection.prototype.openSet" id="apidoc.element.mongoose.connection.prototype.openSet">
        function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>openSet
        <span class="apidocSignatureSpan">(uris, database, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">openSet = function (uris, database, options, callback) {
  if (!rgxProtocol.test(uris)) {
    uris = &#x27;mongodb://&#x27; + uris;
  }

  var Promise = PromiseProvider.get();

  switch (arguments.length) {
    case 3:
      switch (typeof database) {
        case &#x27;string&#x27;:
          this.name = database;
          break;
        case &#x27;object&#x27;:
          callback = options;
          options = database;
          database = null;
          break;
      }

      if (typeof options === &#x27;function&#x27;) {
        callback = options;
        options = {};
      }
      break;
    case 2:
      switch (typeof database) {
        case &#x27;string&#x27;:
          this.name = database;
          break;
        case &#x27;function&#x27;:
          callback = database;
          database = null;
          break;
        case &#x27;object&#x27;:
          options = database;
          database = null;
          break;
      }
  }

  if (typeof database === &#x27;string&#x27;) {
    this.name = database;
  }

  var parsed;
  try {
    parsed = muri(uris);
  } catch (err) {
    this.error(err, callback);
    return new Promise.ES6(function(resolve, reject) {
      reject(err);
    });
  }

  if (!this.name) {
    this.name = parsed.db;
  }

  this.hosts = parsed.hosts;
  this.options = this.parseOptions(options, parsed &#x26;&#x26; parsed.options);
  this.replica = true;

  if (!this.name) {
    var err = new Error(&#x27;No database name provided for replica set&#x27;);
    this.error(err, callback);
    return new Promise.ES6(function(resolve, reject) {
      reject(err);
    });
  }

  // authentication
  if (this.optionsProvideAuthenticationData(options)) {
    this.user = options.user;
    this.pass = options.pass;
  } else if (parsed &#x26;&#x26; parsed.auth) {
    this.user = parsed.auth.user;
    this.pass = parsed.auth.pass;
  } else {
    this.user = this.pass = undefined;
  }

  // global configuration options
  if (options &#x26;&#x26; options.config) {
    this.config.autoIndex = options.config.autoIndex !== false;
  }

  var _this = this;
  var emitted = false;
  var promise = new Promise.ES6(function(resolve, reject) {
    _this._open(true, function(error) {
      callback &#x26;&#x26; callback(error);
      if (error) {
        reject(error);
        if (!callback &#x26;&#x26; !promise.$hasHandler &#x26;&#x26; !emitted) {
          emitted = true;
          _this.emit(&#x27;error&#x27;, error);
        }
        return;
      }
      resolve();
    });
  });
  return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Opens the connection to a replica set.
*
* ####Example:
*
*     var db = mongoose.createConnection();
*     db.<span class="apidocCodeKeywordSpan">openSet</span>(&#x22;mongodb://user:pwd@localhost:27020,localhost:27021,localhost:27012
/mydb&#x22;);
*
* The database name and/or auth need only be included in one URI.
* The `options` is a hash which is passed to the internal driver connection object.
*
* Valid `options`
*
*     db      - passed to the connection db instance
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.connection.prototype.optionsProvideAuthenticationData" id="apidoc.element.mongoose.connection.prototype.optionsProvideAuthenticationData">
        function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>optionsProvideAuthenticationData
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">optionsProvideAuthenticationData = function (options) {
  return (options) &#x26;&#x26;
      (options.user) &#x26;&#x26;
      ((options.pass) || this.authMechanismDoesNotRequirePassword());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.error(err, callback);
return new Promise.ES6(function(resolve, reject) {
  reject(err);
});
  }

  // authentication
  if (this.<span class="apidocCodeKeywordSpan">optionsProvideAuthenticationData</span>(options)) {
this.user = options.user;
this.pass = options.pass;
  } else if (parsed &#x26;&#x26; parsed.auth) {
this.user = parsed.auth.user;
this.pass = parsed.auth.pass;

// Check hostname for user/pass
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.connection.prototype.shouldAuthenticate" id="apidoc.element.mongoose.connection.prototype.shouldAuthenticate">
        function <span class="apidocSignatureSpan">mongoose.connection.prototype.</span>shouldAuthenticate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">shouldAuthenticate = function () {
  return (this.user !== null &#x26;&#x26; this.user !== void 0) &#x26;&#x26;
      ((this.pass !== null || this.pass !== void 0) || this.authMechanismDoesNotRequirePassword());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    }

    callback &#x26;&#x26; callback();
    _this.emit(&#x27;open&#x27;);
  }

  // re-authenticate if we&#x27;re not already connected #3871
  if (this._readyState !== STATES.connected &#x26;&#x26; this.<span class="apidocCodeKeywordSpan">shouldAuthenticate</span>()) {
    _this.db.authenticate(_this.user, _this.pass, _this.options.auth, function(err) {
      open(err, true);
    });
  } else {
    open();
  }
};
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.document" id="apidoc.module.mongoose.document">module mongoose.document</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.document.document" id="apidoc.element.mongoose.document.document">
        function <span class="apidocSignatureSpan">mongoose.</span>document
        <span class="apidocSignatureSpan">(obj, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Document(obj, fields, skipId) {
  this.$__ = new InternalCache;
  this.$__.emitter = new EventEmitter();
  this.isNew = true;
  this.errors = undefined;

  var schema = this.schema;

  if (typeof fields === &#x27;boolean&#x27;) {
    this.$__.strictMode = fields;
    fields = undefined;
  } else {
    this.$__.strictMode = schema.options &#x26;&#x26; schema.options.strict;
    this.$__.selected = fields;
  }

  var required = schema.requiredPaths(true);
  for (var i = 0; i &#x3c; required.length; ++i) {
    this.$__.activePaths.require(required[i]);
  }

  this.$__.emitter.setMaxListeners(0);
  this._doc = this.$__buildDoc(obj, fields, skipId);

  if (obj) {
    if (obj instanceof Document) {
      this.isNew = obj.isNew;
    }
    // Skip set hooks
    if (this.$__original_set) {
      this.$__original_set(obj, undefined, true);
    } else {
      this.set(obj, undefined, true);
    }
  }

  if (!schema.options.strict &#x26;&#x26; obj) {
    var _this = this,
        keys = Object.keys(this._doc);

    keys.forEach(function(key) {
      if (!(key in schema.tree)) {
        defineKey(key, null, _this);
      }
    });
  }

  applyQueue(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.ValidationError" id="apidoc.element.mongoose.document.ValidationError">
        function <span class="apidocSignatureSpan">mongoose.document.</span>ValidationError
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(instance) {
  this.errors = {};
  if (instance &#x26;&#x26; instance.constructor.name === &#x27;model&#x27;) {
    MongooseError.call(this, instance.constructor.modelName + &#x27; validation failed&#x27;);
  } else {
    MongooseError.call(this, &#x27;Validation failed&#x27;);
  }
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this);
  } else {
    this.stack = new Error().stack;
  }
  this.name = &#x27;ValidationError&#x27;;
  if (instance) {
    instance.errors = this.errors;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document._lazySetupHooks" id="apidoc.element.mongoose.document._lazySetupHooks">
        function <span class="apidocSignatureSpan">mongoose.document.</span>_lazySetupHooks
        <span class="apidocSignatureSpan">(proto, methodName, errorCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_lazySetupHooks = function (proto, methodName, errorCb) {
  if (&#x27;undefined&#x27; === typeof proto[methodName].numAsyncPres) {
    this.$hook(methodName, proto[methodName], errorCb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.removePost" id="apidoc.element.mongoose.document.removePost">
        function <span class="apidocSignatureSpan">mongoose.document.</span>removePost
        <span class="apidocSignatureSpan">(name, fnToRemove)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removePost = function (name, fnToRemove) {
  var proto = this.prototype || this
    , posts = proto._posts || (proto._posts || {});
  if (!posts[name]) return this;
  if (arguments.length === 1) {
    // Remove all post callbacks for hook `name`
    posts[name].length = 0;
  } else {
    posts[name] = posts[name].filter( function (currFn) {
      return currFn !== fnToRemove;
    });
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.removePre" id="apidoc.element.mongoose.document.removePre">
        function <span class="apidocSignatureSpan">mongoose.document.</span>removePre
        <span class="apidocSignatureSpan">(name, fnToRemove)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removePre = function (name, fnToRemove) {
  var proto = this.prototype || this
    , pres = proto._pres || (proto._pres || {});
  if (!pres[name]) return this;
  if (arguments.length === 1) {
    // Remove all pre callbacks for hook `name`
    pres[name].length = 0;
  } else {
    pres[name] = pres[name].filter( function (currFn) {
      return currFn !== fnToRemove;
    });
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.document.prototype" id="apidoc.module.mongoose.document.prototype">module mongoose.document.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.document.prototype._lazySetupHooks" id="apidoc.element.mongoose.document.prototype._lazySetupHooks">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>_lazySetupHooks
        <span class="apidocSignatureSpan">(proto, methodName, errorCb)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_lazySetupHooks = function (proto, methodName, errorCb) {
  if (&#x27;undefined&#x27; === typeof proto[methodName].numAsyncPres) {
    this.$hook(methodName, proto[methodName], errorCb);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.addListener" id="apidoc.element.mongoose.document.prototype.addListener">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>addListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addListener = function () {
  return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.depopulate" id="apidoc.element.mongoose.document.prototype.depopulate">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>depopulate
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">depopulate = function (path) {
  var populatedIds = this.populated(path);
  if (!populatedIds) {
    return;
  }
  delete this.$__.populated[path];
  this.set(path, populatedIds);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Takes a populated field and returns it to its unpopulated state.
*
* ####Example:
*
*     Model.findOne().populate(&#x27;author&#x27;).exec(function (err, doc) {
*       console.log(doc.author.name); // Dr.Seuss
*       console.log(doc.<span class="apidocCodeKeywordSpan">depopulate</span>(&#x27;author&#x27;));
*       console.log(doc.author); // &#x27;5144cf8050f071d979c118a7&#x27;
*     })
*
* If the path was not populated, this is a no-op.
*
* @param {String} path
* @return {Document} this
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.emit" id="apidoc.element.mongoose.document.prototype.emit">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>emit
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emit = function () {
  return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
You can intercept method arguments via middleware.

For example, this would allow you to broadcast changes about your Documents every time someone `set`s a path in your Document to
 a new value:

```js
schema.pre(&#x27;set&#x27;, function (next, path, val, typel) {
  // `this` is the current Document
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;set&#x27;, path, val);

  // Pass control to the next pre
  next();
});
```

Moreover, you can mutate the incoming `method` arguments so that subsequent middleware see different values for those arguments.
To do so, just pass the new values to `next`:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.equals" id="apidoc.element.mongoose.document.prototype.equals">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>equals
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">equals = function (doc) {
  if (!doc) {
    return false;
  }

  var tid = this.get(&#x27;_id&#x27;);
  var docid = doc.get ? doc.get(&#x27;_id&#x27;) : doc;
  if (!tid &#x26;&#x26; !docid) {
    return deepEqual(this, doc);
  }
  return tid &#x26;&#x26; tid.equals
      ? tid.equals(docid)
      : tid === docid;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

 var tid = this.get(&#x27;_id&#x27;);
 var docid = doc.get ? doc.get(&#x27;_id&#x27;) : doc;
 if (!tid &#x26;&#x26; !docid) {
   return deepEqual(this, doc);
 }
 return tid &#x26;&#x26; tid.equals
     ? tid.<span class="apidocCodeKeywordSpan">equals</span>(docid)
     : tid === docid;
};

/**
* Populates document references, executing the `callback` when complete.
* If you want to use promises instead, use this function with
* [`execPopulate()`](#document_Document-execPopulate)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.execPopulate" id="apidoc.element.mongoose.document.prototype.execPopulate">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>execPopulate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">execPopulate = function () {
  var Promise = PromiseProvider.get();
  var _this = this;
  return new Promise.ES6(function(resolve, reject) {
    _this.populate(function(error, res) {
      if (error) {
        reject(error);
      } else {
        resolve(res);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*     // summary
*     doc.populate(path)                   // not executed
*     doc.populate(options);               // not executed
*     doc.populate(path, callback)         // executed
*     doc.populate(options, callback);     // executed
*     doc.populate(callback);              // executed
*     doc.populate(options).<span class="apidocCodeKeywordSpan">execPopulate</span>() // executed, returns promise
*
*
* ####NOTE:
*
* Population does not occur unless a `callback` is passed *or* you explicitly
* call `execPopulate()`.
* Passing the same path a second time will overwrite the previous path options.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.get" id="apidoc.element.mongoose.document.prototype.get">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>get
        <span class="apidocSignatureSpan">(path, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (path, type) {
  var adhoc;
  if (type) {
    adhoc = Schema.interpretAsType(path, type, this.schema.options);
  }

  var schema = this.$__path(path) || this.schema.virtualpath(path),
      pieces = path.split(&#x27;.&#x27;),
      obj = this._doc;

  for (var i = 0, l = pieces.length; i &#x3c; l; i++) {
    obj = obj === null || obj === void 0
        ? undefined
        : obj[pieces[i]];
  }

  if (adhoc) {
    obj = adhoc.cast(obj);
  }

  // Check if this path is populated - don&#x27;t apply getters if it is,
  // because otherwise its a nested object. See gh-3357
  if (schema &#x26;&#x26; !this.populated(path)) {
    obj = schema.applyGetters(obj, this);
  }

  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// a setter
Comment.path(&#x27;name&#x27;).set(function (v) {
  return capitalize(v);
});

// middleware
Comment.pre(&#x27;save&#x27;, function (next) {
  notify(this.<span class="apidocCodeKeywordSpan">get</span>(&#x27;email&#x27;));
  next();
});
```

Take a look at the example in `examples/schema.js` for an end-to-end example of a typical setup.

### Accessing a Model
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.getValue" id="apidoc.element.mongoose.document.prototype.getValue">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>getValue
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValue = function (path) {
  return utils.getValue(path, this._doc);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If doc._id is not null or undefined
if (doc._id !== null &#x26;&#x26; doc._id !== undefined &#x26;&#x26;
  opts &#x26;&#x26; opts.populated &#x26;&#x26; opts.populated.length) {
  var id = String(doc._id);
  for (var i = 0; i &#x3c; opts.populated.length; ++i) {
    var item = opts.populated[i];
    if (item.isVirtual) {
      this.populated(item.path, utils.<span class="apidocCodeKeywordSpan">getValue</span>(item.path, doc), item);
    } else {
      this.populated(item.path, item._docs[id], item);
    }
  }
}

init(this, doc, this._doc);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.init" id="apidoc.element.mongoose.document.prototype.init">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>init
        <span class="apidocSignatureSpan">(doc, opts, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function (doc, opts, fn) {
  // do not prefix this method with $__ since its
  // used by public hooks

  if (typeof opts === &#x27;function&#x27;) {
    fn = opts;
    opts = null;
  }

  this.isNew = false;

  // handle docs with populated paths
  // If doc._id is not null or undefined
  if (doc._id !== null &#x26;&#x26; doc._id !== undefined &#x26;&#x26;
    opts &#x26;&#x26; opts.populated &#x26;&#x26; opts.populated.length) {
    var id = String(doc._id);
    for (var i = 0; i &#x3c; opts.populated.length; ++i) {
      var item = opts.populated[i];
      if (item.isVirtual) {
        this.populated(item.path, utils.getValue(item.path, doc), item);
      } else {
        this.populated(item.path, item._docs[id], item);
      }
    }
  }

  init(this, doc, this._doc);
  this.$__storeShard();

  this.emit(&#x27;init&#x27;, this);
  this.constructor.emit(&#x27;init&#x27;, this);

  if (fn) {
    fn(null);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.$__.activePaths.require(required[i]);
}

this.$__.emitter.setMaxListeners(0);
this._doc = this.$__buildDoc(obj, fields, skipId);

if (!skipInit &#x26;&#x26; obj) {
  this.<span class="apidocCodeKeywordSpan">init</span>(obj);
}

this.$__registerHooksFromSchema();

// apply methods
for (var m in schema.methods) {
  this[m] = schema.methods[m];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.inspect" id="apidoc.element.mongoose.document.prototype.inspect">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>inspect
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">inspect = function (options) {
  var isPOJO = options &#x26;&#x26;
    utils.getFunctionName(options.constructor) === &#x27;Object&#x27;;
  var opts;
  if (isPOJO) {
    opts = options;
    opts.minimize = false;
    opts.retainKeyOrder = true;
  }
  return this.toObject(opts);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Helper for console.log
*
* @api public
* @method toString
*/

Document.prototype.toString = function() {
 return inspect(this.<span class="apidocCodeKeywordSpan">inspect</span>());
};

/**
* Returns true if the Document stores the same data as doc.
*
* Documents are considered equal when they have matching `_id`s, unless neither
* document has an `_id`, in which case this function falls back to using
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.invalidate" id="apidoc.element.mongoose.document.prototype.invalidate">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>invalidate
        <span class="apidocSignatureSpan">(path, err, val, kind)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">invalidate = function (path, err, val, kind) {
  if (!this.$__.validationError) {
    this.$__.validationError = new ValidationError(this);
  }

  if (this.$__.validationError.errors[path]) {
    return;
  }

  if (!err || typeof err === &#x27;string&#x27;) {
    err = new ValidatorError({
      path: path,
      message: err,
      type: kind || &#x27;user defined&#x27;,
      value: val
    });
  }

  if (this.$__.validationError === err) {
    return this.$__.validationError;
  }

  this.$__.validationError.errors[path] = err;
  return this.$__.validationError;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (obj[i] === null) {
  doc[i] = null;
} else if (obj[i] !== undefined) {
  if (schema) {
    try {
      doc[i] = schema.cast(obj[i], self, true);
    } catch (e) {
      self.<span class="apidocCodeKeywordSpan">invalidate</span>(e.path, new ValidatorError({
        path: e.path,
        message: e.message,
        type: &#x27;cast&#x27;,
        value: e.value
      }));
    }
  } else {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.isDirectModified" id="apidoc.element.mongoose.document.prototype.isDirectModified">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>isDirectModified
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isDirectModified = function (path) {
  return (path in this.$__.activePaths.states.modify);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// Else mongodb throws: &#x22;LEFT_SUBFIELD only supports Object&#x22;

if (parts.length &#x3c;= 1) {
  pathToMark = path;
} else {
  for (i = 0; i &#x3c; parts.length; ++i) {
    subpath = parts.slice(0, i + 1).join(&#x27;.&#x27;);
    if (this.<span class="apidocCodeKeywordSpan">isDirectModified</span>(subpath) // earlier prefixes that are already
          // marked as dirty have precedence
        || this.get(subpath) === null) {
      pathToMark = subpath;
      break;
    }
  }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.isDirectSelected" id="apidoc.element.mongoose.document.prototype.isDirectSelected">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>isDirectSelected
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isDirectSelected(path) {
  if (this.$__.selected) {
    if (path === &#x27;_id&#x27;) {
      return this.$__.selected._id !== 0;
    }

    var paths = Object.keys(this.$__.selected);
    var i = paths.length;
    var inclusive = null;
    var cur;

    if (i === 1 &#x26;&#x26; paths[0] === &#x27;_id&#x27;) {
      // only _id was selected.
      return this.$__.selected._id === 0;
    }

    while (i--) {
      cur = paths[i];
      if (cur === &#x27;_id&#x27;) {
        continue;
      }
      if (this.$__.selected[cur] &#x26;&#x26; this.$__.selected[cur].$meta) {
        continue;
      }
      inclusive = !!this.$__.selected[cur];
      break;
    }

    if (inclusive === null) {
      return true;
    }

    if (path in this.$__.selected) {
      return inclusive;
    }

    return !inclusive;
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Checks if `path` was explicitly selected. If no projection, always returns
* true.
*
* ####Example
*
*     Thing.findOne().select(&#x27;nested.name&#x27;).exec(function (err, doc) {
*        doc.<span class="apidocCodeKeywordSpan">isDirectSelected</span>(&#x27;nested.name&#x27;) // true
*        doc.isDirectSelected(&#x27;nested.otherName&#x27;) // false
*        doc.isDirectSelected(&#x27;nested&#x27;)  // false
*     })
*
* @param {String} path
* @return {Boolean}
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.isInit" id="apidoc.element.mongoose.document.prototype.isInit">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>isInit
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInit = function (path) {
  return (path in this.$__.activePaths.states.init);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.isModified" id="apidoc.element.mongoose.document.prototype.isModified">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>isModified
        <span class="apidocSignatureSpan">(paths)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isModified = function (paths) {
  if (paths) {
    if (!Array.isArray(paths)) {
      paths = paths.split(&#x27; &#x27;);
    }
    var modified = this.modifiedPaths();
    var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
    var isModifiedChild = paths.some(function(path) {
      return !!~modified.indexOf(path);
    });
    return isModifiedChild || paths.some(function(path) {
      return directModifiedPaths.some(function(mod) {
        return mod === path || path.indexOf(mod + &#x27;.&#x27;) === 0;
      });
    });
  }
  return this.$__.activePaths.some(&#x27;modify&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            }));
          }
        } else {
          doc[i] = obj[i];
        }
      }
      // mark as hydrated
      if (!self.<span class="apidocCodeKeywordSpan">isModified</span>(path)) {
        self.$__.activePaths.init(path);
      }
    }
  }
}

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.isSelected" id="apidoc.element.mongoose.document.prototype.isSelected">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>isSelected
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isSelected(path) {
  if (this.$__.selected) {
    if (path === &#x27;_id&#x27;) {
      return this.$__.selected._id !== 0;
    }

    var paths = Object.keys(this.$__.selected);
    var i = paths.length;
    var inclusive = null;
    var cur;

    if (i === 1 &#x26;&#x26; paths[0] === &#x27;_id&#x27;) {
      // only _id was selected.
      return this.$__.selected._id === 0;
    }

    while (i--) {
      cur = paths[i];
      if (cur === &#x27;_id&#x27;) {
        continue;
      }
      if (this.$__.selected[cur] &#x26;&#x26; this.$__.selected[cur].$meta) {
        continue;
      }
      inclusive = !!this.$__.selected[cur];
      break;
    }

    if (inclusive === null) {
      return true;
    }

    if (path in this.$__.selected) {
      return inclusive;
    }

    i = paths.length;
    var pathDot = path + &#x27;.&#x27;;

    while (i--) {
      cur = paths[i];
      if (cur === &#x27;_id&#x27;) {
        continue;
      }

      if (cur.indexOf(pathDot) === 0) {
        return inclusive || cur !== pathDot;
      }

      if (pathDot.indexOf(cur + &#x27;.&#x27;) === 0) {
        return inclusive;
      }
    }

    return !inclusive;
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
i = keys[index];
path = prefix + i;
schema = self.schema.path(path);

// Should still work if not a model-level discriminator, but should not be
// necessary. This is *only* to catch the case where we queried using the
// base model and the discriminated model has a projection
if (self.schema.$isRootDiscriminator &#x26;&#x26; !self.<span class="apidocCodeKeywordSpan">isSelected</span>(path)) {
  return;
}

if (!schema &#x26;&#x26; utils.isObject(obj[i]) &#x26;&#x26;
    (!obj[i].constructor || utils.getFunctionName(obj[i].constructor) === &#x27;Object&#x27;)) {
  // assume nested object
  if (!doc[i]) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.listeners" id="apidoc.element.mongoose.document.prototype.listeners">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>listeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">listeners = function () {
  return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      doc[pair[0]].apply(doc, pair[1]);
    }
  }
}

Document.prototype.$__handleReject = function handleReject(err) {
  // emit on the Model if listening
  if (this.<span class="apidocCodeKeywordSpan">listeners</span>(&#x27;error&#x27;).length) {
    this.emit(&#x27;error&#x27;, err);
  } else if (this.constructor.listeners &#x26;&#x26; this.constructor.listeners(&#x27;error&#x27;).length) {
    this.constructor.emit(&#x27;error&#x27;, err);
  } else if (this.listeners &#x26;&#x26; this.listeners(&#x27;error&#x27;).length) {
    this.emit(&#x27;error&#x27;, err);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.markModified" id="apidoc.element.mongoose.document.prototype.markModified">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>markModified
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">markModified = function (path) {
  this.$__.activePaths.modify(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!merge) {
    this.setValue(path, null);
    cleanModifiedSubpaths(this, path);
  }

  if (Object.keys(val).length === 0) {
    this.setValue(path, {});
    this.<span class="apidocCodeKeywordSpan">markModified</span>(path);
    cleanModifiedSubpaths(this, path);
  } else {
    this.set(val, path, constructing);
  }
  return this;
}
this.invalidate(path, new MongooseError.CastError(&#x27;Object&#x27;, val, path));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.modifiedPaths" id="apidoc.element.mongoose.document.prototype.modifiedPaths">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>modifiedPaths
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">modifiedPaths = function () {
  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
  return directModifiedPaths.reduce(function(list, path) {
    var parts = path.split(&#x27;.&#x27;);
    return list.concat(parts.reduce(function(chains, part, i) {
      return chains.concat(parts.slice(0, i).concat(part).join(&#x27;.&#x27;));
    }, []).filter(function(chain) {
      return (list.indexOf(chain) === -1);
    }));
  }, []);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */

Document.prototype.isModified = function(paths) {
if (paths) {
  if (!Array.isArray(paths)) {
    paths = paths.split(&#x27; &#x27;);
  }
  var modified = this.<span class="apidocCodeKeywordSpan">modifiedPaths</span>();
  var directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
  var isModifiedChild = paths.some(function(path) {
    return !!~modified.indexOf(path);
  });
  return isModifiedChild || paths.some(function(path) {
    return directModifiedPaths.some(function(mod) {
      return mod === path || path.indexOf(mod + &#x27;.&#x27;) === 0;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.on" id="apidoc.element.mongoose.document.prototype.on">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>on
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">on = function () {
  return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * - 2 = connecting
 * - 3 = disconnecting
 *
 * Each state change emits its associated event name.
 *
 * ####Example
 *
 *     conn.<span class="apidocCodeKeywordSpan">on</span>(&#x27;connected&#x27;, callback);
 *     conn.on(&#x27;disconnected&#x27;, callback);
 *
 * @property readyState
 * @api public
 */

Object.defineProperty(Connection.prototype, &#x27;readyState&#x27;, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.once" id="apidoc.element.mongoose.document.prototype.once">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>once
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">once = function () {
  return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        aggregate(_this._pipeline, options || {});
      decorateCursor(cursor);
      resolve(cursor);
      callback &#x26;&#x26; callback(null, cursor);
    });
    return;
  }
  _this._model.collection.emitter.<span class="apidocCodeKeywordSpan">once</span>(&#x27;queue&#x27;, function() {
    var cursor = _this._model.collection.
      aggregate(_this._pipeline, options || {});
    decorateCursor(cursor);
    resolve(cursor);
    callback &#x26;&#x26; callback(null, cursor);
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.populate" id="apidoc.element.mongoose.document.prototype.populate">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>populate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function populate() {
  if (arguments.length === 0) {
    return this;
  }

  var pop = this.$__.populate || (this.$__.populate = {});
  var args = utils.args(arguments);
  var fn;

  if (typeof args[args.length - 1] === &#x27;function&#x27;) {
    fn = args.pop();
  }

  // allow `doc.populate(callback)`
  if (args.length) {
    // use hash to remove duplicate paths
    var res = utils.populate.apply(null, args);
    for (var i = 0; i &#x3c; res.length; ++i) {
      pop[res[i].path] = res[i];
    }
  }

  if (fn) {
    var paths = utils.object.vals(pop);
    this.$__.populate = undefined;
    paths.__noPromise = true;
    this.constructor.populate(this, paths, fn);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Populates document references, executing the `callback` when complete.
* If you want to use promises instead, use this function with
* [`execPopulate()`](#document_Document-execPopulate)
*
* ####Example:
*
*     doc
*     .<span class="apidocCodeKeywordSpan">populate</span>(&#x27;company&#x27;)
*     .populate({
*       path: &#x27;notes&#x27;,
*       match: /airline/,
*       select: &#x27;text&#x27;,
*       model: &#x27;modelName&#x27;
*       options: opts
*     }, function (err, user) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.populated" id="apidoc.element.mongoose.document.prototype.populated">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>populated
        <span class="apidocSignatureSpan">(path, val, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">populated = function (path, val, options) {
  // val and options are internal

  if (val === null || val === void 0) {
    if (!this.$__.populated) {
      return undefined;
    }
    var v = this.$__.populated[path];
    if (v) {
      return v.value;
    }
    return undefined;
  }

  // internal

  if (val === true) {
    if (!this.$__.populated) {
      return undefined;
    }
    return this.$__.populated[path];
  }

  this.$__.populated || (this.$__.populated = {});
  this.$__.populated[path] = {value: val, options: options};
  return val;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If doc._id is not null or undefined
if (doc._id !== null &#x26;&#x26; doc._id !== undefined &#x26;&#x26;
  opts &#x26;&#x26; opts.populated &#x26;&#x26; opts.populated.length) {
  var id = String(doc._id);
  for (var i = 0; i &#x3c; opts.populated.length; ++i) {
    var item = opts.populated[i];
    if (item.isVirtual) {
      this.<span class="apidocCodeKeywordSpan">populated</span>(item.path, utils.getValue(item.path, doc), item);
    } else {
      this.populated(item.path, item._docs[id], item);
    }
  }
}

init(this, doc, this._doc);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.removeAllListeners" id="apidoc.element.mongoose.document.prototype.removeAllListeners">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>removeAllListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeAllListeners = function () {
  return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.removeListener" id="apidoc.element.mongoose.document.prototype.removeListener">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>removeListener
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeListener = function () {
  return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.removePost" id="apidoc.element.mongoose.document.prototype.removePost">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>removePost
        <span class="apidocSignatureSpan">(name, fnToRemove)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removePost = function (name, fnToRemove) {
  var proto = this.prototype || this
    , posts = proto._posts || (proto._posts || {});
  if (!posts[name]) return this;
  if (arguments.length === 1) {
    // Remove all post callbacks for hook `name`
    posts[name].length = 0;
  } else {
    posts[name] = posts[name].filter( function (currFn) {
      return currFn !== fnToRemove;
    });
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.removePre" id="apidoc.element.mongoose.document.prototype.removePre">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>removePre
        <span class="apidocSignatureSpan">(name, fnToRemove)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removePre = function (name, fnToRemove) {
  var proto = this.prototype || this
    , pres = proto._pres || (proto._pres || {});
  if (!pres[name]) return this;
  if (arguments.length === 1) {
    // Remove all pre callbacks for hook `name`
    pres[name].length = 0;
  } else {
    pres[name] = pres[name].filter( function (currFn) {
      return currFn !== fnToRemove;
    });
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.set" id="apidoc.element.mongoose.document.prototype.set">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>set
        <span class="apidocSignatureSpan">(path, val, type, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (path, val, type, options) {
  if (type &#x26;&#x26; utils.getFunctionName(type.constructor) === &#x27;Object&#x27;) {
    options = type;
    type = undefined;
  }

  var merge = options &#x26;&#x26; options.merge,
      adhoc = type &#x26;&#x26; type !== true,
      constructing = type === true,
      adhocs;

  var strict = options &#x26;&#x26; &#x27;strict&#x27; in options
      ? options.strict
      : this.$__.strictMode;

  if (adhoc) {
    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
    adhocs[path] = Schema.interpretAsType(path, type, this.schema.options);
  }

  if (typeof path !== &#x27;string&#x27;) {
    // new Document({ key: val })

    if (path === null || path === void 0) {
      var _ = path;
      path = val;
      val = _;
    } else {
      var prefix = val
          ? val + &#x27;.&#x27;
          : &#x27;&#x27;;

      if (path instanceof Document) {
        if (path.$__isNested) {
          path = path.toObject();
        } else {
          path = path._doc;
        }
      }

      var keys = Object.keys(path);
      var len = keys.length;
      var i = 0;
      var pathtype;
      var key;

      if (len === 0 &#x26;&#x26; !this.schema.options.minimize) {
        if (val) {
          this.set(val, {});
        }
        return this;
      }

      if (this.schema.options.retainKeyOrder) {
        while (i &#x3c; len) {
          _handleIndex.call(this, i++);
        }
      } else {
        while (len--) {
          _handleIndex.call(this, len);
        }
      }

      return this;
    }
  }

  function _handleIndex(i) {
    key = keys[i];
    var pathName = prefix + key;
    pathtype = this.schema.pathType(pathName);

    if (path[key] !== null
        &#x26;&#x26; path[key] !== void 0
          // need to know if plain object - no Buffer, ObjectId, ref, etc
        &#x26;&#x26; utils.isObject(path[key])
        &#x26;&#x26; (!path[key].constructor || utils.getFunctionName(path[key].constructor) === &#x27;Object&#x27;)
        &#x26;&#x26; pathtype !== &#x27;virtual&#x27;
        &#x26;&#x26; pathtype !== &#x27;real&#x27;
        &#x26;&#x26; !(this.$__path(pathName) instanceof MixedSchema)
        &#x26;&#x26; !(this.schema.paths[pathName] &#x26;&#x26;
        this.schema.paths[pathName].options &#x26;&#x26;
        this.schema.paths[pathName].options.ref)) {
      this.set(path[key], prefix + key, constructing);
    } else if (strict) {
      // Don&#x27;t overwrite defaults with undefined keys (gh-3981)
      if (constructing &#x26;&#x26; path[key] === void 0 &#x26;&#x26;
          this.get(key) !== void 0) {
        return;
      }

      if (pathtype === &#x27;real&#x27; || pathtype === &#x27;virtual&#x27;) {
        // Check for setting single embedded schema to document (gh-3535)
        var p = path[key];
        if (this.schema.paths[pathName] &#x26;&#x26;
            this.schema.paths[pathName].$isSingleNested &#x26;&#x26;
            path[key] instanceof Document) {
          p = p.toObject({ virtuals: false, transform: false });
        }
        this.set(prefix + key, p, constructing);
      } else if (pathtype === &#x27;nested&#x27; &#x26;&#x26; path[key] instanceof Document) {
        this.set(prefix + key,
            path[key].toObject({transform: false}), constructing);
      } else if (strict === &#x27;throw&#x27;) {
        if (pathtype === &#x27;nested&#x27;) {
          throw new ObjectExpectedError(key, path[key]);
        } else {
          throw new StrictModeError(key);
        }
      }
    } else if (path[key] !== void 0) {
      this.set(prefix + key, path[key], constructing);
    }
  }

  var pathType = this.schema.pathType(path);
  if (pathType === &#x27;nested&#x27; &#x26;&#x26; val) {
    if (utils.isObject(val) &#x26;&#x26;
        (!val.constructor || utils.getFunctionName(val.constructor) === &#x27;Object&#x27;)) {
      if (!merge) {
        this.setValue(path, null);
        cleanModifiedSubpaths(this, path);
      }

      if (Object.keys(val).length === 0) {
        this.setValue(path, {});
        this.markModified(path);
        cleanModifiedSubpaths(this, path);
      } else {
        this.set(val, path, constructing);
      }
      return this;
    }
    this.invalidate(path, new MongooseError.CastError(&#x27;Object&#x27;, val, path));
    return this;
  }

  var schema;
  var parts = path.split(&#x27;.&#x27;);

  if (pathType === &#x27;adhocOrUndefined&#x27; &#x26;&#x26; strict) {
    // check for roots that are Mixed types ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
age: { type: Number, min: 18, index: true },
bio: { type: String, match: /[a-z]/ },
date: { type: Date, default: Date.now },
buff: Buffer
});

// a setter
Comment.path(&#x27;name&#x27;).<span class="apidocCodeKeywordSpan">set</span>(function (v) {
return capitalize(v);
});

// middleware
Comment.pre(&#x27;save&#x27;, function (next) {
notify(this.get(&#x27;email&#x27;));
next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.setMaxListeners" id="apidoc.element.mongoose.document.prototype.setMaxListeners">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>setMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setMaxListeners = function () {
  return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var required = this.schema.requiredPaths();
for (var i = 0; i &#x3c; required.length; ++i) {
  this.$__.activePaths.require(required[i]);
}

this.$__.emitter.<span class="apidocCodeKeywordSpan">setMaxListeners</span>(0);
this._doc = this.$__buildDoc(obj, fields, skipId);

if (!skipInit &#x26;&#x26; obj) {
  this.init(obj);
}

this.$__registerHooksFromSchema();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.setValue" id="apidoc.element.mongoose.document.prototype.setValue">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>setValue
        <span class="apidocSignatureSpan">(path, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setValue = function (path, val) {
  utils.setValue(path, val, this._doc);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  var pathType = this.schema.pathType(path);
  if (pathType === &#x27;nested&#x27; &#x26;&#x26; val) {
    if (utils.isObject(val) &#x26;&#x26;
  (!val.constructor || utils.getFunctionName(val.constructor) === &#x27;Object&#x27;)) {
if (!merge) {
  this.<span class="apidocCodeKeywordSpan">setValue</span>(path, null);
  cleanModifiedSubpaths(this, path);
}

if (Object.keys(val).length === 0) {
  this.setValue(path, {});
  this.markModified(path);
  cleanModifiedSubpaths(this, path);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.toBSON" id="apidoc.element.mongoose.document.prototype.toBSON">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>toBSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBSON = function () {
  return this.toObject({
    transform: false,
    virtuals: false,
    _skipDepopulateTopLevel: true,
    depopulate: true,
    flattenDecimals: false
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.toJSON" id="apidoc.element.mongoose.document.prototype.toJSON">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>toJSON
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function (options) {
  return this.$toObject(options, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (Array.isArray(obj)) {
  return cloneArray(obj, options);
}

if (isMongooseObject(obj)) {
  if (options &#x26;&#x26; options.json &#x26;&#x26; typeof obj.toJSON === &#x27;function&#x27;) {
    return obj.<span class="apidocCodeKeywordSpan">toJSON</span>(options);
  }
  return obj.toObject(options);
}

if (obj.constructor) {
  switch (exports.getFunctionName(obj.constructor)) {
    case &#x27;Object&#x27;:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.toObject" id="apidoc.element.mongoose.document.prototype.toObject">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>toObject
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toObject = function (options) {
  return this.$toObject(options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (value.$maxDistance != null) {
    value.$maxDistance = numbertype.castForQuery(value.$maxDistance);
  }
  if (value.$minDistance != null) {
    value.$minDistance = numbertype.castForQuery(value.$minDistance);
  }
  if (utils.isMongooseObject(value.$geometry)) {
    value.$geometry = value.$geometry.<span class="apidocCodeKeywordSpan">toObject</span>({
      transform: false,
      virtuals: false
    });
  }
  value = value.$geometry.coordinates;
} else if (geo === &#x27;$geoWithin&#x27;) {
  if (value.$geometry) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.toString" id="apidoc.element.mongoose.document.prototype.toString">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>toString
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toString = function () {
  return inspect(this.inspect());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Moreover, you can mutate the incoming `method` arguments so that subsequent middleware see different values for those arguments.
To do so, just pass the new values to `next`:

```js
.pre(method, function firstPre (next, methodArg1, methodArg2) {
// Mutate methodArg1
next(&#x22;altered-&#x22; + methodArg1.<span class="apidocCodeKeywordSpan">toString</span>(), methodArg2);
});

// pre declaration is chainable
.pre(method, function secondPre (next, methodArg1, methodArg2) {
console.log(methodArg1);
// =&#x3e; &#x27;altered-originalValOfMethodArg1&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.unmarkModified" id="apidoc.element.mongoose.document.prototype.unmarkModified">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>unmarkModified
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmarkModified = function (path) {
  this.$__.activePaths.init(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
 * Clears the modified state on the specified path.
 *
 * ####Example:
 *
 *     doc.foo = &#x27;bar&#x27;;
 *     doc.<span class="apidocCodeKeywordSpan">unmarkModified</span>(&#x27;foo&#x27;);
 *     doc.save() // changes to foo will not be persisted
 *
 * @param {String} path the path to unmark modified
 * @api public
 */

Document.prototype.unmarkModified = function(path) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.update" id="apidoc.element.mongoose.document.prototype.update">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>update
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function update() {
  var args = utils.args(arguments);
  args.unshift({_id: this._id});
  return this.constructor.update.apply(this.constructor, args);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

/**
* Sends an update command with this document `_id` as the query selector.
*
* ####Example:
*
*     weirdCar.<span class="apidocCodeKeywordSpan">update</span>({$inc: {wheels:1}}, { w: 1 }, callback);
*
* ####Valid options:
*
*  - same as in [Model.update](#model_Model.update)
*
* @see Model.update #model_Model.update
* @param {Object} doc
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.validate" id="apidoc.element.mongoose.document.prototype.validate">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>validate
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = null;
  }

  this.$__validate(callback || function() {});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* ####Note:
*
* This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned
 to your `callback`.
*
* ####Example:
*
*     doc.<span class="apidocCodeKeywordSpan">validate</span>(function (err) {
*       if (err) handleError(err);
*       else // validation passed
*     });
*
* @param {Object} optional options internal options
* @param {Function} callback optional callback called after validation completes, passing an error if one occurred
* @return {Promise} Promise
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.document.prototype.validateSync" id="apidoc.element.mongoose.document.prototype.validateSync">
        function <span class="apidocSignatureSpan">mongoose.document.prototype.</span>validateSync
        <span class="apidocSignatureSpan">(pathsToValidate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validateSync = function (pathsToValidate) {
  var _this = this;

  if (typeof pathsToValidate === &#x27;string&#x27;) {
    pathsToValidate = pathsToValidate.split(&#x27; &#x27;);
  }

  // only validate required fields when necessary
  var paths = _getPathsToValidate(this);

  if (pathsToValidate &#x26;&#x26; pathsToValidate.length) {
    var tmp = [];
    for (var i = 0; i &#x3c; paths.length; ++i) {
      if (pathsToValidate.indexOf(paths[i]) !== -1) {
        tmp.push(paths[i]);
      }
    }
    paths = tmp;
  }

  var validating = {};

  paths.forEach(function(path) {
    if (validating[path]) {
      return;
    }

    validating[path] = true;

    var p = _this.schema.path(path);
    if (!p) {
      return;
    }
    if (!_this.$isValid(path)) {
      return;
    }

    var val = _this.getValue(path);
    var err = p.doValidateSync(val, _this);
    if (err) {
      _this.invalidate(path, err, undefined, true);
    }
  });

  var err = _this.$__.validationError;
  _this.$__.validationError = undefined;
  _this.emit(&#x27;validate&#x27;, _this);
  _this.constructor.emit(&#x27;validate&#x27;, _this);

  if (err) {
    for (var key in err.errors) {
      // Make sure cast errors persist
      if (err.errors[key] instanceof MongooseError.CastError) {
        _this.invalidate(key, err.errors[key]);
      }
    }
  }

  return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* ####Note:
*
* This method is useful if you need synchronous validation.
*
* ####Example:
*
*     var err = doc.<span class="apidocCodeKeywordSpan">validateSync</span>();
*     if ( err ){
*       handleError( err );
*     } else {
*       // validation passed
*     }
*
* @param {Array|string} pathsToValidate only validate the given paths
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.error" id="apidoc.module.mongoose.error">module mongoose.error</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.error.error" id="apidoc.element.mongoose.error.error">
        function <span class="apidocSignatureSpan">mongoose.</span>error
        <span class="apidocSignatureSpan">(msg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MongooseError(msg) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this);
  } else {
    this.stack = new Error().stack;
  }
  this.message = msg;
  this.name = &#x27;MongooseError&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!rgxProtocol.test(host)) {
  host = &#x27;mongodb://&#x27; + host;
}

try {
  parsed = muri(host);
} catch (err) {
  this.<span class="apidocCodeKeywordSpan">error</span>(err, callback);
  return new Promise.ES6(function(resolve, reject) {
    reject(err);
  });
}

database = parsed.db;
host = parsed.hosts[0].host || parsed.hosts[0].ipc;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.error.CastError" id="apidoc.element.mongoose.error.CastError">
        function <span class="apidocSignatureSpan">mongoose.error.</span>CastError
        <span class="apidocSignatureSpan">(type, value, path, reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CastError(type, value, path, reason) {
  var stringValue = util.inspect(value);
  stringValue = stringValue.replace(/^&#x27;/, &#x27;&#x22;&#x27;).replace(/&#x27;$/, &#x27;&#x22;&#x27;);
  if (stringValue.charAt(0) !== &#x27;&#x22;&#x27;) {
    stringValue = &#x27;&#x22;&#x27; + stringValue + &#x27;&#x22;&#x27;;
  }
  MongooseError.call(this, &#x27;Cast to &#x27; + type + &#x27; failed for value &#x27; +
    stringValue + &#x27; at path &#x22;&#x27; + path + &#x27;&#x22;&#x27;);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this);
  } else {
    this.stack = new Error().stack;
  }
  this.stringValue = stringValue;
  this.name = &#x27;CastError&#x27;;
  this.kind = type;
  this.value = value;
  this.path = path;
  this.reason = reason;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      this.markModified(path);
      cleanModifiedSubpaths(this, path);
    } else {
      this.set(val, path, constructing);
    }
    return this;
  }
  this.invalidate(path, new MongooseError.<span class="apidocCodeKeywordSpan">CastError</span>(&#x27;Object&#x27;, val, path));
  return this;
}

var schema;
var parts = path.split(&#x27;.&#x27;);

if (pathType === &#x27;adhocOrUndefined&#x27; &#x26;&#x26; strict) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.error.DivergentArrayError" id="apidoc.element.mongoose.error.DivergentArrayError">
        function <span class="apidocSignatureSpan">mongoose.error.</span>DivergentArrayError
        <span class="apidocSignatureSpan">(paths)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DivergentArrayError(paths) {
  var msg = &#x27;For your own good, using `document.save()` to update an array &#x27;
          + &#x27;which was selected using an $elemMatch projection OR &#x27;
          + &#x27;populated using skip, limit, query conditions, or exclusion of &#x27;
          + &#x27;the _id field when the operation results in a $pop or $set of &#x27;
          + &#x27;the entire array is not supported. The following &#x27;
          + &#x27;path(s) would have been modified unsafely:\n&#x27;
          + &#x27;  &#x27; + paths.join(&#x27;\n  &#x27;) + &#x27;\n&#x27;
          + &#x27;Use Model.update() to update these arrays instead.&#x27;;
          // TODO write up a docs page (FAQ) and link to it

  MongooseError.call(this, msg);
  Error.captureStackTrace &#x26;&#x26; Error.captureStackTrace(this, arguments.callee);
  this.name = &#x27;DivergentArrayError&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.error.DocumentNotFoundError" id="apidoc.element.mongoose.error.DocumentNotFoundError">
        function <span class="apidocSignatureSpan">mongoose.error.</span>DocumentNotFoundError
        <span class="apidocSignatureSpan">(query)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function DocumentNotFoundError(query) {
  MongooseError.call(this, &#x27;No document found for query &#x22;&#x27; +
    util.inspect(query) + &#x27;&#x22;&#x27;);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this);
  } else {
    this.stack = new Error().stack;
  }

  this.name = &#x27;DocumentNotFoundError&#x27;;
  this.query = query;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.error.MissingSchemaError" id="apidoc.element.mongoose.error.MissingSchemaError">
        function <span class="apidocSignatureSpan">mongoose.error.</span>MissingSchemaError
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MissingSchemaError(name) {
  var msg = &#x27;Schema hasn\&#x27;t been registered for model &#x22;&#x27; + name + &#x27;&#x22;.\n&#x27;
          + &#x27;Use mongoose.model(name, schema)&#x27;;
  MongooseError.call(this, msg);
  Error.captureStackTrace &#x26;&#x26; Error.captureStackTrace(this, arguments.callee);
  this.name = &#x27;MissingSchemaError&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  if (obj._id === undefined) {
    obj._id = new ObjectId();
  }
}

if (!schema) {
  throw new MongooseError.<span class="apidocCodeKeywordSpan">MissingSchemaError</span>();
}

this.$__setSchema(schema);

this.$__ = new InternalCache;
this.$__.emitter = new EventEmitter();
this.isNew = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.error.OverwriteModelError" id="apidoc.element.mongoose.error.OverwriteModelError">
        function <span class="apidocSignatureSpan">mongoose.error.</span>OverwriteModelError
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function OverwriteModelError(name) {
  MongooseError.call(this, &#x27;Cannot overwrite `&#x27; + name + &#x27;` model once compiled.&#x27;);
  Error.captureStackTrace &#x26;&#x26; Error.captureStackTrace(this, arguments.callee);
  this.name = &#x27;OverwriteModelError&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  throw new Error(&#x27;The 2nd parameter to `mongoose.model()` should be a &#x27; +
    &#x27;schema or a POJO&#x27;);
}

if (this.models[name] &#x26;&#x26; !collection) {
  // model exists but we are not subclassing with custom collection
  if (schema &#x26;&#x26; schema.instanceOfSchema &#x26;&#x26; schema !== this.models[name].schema) {
    throw new MongooseError.<span class="apidocCodeKeywordSpan">OverwriteModelError</span>(name);
  }
  return this.models[name];
}

var opts = {cache: false, connection: this};
var model;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.error.ValidationError" id="apidoc.element.mongoose.error.ValidationError">
        function <span class="apidocSignatureSpan">mongoose.error.</span>ValidationError
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidationError(instance) {
  this.errors = {};
  if (instance &#x26;&#x26; instance.constructor.name === &#x27;model&#x27;) {
    MongooseError.call(this, instance.constructor.modelName + &#x27; validation failed&#x27;);
  } else {
    MongooseError.call(this, &#x27;Validation failed&#x27;);
  }
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this);
  } else {
    this.stack = new Error().stack;
  }
  this.name = &#x27;ValidationError&#x27;;
  if (instance) {
    instance.errors = this.errors;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.error.ValidatorError" id="apidoc.element.mongoose.error.ValidatorError">
        function <span class="apidocSignatureSpan">mongoose.error.</span>ValidatorError
        <span class="apidocSignatureSpan">(properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidatorError(properties) {
  var msg = properties.message;
  if (!msg) {
    msg = MongooseError.messages.general.default;
  }

  var message = this.formatMessage(msg, properties);
  MongooseError.call(this, message);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this);
  } else {
    this.stack = new Error().stack;
  }
  this.properties = properties;
  this.name = &#x27;ValidatorError&#x27;;
  this.kind = properties.type;
  this.path = properties.path;
  this.value = properties.value;
  this.reason = properties.reason;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.error.VersionError" id="apidoc.element.mongoose.error.VersionError">
        function <span class="apidocSignatureSpan">mongoose.error.</span>VersionError
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VersionError(doc) {
  MongooseError.call(this, &#x27;No matching document found for id &#x22;&#x27; + doc._id +
    &#x27;&#x22;&#x27;);
  this.name = &#x27;VersionError&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.error.prototype" id="apidoc.module.mongoose.error.prototype">module mongoose.error.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.error.prototype.constructor" id="apidoc.element.mongoose.error.prototype.constructor">
        function <span class="apidocSignatureSpan">mongoose.error.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Error() { [native code] }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (obj.constructor) {
  switch (exports.getFunctionName(obj.constructor)) {
    case &#x27;Object&#x27;:
      return cloneObject(obj, options);
    case &#x27;Date&#x27;:
      return new obj.<span class="apidocCodeKeywordSpan">constructor</span>(+obj);
    case &#x27;RegExp&#x27;:
      return cloneRegExp(obj);
    default:
      // ignore
      break;
  }
}
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.model" id="apidoc.module.mongoose.model">module mongoose.model</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.model.model" id="apidoc.element.mongoose.model.model">
        function <span class="apidocSignatureSpan">mongoose.</span>model
        <span class="apidocSignatureSpan">(doc, fields, skipId)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Model(doc, fields, skipId) {
  Document.call(this, doc, fields, skipId, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

Take a look at the example in `examples/schema.js` for an end-to-end example of a typical setup.

### Accessing a Model

Once we define a model through `mongoose.<span class="apidocCodeKeywordSpan">model</span>(&#x27;ModelName&#x27;, mySchema)`, we
can access it through the same function

```js
var myModel = mongoose.model(&#x27;ModelName&#x27;);
```

Or just do it all at once
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.__subclass" id="apidoc.element.mongoose.model.__subclass">
        function <span class="apidocSignatureSpan">mongoose.model.</span>__subclass
        <span class="apidocSignatureSpan">(conn, schema, collection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function subclass(conn, schema, collection) {
  // subclass model using this connection and collection name
  var _this = this;

  var Model = function Model(doc, fields, skipId) {
    if (!(this instanceof Model)) {
      return new Model(doc, fields, skipId);
    }
    _this.call(this, doc, fields, skipId);
  };

  Model.__proto__ = _this;
  Model.prototype.__proto__ = _this.prototype;
  Model.db = Model.prototype.db = conn;

  var s = schema &#x26;&#x26; typeof schema !== &#x27;string&#x27;
      ? schema
      : _this.prototype.schema;

  var options = s.options || {};

  if (!collection) {
    collection = _this.prototype.schema.get(&#x27;collection&#x27;)
        || utils.toCollectionName(_this.modelName, options);
  }

  var collectionOptions = {
    bufferCommands: s ? options.bufferCommands : true,
    capped: s &#x26;&#x26; options.capped
  };

  Model.prototype.collection = conn.collection(collection, collectionOptions);
  Model.collection = Model.prototype.collection;
  Model.init();
  return Model;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return model;
}

if (this.models[name] &#x26;&#x26; collection) {
  // subclassing current model with alternate collection
  model = this.models[name];
  schema = model.prototype.schema;
  var sub = model.<span class="apidocCodeKeywordSpan">__subclass</span>(this, schema, collection);
  // do not cache the sub model
  return sub;
}

// lookup model in mongoose module
model = this.base.models[name];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model._getSchema" id="apidoc.element.mongoose.model._getSchema">
        function <span class="apidocSignatureSpan">mongoose.model.</span>_getSchema
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _getSchema(path) {
  return this.schema._getSchema(path);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    modelNameFromQuery = options.model &#x26;&#x26; options.model.modelName || options.model,
    schema, refPath, Model, currentOptions, modelNames, modelName, discriminatorKey, modelForFindSchema;

var originalModel = options.model;
var isVirtual = false;
var isRefPathArray = false;

schema = model.<span class="apidocCodeKeywordSpan">_getSchema</span>(options.path);
var isUnderneathDocArray = schema &#x26;&#x26; schema.$isUnderneathDocArray;
if (isUnderneathDocArray &#x26;&#x26;
    options &#x26;&#x26;
    options.options &#x26;&#x26;
    options.options.sort) {
  return new Error(&#x27;Cannot populate with `sort` on path &#x27; + options.path +
    &#x27; because it is a subproperty of a document array&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.addListener" id="apidoc.element.mongoose.model.addListener">
        function <span class="apidocSignatureSpan">mongoose.model.</span>addListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addListener(type, listener) {
  return _addListener(this, type, listener, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.aggregate" id="apidoc.element.mongoose.model.aggregate">
        function <span class="apidocSignatureSpan">mongoose.model.</span>aggregate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function aggregate() {
  var args = [].slice.call(arguments),
      aggregate,
      callback;

  if (typeof args[args.length - 1] === &#x27;function&#x27;) {
    callback = args.pop();
  }

  if (args.length === 1 &#x26;&#x26; util.isArray(args[0])) {
    aggregate = new Aggregate(args[0]);
  } else {
    aggregate = new Aggregate(args);
  }

  aggregate.model(this);

  if (typeof callback === &#x27;undefined&#x27;) {
    return aggregate;
  }

  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  aggregate.exec(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* ####Example:
*
*     new Aggregate();
*     new Aggregate({ $project: { a: 1, b: 1 } });
*     new Aggregate({ $project: { a: 1, b: 1 } }, { $skip: 5 });
*     new Aggregate([{ $project: { a: 1, b: 1 } }, { $skip: 5 }]);
*
* Returned when calling Model.<span class="apidocCodeKeywordSpan">aggregate</span>().
*
* ####Example:
*
*     Model
*     .aggregate({ $match: { age: { $gte: 21 }}})
*     .unwind(&#x27;tags&#x27;)
*     .exec(callback)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.bulkWrite" id="apidoc.element.mongoose.model.bulkWrite">
        function <span class="apidocSignatureSpan">mongoose.model.</span>bulkWrite
        <span class="apidocSignatureSpan">(ops, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bulkWrite = function (ops, options, callback) {
  var Promise = PromiseProvider.get();
  var _this = this;
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = null;
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  options = options || {};

  var validations = ops.map(function(op) {
    if (op[&#x27;insertOne&#x27;]) {
      return function(callback) {
        op[&#x27;insertOne&#x27;][&#x27;document&#x27;] = new _this(op[&#x27;insertOne&#x27;][&#x27;document&#x27;]);
        op[&#x27;insertOne&#x27;][&#x27;document&#x27;].validate({ __noPromise: true }, function(error) {
          if (error) {
            return callback(error);
          }
          callback(null);
        });
      };
    } else if (op[&#x27;updateOne&#x27;]) {
      return function(callback) {
        try {
          op[&#x27;updateOne&#x27;][&#x27;filter&#x27;] = cast(_this.schema,
            op[&#x27;updateOne&#x27;][&#x27;filter&#x27;]);
          op[&#x27;updateOne&#x27;][&#x27;update&#x27;] = castUpdate(_this.schema,
            op[&#x27;updateOne&#x27;][&#x27;update&#x27;], _this.schema.options.strict);
        } catch (error) {
          return callback(error);
        }

        callback(null);
      };
    } else if (op[&#x27;updateMany&#x27;]) {
      return function(callback) {
        try {
          op[&#x27;updateMany&#x27;][&#x27;filter&#x27;] = cast(_this.schema,
            op[&#x27;updateMany&#x27;][&#x27;filter&#x27;]);
          op[&#x27;updateMany&#x27;][&#x27;update&#x27;] = castUpdate(_this.schema, op[&#x27;updateMany&#x27;][&#x27;filter&#x27;], {
            strict: _this.schema.options.strict,
            overwrite: false
          });
        } catch (error) {
          return callback(error);
        }

        callback(null);
      };
    } else if (op[&#x27;replaceOne&#x27;]) {
      return function(callback) {
        try {
          op[&#x27;replaceOne&#x27;][&#x27;filter&#x27;] = cast(_this.schema,
            op[&#x27;replaceOne&#x27;][&#x27;filter&#x27;]);
        } catch (error) {
          return callback(error);
        }

        // set `skipId`, otherwise we get &#x22;_id field cannot be changed&#x22;
        op[&#x27;replaceOne&#x27;][&#x27;replacement&#x27;] =
          new _this(op[&#x27;replaceOne&#x27;][&#x27;replacement&#x27;], null, true);
        op[&#x27;replaceOne&#x27;][&#x27;replacement&#x27;].validate({ __noPromise: true }, function(error) {
          if (error) {
            return callback(error);
          }
          callback(null);
        });
      };
    } else if (op[&#x27;deleteOne&#x27;]) {
      return function(callback) {
        try {
          op[&#x27;deleteOne&#x27;][&#x27;filter&#x27;] = cast(_this.schema,
            op[&#x27;deleteOne&#x27;][&#x27;filter&#x27;]);
        } catch (error) {
          return callback(error);
        }

        callback(null);
      };
    } else if (op[&#x27;deleteMany&#x27;]) {
      return function(callback) {
        try {
          op[&#x27;deleteMany&#x27;][&#x27;filter&#x27;] = cast(_this.schema,
            op[&#x27;deleteMany&#x27;][&#x27;filter&#x27;]);
        } catch (error) {
          return callback(error);
        }

        callback(null);
      };
    } else {
      return function(callback) {
        callback(new Error(&#x27;Invalid op passed to `bulkWrite()`&#x27;));
      };
    }
  });

  var promise = new Promise.ES6(function(resolve, reject) {
    parallel(validations, function(error) {
      if (error) {
        callback &#x26;&#x26; callback(error);
        return reject(error);
      }

      _this.collection.bulkWrite(ops, options, function(error, res) {
        if (error) {
          callback &#x26;&#x26; callback(error);
          return reject(error);
        }

        callback &#x26;&#x26; callback(null, res);
        resolve(res);
      });
    });
  });

  return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Mongoose will perform casting on all operations you provide.
*
* This function does **not** trigger any middleware.
*
* ####Example:
*
*     Character.<span class="apidocCodeKeywordSpan">bulkWrite</span>([
*       {
*         insertOne: {
*           document: {
*             name: &#x27;Eddard Stark&#x27;,
*             title: &#x27;Warden of the North&#x27;
*           }
*         }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.compile" id="apidoc.element.mongoose.model.compile">
        function <span class="apidocSignatureSpan">mongoose.model.</span>compile
        <span class="apidocSignatureSpan">(name, schema, collectionName, connection, base)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compile(name, schema, collectionName, connection, base) {
  var versioningEnabled = schema.options.versionKey !== false;

  if (versioningEnabled &#x26;&#x26; !schema.paths[schema.options.versionKey]) {
    // add versioning to top level documents only
    var o = {};
    o[schema.options.versionKey] = Number;
    schema.add(o);
  }

  var model;
  if (typeof name === &#x27;function&#x27; &#x26;&#x26; name.prototype instanceof Model) {
    model = name;
    name = model.name;
    schema.loadClass(model, true);
    model.prototype.$isMongooseModelPrototype = true;
  } else {
    // generate new class
    model = function model(doc, fields, skipId) {
      if (!(this instanceof model)) {
        return new model(doc, fields, skipId);
      }
      Model.call(this, doc, fields, skipId);
    };
  }

  model.hooks = schema.s.hooks.clone();
  model.base = base;
  model.modelName = name;
  if (!(model.prototype instanceof Model)) {
    model.__proto__ = Model;
    model.prototype.__proto__ = Model.prototype;
  }
  model.model = Model.prototype.model;
  model.db = model.prototype.db = connection;
  model.discriminators = model.prototype.discriminators = undefined;

  model.prototype.$__setSchema(schema);

  var collectionOptions = {
    bufferCommands: schema.options.bufferCommands,
    capped: schema.options.capped
  };

  model.prototype.collection = connection.collection(
      collectionName
      , collectionOptions
  );

  // apply methods and statics
  applyMethods(model, schema);
  applyStatics(model, schema);
  applyHooks(model, schema);

  model.schema = model.prototype.schema;
  model.collection = model.prototype.collection;

  // Create custom query constructor
  model.Query = function() {
    Query.apply(this, arguments);
    this.options.retainKeyOrder = model.schema.options.retainKeyOrder;
  };
  model.Query.prototype = Object.create(Query.prototype);
  model.Query.base = Query.base;
  applyQueryMethods(model, schema.query);

  var kareemOptions = { useErrorHandlers: true };
  model.$__insertMany = model.hooks.createWrapper(&#x27;insertMany&#x27;,
    model.insertMany, model, kareemOptions);
  model.insertMany = function(arr, options, callback) {
    var Promise = PromiseProvider.get();
    if (typeof options === &#x27;function&#x27;) {
      callback = options;
      options = null;
    }
    return new Promise.ES6(function(resolve, reject) {
      model.$__insertMany(arr, options, function(error, result) {
        if (error) {
          callback &#x26;&#x26; callback(error);
          return reject(error);
        }
        callback &#x26;&#x26; callback(null, result);
        resolve(result);
      });
    });
  };

  return model;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
callback &#x26;&#x26; callback(err);
reject(err);
return;
      }

      if (ret.findOne &#x26;&#x26; ret.mapReduce) {
// returned a collection, convert to Model
var model = Model.<span class="apidocCodeKeywordSpan">compile</span>(
    &#x27;_mapreduce_&#x27; + ret.collectionName
    , Model.mapReduce.schema
    , ret.collectionName
    , _this.db
    , _this.base);

model._mapreduce = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.count" id="apidoc.element.mongoose.model.count">
        function <span class="apidocSignatureSpan">mongoose.model.</span>count
        <span class="apidocSignatureSpan">(conditions, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function count(conditions, callback) {
  if (typeof conditions === &#x27;function&#x27;) {
    callback = conditions;
    conditions = {};
  }

  // get the mongodb collection object
  var mq = new this.Query({}, {}, this, this.collection);

  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  return mq.count(conditions, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Counts number of matching documents in a database collection.
*
* ####Example:
*
*     Adventure.<span class="apidocCodeKeywordSpan">count</span>({ type: &#x27;jungle&#x27; }, function (err, count) {
*       if (err) ..
*       console.log(&#x27;there are %d jungle adventures&#x27;, count);
*     });
*
* @param {Object} conditions
* @param {Function} [callback]
* @return {Query}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.create" id="apidoc.element.mongoose.model.create">
        function <span class="apidocSignatureSpan">mongoose.model.</span>create
        <span class="apidocSignatureSpan">(doc, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function create(doc, callback) {
  var args;
  var cb;
  var discriminatorKey = this.schema.options.discriminatorKey;

  if (Array.isArray(doc)) {
    args = doc;
    cb = callback;
  } else {
    var last = arguments[arguments.length - 1];
    // Handle falsy callbacks re: #5061
    if (typeof last === &#x27;function&#x27; || !last) {
      cb = last;
      args = utils.args(arguments, 0, arguments.length - 1);
    } else {
      args = utils.args(arguments);
    }
  }

  var Promise = PromiseProvider.get();
  var _this = this;
  if (cb) {
    cb = this.$wrapCallback(cb);
  }

  var promise = new Promise.ES6(function(resolve, reject) {
    if (args.length === 0) {
      setImmediate(function() {
        cb &#x26;&#x26; cb(null);
        resolve(null);
      });
      return;
    }

    var toExecute = [];
    args.forEach(function(doc) {
      toExecute.push(function(callback) {
        var Model = _this.discriminators &#x26;&#x26; doc[discriminatorKey] ?
          _this.discriminators[doc[discriminatorKey]] :
          _this;
        var toSave = doc instanceof Model ? doc : new Model(doc);
        var callbackWrapper = function(error, doc) {
          if (error) {
            return callback(error);
          }
          callback(null, doc);
        };

        // Hack to avoid getting a promise because of
        // $__registerHooksFromSchema
        if (toSave.$__original_save) {
          toSave.$__original_save({ __noPromise: true }, callbackWrapper);
        } else {
          toSave.save({ __noPromise: true }, callbackWrapper);
        }
      });
    });

    parallel(toExecute, function(error, savedDocs) {
      if (error) {
        if (cb) {
          cb(error);
        } else {
          reject(error);
        }
        return;
      }

      if (doc instanceof Array) {
        resolve(savedDocs);
        cb &#x26;&#x26; cb.call(_this, null, savedDocs);
      } else {
        resolve.apply(promise, savedDocs);
        if (cb) {
          savedDocs.unshift(null);
          cb.apply(_this, savedDocs);
        }
      }
    });
  });

  return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }
}

/*!
 * Inherit from the NodeJS document
 */

Document.prototype = Object.<span class="apidocCodeKeywordSpan">create</span>(NodeJSDocument.prototype);
Document.prototype.constructor = Document;

/*!
 * Browser doc exposes the event emitter API
 */

Document.$emitter = new EventEmitter();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.deleteMany" id="apidoc.element.mongoose.model.deleteMany">
        function <span class="apidocSignatureSpan">mongoose.model.</span>deleteMany
        <span class="apidocSignatureSpan">(conditions, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteMany(conditions, callback) {
  if (typeof conditions === &#x27;function&#x27;) {
    callback = conditions;
    conditions = {};
  }

  // get the mongodb collection object
  var mq = new this.Query(conditions, {}, this, this.collection);

  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  return mq.deleteMany(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Deletes the first document that matches `conditions` from the collection.
* Behaves like `remove()`, but deletes all documents that match `conditions`
* regardless of the `justOne` option.
*
* ####Example:
*
*     Character.<span class="apidocCodeKeywordSpan">deleteMany</span>({ name: /Stark/, age: { $gte: 18 } }, function (err) {});
*
* ####Note:
*
* Like `Model.remove()`, this function does **not** trigger `pre(&#x27;remove&#x27;)` or `post(&#x27;remove&#x27;)` hooks.
*
* @param {Object} conditions
* @param {Function} [callback]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.deleteOne" id="apidoc.element.mongoose.model.deleteOne">
        function <span class="apidocSignatureSpan">mongoose.model.</span>deleteOne
        <span class="apidocSignatureSpan">(conditions, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deleteOne(conditions, callback) {
  if (typeof conditions === &#x27;function&#x27;) {
    callback = conditions;
    conditions = {};
  }

  // get the mongodb collection object
  var mq = new this.Query(conditions, {}, this, this.collection);

  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  return mq.deleteOne(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Deletes the first document that matches `conditions` from the collection.
* Behaves like `remove()`, but deletes at most one document regardless of the
* `justOne` option.
*
* ####Example:
*
*     Character.<span class="apidocCodeKeywordSpan">deleteOne</span>({ name: &#x27;Eddard Stark&#x27; }, function (err) {});
*
* ####Note:
*
* Like `Model.remove()`, this function does **not** trigger `pre(&#x27;remove&#x27;)` or `post(&#x27;remove&#x27;)` hooks.
*
* @param {Object} conditions
* @param {Function} [callback]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.discriminator" id="apidoc.element.mongoose.model.discriminator">
        function <span class="apidocSignatureSpan">mongoose.model.</span>discriminator
        <span class="apidocSignatureSpan">(name, schema)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">discriminator = function (name, schema) {
  if (typeof name === &#x27;function&#x27;) {
    name = utils.getFunctionName(name);
  }

  schema = discriminator(this, name, schema);
  if (this.db.models[name]) {
    throw new OverwriteModelError(name);
  }

  schema.$isRootDiscriminator = true;

  this.discriminators[name] = this.db.model(name, schema, this.collection.name);
  var d = this.discriminators[name];
  d.prototype.__proto__ = this.prototype;
  Object.defineProperty(d, &#x27;baseModelName&#x27;, {
    value: this.modelName,
    configurable: true,
    writable: false
  });

  // apply methods and statics
  applyMethods(d, schema);
  applyStatics(d, schema);

  return d;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 *     }
 *     util.inherits(BaseSchema, Schema);
 *
 *     var PersonSchema = new BaseSchema();
 *     var BossSchema = new BaseSchema({ department: String });
 *
 *     var Person = mongoose.model(&#x27;Person&#x27;, PersonSchema);
 *     var Boss = Person.<span class="apidocCodeKeywordSpan">discriminator</span>(&#x27;Boss&#x27;, BossSchema);
 *
 * @param {String} name   discriminator model name
 * @param {Schema} schema discriminator model schema
 * @api public
 */

Model.discriminator = function(name, schema) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.distinct" id="apidoc.element.mongoose.model.distinct">
        function <span class="apidocSignatureSpan">mongoose.model.</span>distinct
        <span class="apidocSignatureSpan">(field, conditions, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function distinct(field, conditions, callback) {
  // get the mongodb collection object
  var mq = new this.Query({}, {}, this, this.collection);

  if (typeof conditions === &#x27;function&#x27;) {
    callback = conditions;
    conditions = {};
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  return mq.distinct(field, conditions, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Creates a Query for a `distinct` operation.
*
* Passing a `callback` immediately executes the query.
*
* ####Example
*
*     Link.<span class="apidocCodeKeywordSpan">distinct</span>(&#x27;url&#x27;, { clicks: {$gt: 100}}, function (err, result) {
*       if (err) return handleError(err);
*
*       assert(Array.isArray(result));
*       console.log(&#x27;unique urls with more than 100 clicks&#x27;, result);
*     })
*
*     var query = Link.distinct(&#x27;url&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.emit" id="apidoc.element.mongoose.model.emit">
        function <span class="apidocSignatureSpan">mongoose.model.</span>emit
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function emit(type) {
  var er, handler, len, args, i, events, domain;
  var needDomainExit = false;
  var doError = (type === &#x27;error&#x27;);

  events = this._events;
  if (events)
    doError = (doError &#x26;&#x26; events.error == null);
  else if (!doError)
    return false;

  domain = this.domain;

  // If there is no &#x27;error&#x27; event listener then throw.
  if (doError) {
    er = arguments[1];
    if (domain) {
      if (!er)
        er = new Error(&#x27;Uncaught, unspecified &#x22;error&#x22; event&#x27;);
      er.domainEmitter = this;
      er.domain = domain;
      er.domainThrown = false;
      domain.emit(&#x27;error&#x27;, er);
    } else if (er instanceof Error) {
      throw er; // Unhandled &#x27;error&#x27; event
    } else {
      // At least give some kind of context to the user
      var err = new Error(&#x27;Uncaught, unspecified &#x22;error&#x22; event. (&#x27; + er + &#x27;)&#x27;);
      err.context = er;
      throw err;
    }
    return false;
  }

  handler = events[type];

  if (!handler)
    return false;

  if (domain &#x26;&#x26; this !== process) {
    domain.enter();
    needDomainExit = true;
  }

  var isFn = typeof handler === &#x27;function&#x27;;
  len = arguments.length;
  switch (len) {
    // fast cases
    case 1:
      emitNone(handler, isFn, this);
      break;
    case 2:
      emitOne(handler, isFn, this, arguments[1]);
      break;
    case 3:
      emitTwo(handler, isFn, this, arguments[1], arguments[2]);
      break;
    case 4:
      emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
      break;
    // slower
    default:
      args = new Array(len - 1);
      for (i = 1; i &#x3c; len; i++)
        args[i - 1] = arguments[i];
      emitMany(handler, isFn, this, args);
  }

  if (needDomainExit)
    domain.exit();

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
You can intercept method arguments via middleware.

For example, this would allow you to broadcast changes about your Documents every time someone `set`s a path in your Document to
 a new value:

```js
schema.pre(&#x27;set&#x27;, function (next, path, val, typel) {
  // `this` is the current Document
  this.<span class="apidocCodeKeywordSpan">emit</span>(&#x27;set&#x27;, path, val);

  // Pass control to the next pre
  next();
});
```

Moreover, you can mutate the incoming `method` arguments so that subsequent middleware see different values for those arguments.
To do so, just pass the new values to `next`:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.ensureIndexes" id="apidoc.element.mongoose.model.ensureIndexes">
        function <span class="apidocSignatureSpan">mongoose.model.</span>ensureIndexes
        <span class="apidocSignatureSpan">(options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ensureIndexes(options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = null;
  }

  if (options &#x26;&#x26; options.__noPromise) {
    _ensureIndexes(this, options, callback);
    return;
  }

  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  var _this = this;
  var Promise = PromiseProvider.get();
  return new Promise.ES6(function(resolve, reject) {
    _ensureIndexes(_this, options || {}, function(error) {
      if (error) {
        callback &#x26;&#x26; callback(error);
        reject(error);
      }
      callback &#x26;&#x26; callback();
      resolve();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @api private
*/

Model.init = function init() {
 if ((this.schema.options.autoIndex) ||
     (this.schema.options.autoIndex === null &#x26;&#x26; this.db.config.autoIndex)) {
   this.<span class="apidocCodeKeywordSpan">ensureIndexes</span>({ __noPromise: true, _automatic: true });
 }

 this.schema.emit(&#x27;init&#x27;, this);
};

/**
* Sends `ensureIndex` commands to mongo for each index declared in the schema.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.eventNames" id="apidoc.element.mongoose.model.eventNames">
        function <span class="apidocSignatureSpan">mongoose.model.</span>eventNames
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function eventNames() {
  return this._eventsCount &#x3e; 0 ? Reflect.ownKeys(this._events) : [];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.find" id="apidoc.element.mongoose.model.find">
        function <span class="apidocSignatureSpan">mongoose.model.</span>find
        <span class="apidocSignatureSpan">(conditions, projection, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function find(conditions, projection, options, callback) {
  if (typeof conditions === &#x27;function&#x27;) {
    callback = conditions;
    conditions = {};
    projection = null;
    options = null;
  } else if (typeof projection === &#x27;function&#x27;) {
    callback = projection;
    projection = null;
    options = null;
  } else if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = null;
  }

  var mq = new this.Query({}, {}, this, this.collection);
  mq.select(projection);
  mq.setOptions(options);
  if (this.schema.discriminatorMapping &#x26;&#x26; mq.selectedInclusively()) {
    mq.select(this.schema.options.discriminatorKey);
  }

  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  return mq.find(conditions, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  //
});
```

Or we can find documents from the same collection

```js
MyModel.<span class="apidocCodeKeywordSpan">find</span>({}, function (err, docs) {
  // docs.forEach
});
```

You can also `findOne`, `findById`, `update`, etc. For more details check out [the docs](http://mongoosejs.com/docs/queries.html
).

**Important!** If you opened a separate connection using `mongoose.createConnection()` but attempt to access the model through `
mongoose.model(&#x27;ModelName&#x27;)` it will not work as expected since it is not hooked up to an active db connection. In this
 case access your model through the connection you created:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.findById" id="apidoc.element.mongoose.model.findById">
        function <span class="apidocSignatureSpan">mongoose.model.</span>findById
        <span class="apidocSignatureSpan">(id, projection, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findById(id, projection, options, callback) {
  if (typeof id === &#x27;undefined&#x27;) {
    id = null;
  }

  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  return this.findOne({_id: id}, projection, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!err) console.log(&#x27;Success!&#x27;);
});
```

The same goes for removing them:

```js
BlogPost.<span class="apidocCodeKeywordSpan">findById</span>(myId, function (err, post) {
  if (!err) {
    post.comments[0].remove();
    post.save(function (err) {
      // do something
    });
  }
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.findByIdAndRemove" id="apidoc.element.mongoose.model.findByIdAndRemove">
        function <span class="apidocSignatureSpan">mongoose.model.</span>findByIdAndRemove
        <span class="apidocSignatureSpan">(id, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findByIdAndRemove = function (id, options, callback) {
  if (arguments.length === 1 &#x26;&#x26; typeof id === &#x27;function&#x27;) {
    var msg = &#x27;Model.findByIdAndRemove(): First argument must not be a function.\n\n&#x27;
        + &#x27;  &#x27; + this.modelName + &#x27;.findByIdAndRemove(id, callback)\n&#x27;
        + &#x27;  &#x27; + this.modelName + &#x27;.findByIdAndRemove(id)\n&#x27;
        + &#x27;  &#x27; + this.modelName + &#x27;.findByIdAndRemove()\n&#x27;;
    throw new TypeError(msg);
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  return this.findOneAndRemove({_id: id}, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* ####Options:
*
* - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
* - `select`: sets the document fields to return
*
* ####Examples:
*
*     A.<span class="apidocCodeKeywordSpan">findByIdAndRemove</span>(id, options, callback) // executes
*     A.findByIdAndRemove(id, options)  // return Query
*     A.findByIdAndRemove(id, callback) // executes
*     A.findByIdAndRemove(id) // returns Query
*     A.findByIdAndRemove()           // returns Query
*
* @param {Object|Number|String} id value of `_id` to query by
* @param {Object} [options]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.findByIdAndUpdate" id="apidoc.element.mongoose.model.findByIdAndUpdate">
        function <span class="apidocSignatureSpan">mongoose.model.</span>findByIdAndUpdate
        <span class="apidocSignatureSpan">(id, update, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findByIdAndUpdate = function (id, update, options, callback) {
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  if (arguments.length === 1) {
    if (typeof id === &#x27;function&#x27;) {
      var msg = &#x27;Model.findByIdAndUpdate(): First argument must not be a function.\n\n&#x27;
          + &#x27;  &#x27; + this.modelName + &#x27;.findByIdAndUpdate(id, callback)\n&#x27;
          + &#x27;  &#x27; + this.modelName + &#x27;.findByIdAndUpdate(id)\n&#x27;
          + &#x27;  &#x27; + this.modelName + &#x27;.findByIdAndUpdate()\n&#x27;;
      throw new TypeError(msg);
    }
    return this.findOneAndUpdate({_id: id}, undefined);
  }

  // if a model is passed in instead of an id
  if (id instanceof Document) {
    id = id._id;
  }

  return this.findOneAndUpdate.call(this, {_id: id}, update, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators
 validate the update operation against the model&#x27;s schema.
* - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults
.html) specified in the model&#x27;s schema if a new document is created. This option only works on MongoDB &#x3e;= 2.4 because
it relies on [MongoDB&#x27;s `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).
* - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
* - `select`: sets the document fields to return
*
* ####Examples:
*
*     A.<span class="apidocCodeKeywordSpan">findByIdAndUpdate</span>(id, update, options, callback) // executes
*     A.findByIdAndUpdate(id, update, options)  // returns Query
*     A.findByIdAndUpdate(id, update, callback) // executes
*     A.findByIdAndUpdate(id, update)           // returns Query
*     A.findByIdAndUpdate()                     // returns Query
*
* ####Note:
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.findOne" id="apidoc.element.mongoose.model.findOne">
        function <span class="apidocSignatureSpan">mongoose.model.</span>findOne
        <span class="apidocSignatureSpan">(conditions, projection, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function findOne(conditions, projection, options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = null;
  } else if (typeof projection === &#x27;function&#x27;) {
    callback = projection;
    projection = null;
    options = null;
  } else if (typeof conditions === &#x27;function&#x27;) {
    callback = conditions;
    conditions = {};
    projection = null;
    options = null;
  }

  // get the mongodb collection object
  var mq = new this.Query({}, {}, this, this.collection);
  mq.select(projection);
  mq.setOptions(options);
  if (this.schema.discriminatorMapping &#x26;&#x26; mq.selectedInclusively()) {
    mq.select(this.schema.options.discriminatorKey);
  }

  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  return mq.findOne(conditions, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Checks if `path` was selected in the source query which initialized this document.
*
* ####Example
*
*     Thing.<span class="apidocCodeKeywordSpan">findOne</span>().select(&#x27;name&#x27;).exec(function (err, doc) {
*        doc.isSelected(&#x27;name&#x27;) // true
*        doc.isSelected(&#x27;age&#x27;)  // false
*     })
*
* @param {String} path
* @return {Boolean}
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.findOneAndRemove" id="apidoc.element.mongoose.model.findOneAndRemove">
        function <span class="apidocSignatureSpan">mongoose.model.</span>findOneAndRemove
        <span class="apidocSignatureSpan">(conditions, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findOneAndRemove = function (conditions, options, callback) {
  if (arguments.length === 1 &#x26;&#x26; typeof conditions === &#x27;function&#x27;) {
    var msg = &#x27;Model.findOneAndRemove(): First argument must not be a function.\n\n&#x27;
        + &#x27;  &#x27; + this.modelName + &#x27;.findOneAndRemove(conditions, callback)\n&#x27;
        + &#x27;  &#x27; + this.modelName + &#x27;.findOneAndRemove(conditions)\n&#x27;
        + &#x27;  &#x27; + this.modelName + &#x27;.findOneAndRemove()\n&#x27;;
    throw new TypeError(msg);
  }

  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = undefined;
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  var fields;
  if (options) {
    fields = options.select;
    options.select = undefined;
  }

  var mq = new this.Query({}, {}, this, this.collection);
  mq.select(fields);

  return mq.findOneAndRemove(conditions, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
* - `maxTimeMS`: puts a time limit on the query - requires mongodb &#x3e;= 2.6.0
* - `select`: sets the document fields to return
*
* ####Examples:
*
*     A.<span class="apidocCodeKeywordSpan">findOneAndRemove</span>(conditions, options, callback) // executes
*     A.findOneAndRemove(conditions, options)  // return Query
*     A.findOneAndRemove(conditions, callback) // executes
*     A.findOneAndRemove(conditions) // returns Query
*     A.findOneAndRemove()           // returns Query
*
* Values are cast to their appropriate types when using the findAndModify helpers.
* However, the below are never executed.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.findOneAndUpdate" id="apidoc.element.mongoose.model.findOneAndUpdate">
        function <span class="apidocSignatureSpan">mongoose.model.</span>findOneAndUpdate
        <span class="apidocSignatureSpan">(conditions, update, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findOneAndUpdate = function (conditions, update, options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = null;
  } else if (arguments.length === 1) {
    if (typeof conditions === &#x27;function&#x27;) {
      var msg = &#x27;Model.findOneAndUpdate(): First argument must not be a function.\n\n&#x27;
          + &#x27;  &#x27; + this.modelName + &#x27;.findOneAndUpdate(conditions, update, options, callback)\n&#x27;
          + &#x27;  &#x27; + this.modelName + &#x27;.findOneAndUpdate(conditions, update, options)\n&#x27;
          + &#x27;  &#x27; + this.modelName + &#x27;.findOneAndUpdate(conditions, update)\n&#x27;
          + &#x27;  &#x27; + this.modelName + &#x27;.findOneAndUpdate(update)\n&#x27;
          + &#x27;  &#x27; + this.modelName + &#x27;.findOneAndUpdate()\n&#x27;;
      throw new TypeError(msg);
    }
    update = conditions;
    conditions = undefined;
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  var fields;
  if (options &#x26;&#x26; options.fields) {
    fields = options.fields;
  }

  update = utils.clone(update, {depopulate: 1, _isNested: true});
  if (this.schema.options.versionKey &#x26;&#x26; options &#x26;&#x26; options.upsert) {
    if (!update.$setOnInsert) {
      update.$setOnInsert = {};
    }
    update.$setOnInsert[this.schema.options.versionKey] = 0;
  }

  var mq = new this.Query({}, {}, this, this.collection);
  mq.select(fields);

  return mq.findOneAndUpdate(conditions, update, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if
 any) to the callback. The query executes immediately if `callback` is passed else a Query object is returned.
*
* ####Options:
*
* - `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)
* - `upsert`: bool - creates the object if it doesn&#x27;t exist. defaults to false.
* - `fields`: {Object|String} - Field selection. Equivalent to `.select(fields).<span class="apidocCodeKeywordSpan">findOneAndUpdate
</span>()`
* - `maxTimeMS`: puts a time limit on the query - requires mongodb &#x3e;= 2.6.0
* - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
* - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators
 validate the update operation against the model&#x27;s schema.
* - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults
.html) specified in the model&#x27;s schema if a new document is created. This option only works on MongoDB &#x3e;= 2.4 because
it relies on [MongoDB&#x27;s `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).
* - `passRawResult`: if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github
.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)
*
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.geoNear" id="apidoc.element.mongoose.model.geoNear">
        function <span class="apidocSignatureSpan">mongoose.model.</span>geoNear
        <span class="apidocSignatureSpan">(near, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">geoNear = function (near, options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  }

  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  var _this = this;
  var Promise = PromiseProvider.get();
  if (!near) {
    return new Promise.ES6(function(resolve, reject) {
      var error = new Error(&#x27;Must pass a near option to geoNear&#x27;);
      reject(error);
      callback &#x26;&#x26; callback(error);
    });
  }

  var x, y;

  return new Promise.ES6(function(resolve, reject) {
    var handler = function(err, res) {
      if (err) {
        reject(err);
        callback &#x26;&#x26; callback(err);
        return;
      }
      if (options.lean) {
        resolve(res.results, res.stats);
        callback &#x26;&#x26; callback(null, res.results, res.stats);
        return;
      }

      var count = res.results.length;
      // if there are no results, fulfill the promise now
      if (count === 0) {
        resolve(res.results, res.stats);
        callback &#x26;&#x26; callback(null, res.results, res.stats);
        return;
      }

      var errSeen = false;

      function init(err) {
        if (err &#x26;&#x26; !errSeen) {
          errSeen = true;
          reject(err);
          callback &#x26;&#x26; callback(err);
          return;
        }
        if (--count &#x3c;= 0) {
          resolve(res.results, res.stats);
          callback &#x26;&#x26; callback(null, res.results, res.stats);
        }
      }

      for (var i = 0; i &#x3c; res.results.length; i++) {
        var temp = res.results[i].obj;
        res.results[i].obj = new _this();
        res.results[i].obj.init(temp, init);
      }
    };

    if (Array.isArray(near)) {
      if (near.length !== 2) {
        var error = new Error(&#x27;If using legacy coordinates, must be an array &#x27; +
            &#x27;of size 2 for geoNear&#x27;);
        reject(error);
        callback &#x26;&#x26; callback(error);
        return;
      }
      x = near[0];
      y = near[1];
      _this.collection.geoNear(x, y, options, handler);
    } else {
      if (near.type !== &#x27;Point&#x27; || !Array.isArray(near.coordinates)) {
        error = new Error(&#x27;Must pass either a legacy coordinate array or &#x27; +
            &#x27;GeoJSON Point to geoNear&#x27;);
        reject(error);
        callback &#x26;&#x26; callback(error);
        return;
      }

      _this.collection.geoNear(near, options, handler);
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* ####Options:
* - `lean` {Boolean} return the raw object
* - All options supported by the driver are also supported
*
* ####Example:
*
*     // Legacy point
*     Model.<span class="apidocCodeKeywordSpan">geoNear</span>([1,3], { maxDistance : 5, spherical : true }, function(err, results
, stats) {
*        console.log(results);
*     });
*
*     // geoJson
*     var point = { type : &#x22;Point&#x22;, coordinates : [9,9] };
*     Model.geoNear(point, { maxDistance : 5, spherical : true }, function(err, results, stats) {
*        console.log(results);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.geoSearch" id="apidoc.element.mongoose.model.geoSearch">
        function <span class="apidocSignatureSpan">mongoose.model.</span>geoSearch
        <span class="apidocSignatureSpan">(conditions, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">geoSearch = function (conditions, options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = {};
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  var _this = this;
  var Promise = PromiseProvider.get();
  return new Promise.ES6(function(resolve, reject) {
    var error;
    if (conditions === undefined || !utils.isObject(conditions)) {
      error = new Error(&#x27;Must pass conditions to geoSearch&#x27;);
    } else if (!options.near) {
      error = new Error(&#x27;Must specify the near option in geoSearch&#x27;);
    } else if (!Array.isArray(options.near)) {
      error = new Error(&#x27;near option must be an array [x, y]&#x27;);
    }

    if (error) {
      callback &#x26;&#x26; callback(error);
      reject(error);
      return;
    }

    // send the conditions in the options object
    options.search = conditions;

    _this.collection.geoHaystackSearch(options.near[0], options.near[1], options, function(err, res) {
      // have to deal with driver problem. Should be fixed in a soon-ish release
      // (7/8/2013)
      if (err) {
        callback &#x26;&#x26; callback(err);
        reject(err);
        return;
      }

      var count = res.results.length;
      if (options.lean || count === 0) {
        callback &#x26;&#x26; callback(null, res.results, res.stats);
        resolve(res.results, res.stats);
        return;
      }

      var errSeen = false;

      function init(err) {
        if (err &#x26;&#x26; !errSeen) {
          callback &#x26;&#x26; callback(err);
          reject(err);
          return;
        }

        if (!--count &#x26;&#x26; !errSeen) {
          callback &#x26;&#x26; callback(null, res.results, res.stats);
          resolve(res.results, res.stats);
        }
      }

      for (var i = 0; i &#x3c; res.results.length; i++) {
        var temp = res.results[i];
        res.results[i] = new _this();
        res.results[i].init(temp, {}, init);
      }
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Implements `$geoSearch` functionality for Mongoose
*
* ####Example:
*
*     var options = { near: [10, 10], maxDistance: 5 };
*     Locations.<span class="apidocCodeKeywordSpan">geoSearch</span>({ type : &#x22;house&#x22; }, options, function(err, res) {
*       console.log(res);
*     });
*
* ####Options:
* - `near` {Array} x,y point to search for
* - `maxDistance` {Number} the maximum distance from the point near that a result can be
* - `limit` {Number} The maximum number of results to return
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.getMaxListeners" id="apidoc.element.mongoose.model.getMaxListeners">
        function <span class="apidocSignatureSpan">mongoose.model.</span>getMaxListeners
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getMaxListeners() {
  return $getMaxListeners(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.hydrate" id="apidoc.element.mongoose.model.hydrate">
        function <span class="apidocSignatureSpan">mongoose.model.</span>hydrate
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hydrate = function (obj) {
  var model = require(&#x27;./queryhelpers&#x27;).createModel(this, obj);
  model.init(obj);
  return model;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.
 * The document returned has no paths marked as modified initially.
 *
 * ####Example:
 *
 *     // hydrate previous data into a Mongoose document
 *     var mongooseCandy = Candy.<span class="apidocCodeKeywordSpan">hydrate</span>({ _id: &#x27;54108337212ffb6d459f854c&#x27;,
type: &#x27;jelly bean&#x27; });
 *
 * @param {Object} obj
 * @return {Document}
 * @api public
 */

Model.hydrate = function(obj) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.init" id="apidoc.element.mongoose.model.init">
        function <span class="apidocSignatureSpan">mongoose.model.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function init() {
  if ((this.schema.options.autoIndex) ||
      (this.schema.options.autoIndex === null &#x26;&#x26; this.db.config.autoIndex)) {
    this.ensureIndexes({ __noPromise: true, _automatic: true });
  }

  this.schema.emit(&#x27;init&#x27;, this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.$__.activePaths.require(required[i]);
}

this.$__.emitter.setMaxListeners(0);
this._doc = this.$__buildDoc(obj, fields, skipId);

if (!skipInit &#x26;&#x26; obj) {
  this.<span class="apidocCodeKeywordSpan">init</span>(obj);
}

this.$__registerHooksFromSchema();

// apply methods
for (var m in schema.methods) {
  this[m] = schema.methods[m];
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.insertMany" id="apidoc.element.mongoose.model.insertMany">
        function <span class="apidocSignatureSpan">mongoose.model.</span>insertMany
        <span class="apidocSignatureSpan">(arr, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertMany = function (arr, options, callback) {
  var _this = this;
  if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = null;
  }
  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  if (!Array.isArray(arr)) {
    arr = [arr];
  }

  var toExecute = [];
  arr.forEach(function(doc) {
    toExecute.push(function(callback) {
      doc = new _this(doc);
      doc.validate({ __noPromise: true }, function(error) {
        if (error) {
          // Option `ordered` signals that insert should be continued after reaching
          // a failing insert. Therefore we delegate &#x22;null&#x22;, meaning the validation
          // failed. It&#x27;s up to the next function to filter out all failed models
          if (options != null &#x26;&#x26; typeof options === &#x27;object&#x27; &#x26;&#x26; options[&#x27;ordered&#x27;] === false) {
            return callback(null, null);
          }
          return callback(error);
        }
        callback(null, doc);
      });
    });
  });

  parallel(toExecute, function(error, docs) {
    if (error) {
      callback &#x26;&#x26; callback(error);
      return;
    }
    // We filter all failed pre-validations by removing nulls
    var docAttributes = docs.filter(function(doc) {
      return doc != null;
    });
    // Quickly escape while there aren&#x27;t any valid docAttributes
    if (docAttributes.length &#x3c; 1) {
      callback &#x26;&#x26; callback(null, []);
      return;
    }
    var docObjects = docAttributes.map(function(doc) {
      if (doc.schema.options.versionKey) {
        doc[doc.schema.options.versionKey] = 0;
      }
      if (doc.initializeTimestamps) {
        return doc.initializeTimestamps().toObject(POJO_TO_OBJECT_OPTIONS);
      }
      return doc.toObject(POJO_TO_OBJECT_OPTIONS);
    });
    _this.collection.insertMany(docObjects, options, function(error) {
      if (error) {
        callback &#x26;&#x26; callback(error);
        return;
      }
      for (var i = 0; i &#x3c; docAttributes.length; ++i) {
        docAttributes[i].isNew = false;
        docAttributes[i].emit(&#x27;isNew&#x27;, false);
        docAttributes[i].constructor.emit(&#x27;isNew&#x27;, false);
      }
      callback &#x26;&#x26; callback(null, docAttributes);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* document.
*
* This function does **not** trigger save middleware.
*
* ####Example:
*
*     var arr = [{ name: &#x27;Star Wars&#x27; }, { name: &#x27;The Empire Strikes Back&#x27; }];
*     Movies.<span class="apidocCodeKeywordSpan">insertMany</span>(arr, function(error, docs) {});
*
* @param {Array|Object|*} doc(s)
* @param {Object} [options] see the [mongodb driver options](http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html
#insertMany)
* @param {Function} [callback] callback
* @return {Promise}
* @api public
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.listenerCount" id="apidoc.element.mongoose.model.listenerCount">
        function <span class="apidocSignatureSpan">mongoose.model.</span>listenerCount
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listenerCount(type) {
  const events = this._events;

  if (events) {
    const evlistener = events[type];

    if (typeof evlistener === &#x27;function&#x27;) {
      return 1;
    } else if (evlistener) {
      return evlistener.length;
    }
  }

  return 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.listeners" id="apidoc.element.mongoose.model.listeners">
        function <span class="apidocSignatureSpan">mongoose.model.</span>listeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function listeners(type) {
  var evlistener;
  var ret;
  var events = this._events;

  if (!events)
    ret = [];
  else {
    evlistener = events[type];
    if (!evlistener)
      ret = [];
    else if (typeof evlistener === &#x27;function&#x27;)
      ret = [evlistener];
    else
      ret = arrayClone(evlistener, evlistener.length);
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      doc[pair[0]].apply(doc, pair[1]);
    }
  }
}

Document.prototype.$__handleReject = function handleReject(err) {
  // emit on the Model if listening
  if (this.<span class="apidocCodeKeywordSpan">listeners</span>(&#x27;error&#x27;).length) {
    this.emit(&#x27;error&#x27;, err);
  } else if (this.constructor.listeners &#x26;&#x26; this.constructor.listeners(&#x27;error&#x27;).length) {
    this.constructor.emit(&#x27;error&#x27;, err);
  } else if (this.listeners &#x26;&#x26; this.listeners(&#x27;error&#x27;).length) {
    this.emit(&#x27;error&#x27;, err);
  }
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.mapReduce" id="apidoc.element.mongoose.model.mapReduce">
        function <span class="apidocSignatureSpan">mongoose.model.</span>mapReduce
        <span class="apidocSignatureSpan">(o, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function mapReduce(o, callback) {
  var _this = this;
  if (callback) {
    callback = this.$wrapCallback(callback);
  }
  var Promise = PromiseProvider.get();
  return new Promise.ES6(function(resolve, reject) {
    if (!Model.mapReduce.schema) {
      var opts = {noId: true, noVirtualId: true, strict: false};
      Model.mapReduce.schema = new Schema({}, opts);
    }

    if (!o.out) o.out = {inline: 1};
    if (o.verbose !== false) o.verbose = true;

    o.map = String(o.map);
    o.reduce = String(o.reduce);

    if (o.query) {
      var q = new _this.Query(o.query);
      q.cast(_this);
      o.query = q._conditions;
      q = undefined;
    }

    _this.collection.mapReduce(null, null, o, function(err, ret, stats) {
      if (err) {
        callback &#x26;&#x26; callback(err);
        reject(err);
        return;
      }

      if (ret.findOne &#x26;&#x26; ret.mapReduce) {
        // returned a collection, convert to Model
        var model = Model.compile(
            &#x27;_mapreduce_&#x27; + ret.collectionName
            , Model.mapReduce.schema
            , ret.collectionName
            , _this.db
            , _this.base);

        model._mapreduce = true;

        callback &#x26;&#x26; callback(null, model, stats);
        return resolve(model, stats);
      }

      callback &#x26;&#x26; callback(null, ret, stats);
      resolve(ret, stats);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* `o` is an object specifying all mapReduce options as well as the map and reduce functions. All options are delegated to the driver
 implementation. See [node-mongodb-native mapReduce() documentation](http://mongodb.github.io/node-mongodb-native/api-generated/
collection.html#mapreduce) for more detail about options.
*
* ####Example:
*
*     var o = {};
*     o.map = function () { emit(this.name, 1) }
*     o.reduce = function (k, vals) { return vals.length }
*     User.<span class="apidocCodeKeywordSpan">mapReduce</span>(o, function (err, results) {
*       console.log(results)
*     })
*
* ####Other options:
*
* - `query` {Object} query filter object.
* - `sort` {Object} sort input objects using this key
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.on" id="apidoc.element.mongoose.model.on">
        function <span class="apidocSignatureSpan">mongoose.model.</span>on
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addListener(type, listener) {
  return _addListener(this, type, listener, false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * - 2 = connecting
 * - 3 = disconnecting
 *
 * Each state change emits its associated event name.
 *
 * ####Example
 *
 *     conn.<span class="apidocCodeKeywordSpan">on</span>(&#x27;connected&#x27;, callback);
 *     conn.on(&#x27;disconnected&#x27;, callback);
 *
 * @property readyState
 * @api public
 */

Object.defineProperty(Connection.prototype, &#x27;readyState&#x27;, {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.once" id="apidoc.element.mongoose.model.once">
        function <span class="apidocSignatureSpan">mongoose.model.</span>once
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function once(type, listener) {
  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);
  this.on(type, _onceWrap(this, type, listener));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        aggregate(_this._pipeline, options || {});
      decorateCursor(cursor);
      resolve(cursor);
      callback &#x26;&#x26; callback(null, cursor);
    });
    return;
  }
  _this._model.collection.emitter.<span class="apidocCodeKeywordSpan">once</span>(&#x27;queue&#x27;, function() {
    var cursor = _this._model.collection.
      aggregate(_this._pipeline, options || {});
    decorateCursor(cursor);
    resolve(cursor);
    callback &#x26;&#x26; callback(null, cursor);
  });
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.populate" id="apidoc.element.mongoose.model.populate">
        function <span class="apidocSignatureSpan">mongoose.model.</span>populate
        <span class="apidocSignatureSpan">(docs, paths, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">populate = function (docs, paths, callback) {
  var _this = this;
  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  // normalized paths
  var noPromise = paths &#x26;&#x26; !!paths.__noPromise;
  paths = utils.populate(paths);

  // data that should persist across subPopulate calls
  var cache = {};

  if (noPromise) {
    _populate(this, docs, paths, cache, callback);
  } else {
    var Promise = PromiseProvider.get();
    return new Promise.ES6(function(resolve, reject) {
      _populate(_this, docs, paths, cache, function(error, docs) {
        if (error) {
          callback &#x26;&#x26; callback(error);
          reject(error);
        } else {
          callback &#x26;&#x26; callback(null, docs);
          resolve(docs);
        }
      });
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Populates document references, executing the `callback` when complete.
* If you want to use promises instead, use this function with
* [`execPopulate()`](#document_Document-execPopulate)
*
* ####Example:
*
*     doc
*     .<span class="apidocCodeKeywordSpan">populate</span>(&#x27;company&#x27;)
*     .populate({
*       path: &#x27;notes&#x27;,
*       match: /airline/,
*       select: &#x27;text&#x27;,
*       model: &#x27;modelName&#x27;
*       options: opts
*     }, function (err, user) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.prependListener" id="apidoc.element.mongoose.model.prependListener">
        function <span class="apidocSignatureSpan">mongoose.model.</span>prependListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.prependOnceListener" id="apidoc.element.mongoose.model.prependOnceListener">
        function <span class="apidocSignatureSpan">mongoose.model.</span>prependOnceListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function prependOnceListener(type, listener) {
  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.remove" id="apidoc.element.mongoose.model.remove">
        function <span class="apidocSignatureSpan">mongoose.model.</span>remove
        <span class="apidocSignatureSpan">(conditions, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function remove(conditions, callback) {
  if (typeof conditions === &#x27;function&#x27;) {
    callback = conditions;
    conditions = {};
  }

  // get the mongodb collection object
  var mq = new this.Query(conditions, {}, this, this.collection);

  if (callback) {
    callback = this.$wrapCallback(callback);
  }

  return mq.remove(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

The same goes for removing them:

```js
BlogPost.findById(myId, function (err, post) {
  if (!err) {
    post.comments[0].<span class="apidocCodeKeywordSpan">remove</span>();
    post.save(function (err) {
      // do something
    });
  }
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.removeAllListeners" id="apidoc.element.mongoose.model.removeAllListeners">
        function <span class="apidocSignatureSpan">mongoose.model.</span>removeAllListeners
        <span class="apidocSignatureSpan">(type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeAllListeners(type) {
  var listeners, events;

  events = this._events;
  if (!events)
    return this;

  // not listening for removeListener, no need to emit
  if (!events.removeListener) {
    if (arguments.length === 0) {
      this._events = new EventHandlers();
      this._eventsCount = 0;
    } else if (events[type]) {
      if (--this._eventsCount === 0)
        this._events = new EventHandlers();
      else
        delete events[type];
    }
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    var keys = Object.keys(events);
    for (var i = 0, key; i &#x3c; keys.length; ++i) {
      key = keys[i];
      if (key === &#x27;removeListener&#x27;) continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners(&#x27;removeListener&#x27;);
    this._events = new EventHandlers();
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === &#x27;function&#x27;) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    do {
      this.removeListener(type, listeners[listeners.length - 1]);
    } while (listeners[0]);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.removeListener" id="apidoc.element.mongoose.model.removeListener">
        function <span class="apidocSignatureSpan">mongoose.model.</span>removeListener
        <span class="apidocSignatureSpan">(type, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  if (typeof listener !== &#x27;function&#x27;)
    throw new TypeError(&#x27;&#x22;listener&#x22; argument must be a function&#x27;);

  events = this._events;
  if (!events)
    return this;

  list = events[type];
  if (!list)
    return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0)
      this._events = new EventHandlers();
    else {
      delete events[type];
      if (events.removeListener)
        this.emit(&#x27;removeListener&#x27;, type, list.listener || listener);
    }
  } else if (typeof list !== &#x27;function&#x27;) {
    position = -1;

    for (i = list.length; i-- &#x3e; 0;) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position &#x3c; 0)
      return this;

    if (list.length === 1) {
      list[0] = undefined;
      if (--this._eventsCount === 0) {
        this._events = new EventHandlers();
        return this;
      } else {
        delete events[type];
      }
    } else {
      spliceOne(list, position);
    }

    if (events.removeListener)
      this.emit(&#x27;removeListener&#x27;, type, originalListener || listener);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.replaceOne" id="apidoc.element.mongoose.model.replaceOne">
        function <span class="apidocSignatureSpan">mongoose.model.</span>replaceOne
        <span class="apidocSignatureSpan">(conditions, doc, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function replaceOne(conditions, doc, options, callback) {
  return _update(this, &#x27;replaceOne&#x27;, conditions, doc, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Query.base.updateOne.call(this, castedQuery, castedDoc, options, callback);
return this;
};

/*!
 * Internal thunk for .<span class="apidocCodeKeywordSpan">replaceOne</span>()
 *
 * @param {Function} callback
 * @see Model.replaceOne #model_Model.replaceOne
 * @api private
 */
Query.prototype._replaceOne = function(callback) {
var schema = this.model.schema;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.setMaxListeners" id="apidoc.element.mongoose.model.setMaxListeners">
        function <span class="apidocSignatureSpan">mongoose.model.</span>setMaxListeners
        <span class="apidocSignatureSpan">(n)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setMaxListeners(n) {
  if (typeof n !== &#x27;number&#x27; || n &#x3c; 0 || isNaN(n))
    throw new TypeError(&#x27;&#x22;n&#x22; argument must be a positive number&#x27;);
  this._maxListeners = n;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

var required = this.schema.requiredPaths();
for (var i = 0; i &#x3c; required.length; ++i) {
  this.$__.activePaths.require(required[i]);
}

this.$__.emitter.<span class="apidocCodeKeywordSpan">setMaxListeners</span>(0);
this._doc = this.$__buildDoc(obj, fields, skipId);

if (!skipInit &#x26;&#x26; obj) {
  this.init(obj);
}

this.$__registerHooksFromSchema();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.update" id="apidoc.element.mongoose.model.update">
        function <span class="apidocSignatureSpan">mongoose.model.</span>update
        <span class="apidocSignatureSpan">(conditions, doc, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function update(conditions, doc, options, callback) {
  return _update(this, &#x27;update&#x27;, conditions, doc, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

/**
* Sends an update command with this document `_id` as the query selector.
*
* ####Example:
*
*     weirdCar.<span class="apidocCodeKeywordSpan">update</span>({$inc: {wheels:1}}, { w: 1 }, callback);
*
* ####Valid options:
*
*  - same as in [Model.update](#model_Model.update)
*
* @see Model.update #model_Model.update
* @param {Object} doc
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.updateMany" id="apidoc.element.mongoose.model.updateMany">
        function <span class="apidocSignatureSpan">mongoose.model.</span>updateMany
        <span class="apidocSignatureSpan">(conditions, doc, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateMany(conditions, doc, options, callback) {
  return _update(this, &#x27;updateMany&#x27;, conditions, doc, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Query.base.update.call(this, castedQuery, castedDoc, options, callback);
return this;
};

/*!
 * Internal thunk for .<span class="apidocCodeKeywordSpan">updateMany</span>()
 *
 * @param {Function} callback
 * @see Model.update #model_Model.update
 * @api private
 */
Query.prototype._updateMany = function(callback) {
var schema = this.model.schema;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.updateOne" id="apidoc.element.mongoose.model.updateOne">
        function <span class="apidocSignatureSpan">mongoose.model.</span>updateOne
        <span class="apidocSignatureSpan">(conditions, doc, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function updateOne(conditions, doc, options, callback) {
  return _update(this, &#x27;updateOne&#x27;, conditions, doc, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Query.base.updateMany.call(this, castedQuery, castedDoc, options, callback);
return this;
};

/*!
 * Internal thunk for .<span class="apidocCodeKeywordSpan">updateOne</span>()
 *
 * @param {Function} callback
 * @see Model.update #model_Model.update
 * @api private
 */
Query.prototype._updateOne = function(callback) {
var schema = this.model.schema;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.where" id="apidoc.element.mongoose.model.where">
        function <span class="apidocSignatureSpan">mongoose.model.</span>where
        <span class="apidocSignatureSpan">(path, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function where(path, val) {
  void val; // eslint
  // get the mongodb collection object
  var mq = new this.Query({}, {}, this, this.collection).find({});
  return mq.where.apply(mq, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* For example, instead of writing:
*
*     User.find({age: {$gte: 21, $lte: 65}}, callback);
*
* we can instead write:
*
*     User.<span class="apidocCodeKeywordSpan">where</span>(&#x27;age&#x27;).gte(21).lte(65).exec(callback);
*
* Since the Query class also supports `where` you can continue chaining
*
*     User
*     .where(&#x27;age&#x27;).gte(21).lte(65)
*     .where(&#x27;name&#x27;, /^b/i)
*     ... etc
...</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.model.prototype" id="apidoc.module.mongoose.model.prototype">module mongoose.model.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.model.prototype.increment" id="apidoc.element.mongoose.model.prototype.increment">
        function <span class="apidocSignatureSpan">mongoose.model.prototype.</span>increment
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function increment() {
  this.$__.version = VERSION_ALL;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// only increment the version if an array position changes.
// modifying elements of an array is ok if position does not change.

if (op === &#x27;$push&#x27; || op === &#x27;$pushAll&#x27; || op === &#x27;$addToSet&#x27;) {
  self.$__.version = VERSION_INC;
} else if (/^\$p/.test(op)) {
  // potentially changing array positions
  self.<span class="apidocCodeKeywordSpan">increment</span>();
} else if (Array.isArray(val)) {
  // $set an array
  self.increment();
} else if (/\.\d+\.|\.\d+$/.test(data.path)) {
  // now handling $set, $unset
  // subpath of array
  self.$__.version = VERSION_WHERE;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.prototype.model" id="apidoc.element.mongoose.model.prototype.model">
        function <span class="apidocSignatureSpan">mongoose.model.prototype.</span>model
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function model(name) {
  return this.db.model(name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
});
```

Take a look at the example in `examples/schema.js` for an end-to-end example of a typical setup.

### Accessing a Model

Once we define a model through `mongoose.<span class="apidocCodeKeywordSpan">model</span>(&#x27;ModelName&#x27;, mySchema)`, we
can access it through the same function

```js
var myModel = mongoose.model(&#x27;ModelName&#x27;);
```

Or just do it all at once
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.prototype.remove" id="apidoc.element.mongoose.model.prototype.remove">
        function <span class="apidocSignatureSpan">mongoose.model.prototype.</span>remove
        <span class="apidocSignatureSpan">(options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function remove(options, fn) {
  if (typeof options === &#x27;function&#x27;) {
    fn = options;
    options = undefined;
  }

  if (!options) {
    options = {};
  }

  if (this.$__.removing) {
    if (fn) {
      this.$__.removing.then(
          function(res) { fn(null, res); },
          function(err) { fn(err); });
    }
    return this;
  }

  var _this = this;
  var Promise = PromiseProvider.get();

  if (fn) {
    fn = this.constructor.$wrapCallback(fn);
  }

  this.$__.removing = new Promise.ES6(function(resolve, reject) {
    var where = _this.$__where();
    if (where instanceof Error) {
      reject(where);
      fn &#x26;&#x26; fn(where);
      return;
    }

    if (!options.safe &#x26;&#x26; _this.schema.options.safe) {
      options.safe = _this.schema.options.safe;
    }

    _this.collection.remove(where, options, function(err) {
      if (!err) {
        _this.emit(&#x27;remove&#x27;, _this);
        _this.constructor.emit(&#x27;remove&#x27;, _this);
        resolve(_this);
        fn &#x26;&#x26; fn(null, _this);
        return;
      }
      reject(err);
      fn &#x26;&#x26; fn(err);
    });
  });
  return this.$__.removing;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

The same goes for removing them:

```js
BlogPost.findById(myId, function (err, post) {
  if (!err) {
    post.comments[0].<span class="apidocCodeKeywordSpan">remove</span>();
    post.save(function (err) {
      // do something
    });
  }
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.model.prototype.save" id="apidoc.element.mongoose.model.prototype.save">
        function <span class="apidocSignatureSpan">mongoose.model.prototype.</span>save
        <span class="apidocSignatureSpan">(options, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">save = function (options, fn) {
  if (typeof options === &#x27;function&#x27;) {
    fn = options;
    options = undefined;
  }

  if (!options) {
    options = {};
  }

  if (fn) {
    fn = this.constructor.$wrapCallback(fn);
  }

  return this.$__save(options, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Then Mongoose will create the model for your __tickets__ collection, not your __ticket__ collection.

Once we have our model, we can then instantiate it, and save it:

```js
var instance = new MyModel();
instance.my.key = &#x27;hello&#x27;;
instance.<span class="apidocCodeKeywordSpan">save</span>(function (err) {
  //
});
```

Or we can find documents from the same collection

```js
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.promise" id="apidoc.module.mongoose.promise">module mongoose.promise</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.promise.promise" id="apidoc.element.mongoose.promise.promise">
        function <span class="apidocSignatureSpan">mongoose.</span>promise
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise(fn) {
  MPromise.call(this, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.promise.ES6" id="apidoc.element.mongoose.promise.ES6">
        function <span class="apidocSignatureSpan">mongoose.promise.</span>ES6
        <span class="apidocSignatureSpan">(resolver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ES6 = function (resolver) {
  var promise = new Promise();

  // No try/catch for backwards compatibility
  resolver(
    function() {
      promise.complete.apply(promise, arguments);
    },
    function(e) {
      promise.error(e);
    });

  return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @param {Function} callback
 * @return {Promise}
 */

Aggregate.prototype.explain = function(callback) {
var _this = this;
var Promise = PromiseProvider.get();
return new Promise.<span class="apidocCodeKeywordSpan">ES6</span>(function(resolve, reject) {
  if (!_this._pipeline.length) {
    var err = new Error(&#x27;Aggregate has empty pipeline&#x27;);
    if (callback) {
      callback(err);
    }
    reject(err);
    return;
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.promise.prototype" id="apidoc.module.mongoose.promise.prototype">module mongoose.promise.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.promise.prototype.addBack" id="apidoc.element.mongoose.promise.prototype.addBack">
        function <span class="apidocSignatureSpan">mongoose.promise.prototype.</span>addBack
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBack = function (fn) {
  if (!fn) return this;
  if (&#x27;function&#x27; != typeof fn) throw new TypeError(&#x22;fn should be a function&#x22;);
  this.on(Promise.FAILURE, function (err) { fn.call(this, err); });
  this.on(Promise.SUCCESS, function () { fn.apply(this, strongUnshift(null, arguments)); });
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     // executing a query explicitly
*     var query = MyModel.find({ name: /john/i }, null, { skip: 10 })
*     query.exec(function (err, docs) {});
*
*     // using the promise returned from executing a query
*     var query = MyModel.find({ name: /john/i }, null, { skip: 10 });
*     var promise = query.exec();
*     promise.<span class="apidocCodeKeywordSpan">addBack</span>(function (err, docs) {});
*
* @param {Object} conditions
* @param {Object} [projection] optional fields to return (http://bit.ly/1HotzBo)
* @param {Object} [options] optional
* @param {Function} [callback]
* @return {Query}
* @see field selection #query_Query-select
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.promise.prototype.addCallback" id="apidoc.element.mongoose.promise.prototype.addCallback">
        function <span class="apidocSignatureSpan">mongoose.promise.prototype.</span>addCallback
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addCallback = function (fn) {
  if (!fn) return this;
  if (&#x27;function&#x27; != typeof fn) throw new TypeError(&#x22;fn should be a function&#x22;);
  return this.on(Promise.SUCCESS, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.promise.prototype.addErrback" id="apidoc.element.mongoose.promise.prototype.addErrback">
        function <span class="apidocSignatureSpan">mongoose.promise.prototype.</span>addErrback
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addErrback = function (fn) {
  if (!fn) return this;
  if (&#x27;function&#x27; != typeof fn) throw new TypeError(&#x22;fn should be a function&#x22;);
  return this.on(Promise.FAILURE, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.promise.prototype.catch" id="apidoc.element.mongoose.promise.prototype.catch">
        function <span class="apidocSignatureSpan">mongoose.promise.prototype.</span>catch
        <span class="apidocSignatureSpan">(onReject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catch = function (onReject) {
  return this.then(null, onReject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Promise.prototype.then = util.deprecate(Promise.prototype.then,
 &#x27;Mongoose: mpromise (mongoose\&#x27;s default promise library) is deprecated, &#x27; +
 &#x27;plug in your own promise library instead: &#x27; +
 &#x27;http://mongoosejs.com/docs/promises.html&#x27;);

/**
* ES6-style `.<span class="apidocCodeKeywordSpan">catch</span>()` shorthand
*
* @method catch
* @memberOf Promise
* @param {Function} onReject
* @return {Promise}
* @api public
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.promise.prototype.complete" id="apidoc.element.mongoose.promise.prototype.complete">
        function <span class="apidocSignatureSpan">mongoose.promise.prototype.</span>complete
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">complete = function () {
  return this.safeEmit.apply(this, strongUnshift(Promise.SUCCESS, arguments));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.promise.prototype.error" id="apidoc.element.mongoose.promise.prototype.error">
        function <span class="apidocSignatureSpan">mongoose.promise.prototype.</span>error
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">error = function (err) {
  if (!(err instanceof Error)) {
    if (err instanceof Object) {
      err = util.inspect(err);
    }
    err = new Error(err);
  }
  return this.reject(err);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (!rgxProtocol.test(host)) {
  host = &#x27;mongodb://&#x27; + host;
}

try {
  parsed = muri(host);
} catch (err) {
  this.<span class="apidocCodeKeywordSpan">error</span>(err, callback);
  return new Promise.ES6(function(resolve, reject) {
    reject(err);
  });
}

database = parsed.db;
host = parsed.hosts[0].host || parsed.hosts[0].ipc;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.promise.prototype.resolve" id="apidoc.element.mongoose.promise.prototype.resolve">
        function <span class="apidocSignatureSpan">mongoose.promise.prototype.</span>resolve
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resolve = function (err) {
  if (err) return this.error(err);
  return this.fulfill.apply(this, Array.prototype.slice.call(arguments, 1));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.promise.prototype.then" id="apidoc.element.mongoose.promise.prototype.then">
        function <span class="apidocSignatureSpan">mongoose.promise.prototype.</span>then
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecated() {
  warned = exports.printDeprecationMessage(msg, warned, deprecated);
  if (new.target) {
    return Reflect.construct(fn, arguments, new.target);
  }
  return fn.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* ####Example:
*
*     aggregate.exec(callback);
*
*     // Because a promise is returned, the `callback` is optional.
*     var promise = aggregate.exec();
*     promise.<span class="apidocCodeKeywordSpan">then</span>(..);
*
* @see Promise #promise_Promise
* @param {Function} [callback]
* @return {Promise}
* @api public
*/
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.promise_provider" id="apidoc.module.mongoose.promise_provider">module mongoose.promise_provider</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.promise_provider._promise" id="apidoc.element.mongoose.promise_provider._promise">
        function <span class="apidocSignatureSpan">mongoose.promise_provider.</span>_promise
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Promise(fn) {
  MPromise.call(this, fn);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.promise_provider.get" id="apidoc.element.mongoose.promise_provider.get">
        function <span class="apidocSignatureSpan">mongoose.promise_provider.</span>get
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function () {
  return Promise._promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// a setter
Comment.path(&#x27;name&#x27;).set(function (v) {
  return capitalize(v);
});

// middleware
Comment.pre(&#x27;save&#x27;, function (next) {
  notify(this.<span class="apidocCodeKeywordSpan">get</span>(&#x27;email&#x27;));
  next();
});
```

Take a look at the example in `examples/schema.js` for an end-to-end example of a typical setup.

### Accessing a Model
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.promise_provider.reset" id="apidoc.element.mongoose.promise_provider.reset">
        function <span class="apidocSignatureSpan">mongoose.promise_provider.</span>reset
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">reset = function () {
  Promise._promise = MPromise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * Set the current promise constructor
 *
 * @api private
 */

Promise.set = function(lib) {
  if (lib === MPromise) {
    return Promise.<span class="apidocCodeKeywordSpan">reset</span>();
  }
  Promise._promise = require(&#x27;./ES6Promise&#x27;);
  Promise._promise.use(lib);
  require(&#x27;mquery&#x27;).Promise = Promise._promise.ES6;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.promise_provider.set" id="apidoc.element.mongoose.promise_provider.set">
        function <span class="apidocSignatureSpan">mongoose.promise_provider.</span>set
        <span class="apidocSignatureSpan">(lib)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (lib) {
  if (lib === MPromise) {
    return Promise.reset();
  }
  Promise._promise = require(&#x27;./ES6Promise&#x27;);
  Promise._promise.use(lib);
  require(&#x27;mquery&#x27;).Promise = Promise._promise.ES6;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
age: { type: Number, min: 18, index: true },
bio: { type: String, match: /[a-z]/ },
date: { type: Date, default: Date.now },
buff: Buffer
});

// a setter
Comment.path(&#x27;name&#x27;).<span class="apidocCodeKeywordSpan">set</span>(function (v) {
return capitalize(v);
});

// middleware
Comment.pre(&#x27;save&#x27;, function (next) {
notify(this.get(&#x27;email&#x27;));
next();
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.query" id="apidoc.module.mongoose.query">module mongoose.query</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.query.query" id="apidoc.element.mongoose.query.query">
        function <span class="apidocSignatureSpan">mongoose.</span>query
        <span class="apidocSignatureSpan">(conditions, options, model, collection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Query(conditions, options, model, collection) {
  // this stuff is for dealing with custom queries created by #toConstructor
  if (!this._mongooseOptions) {
    this._mongooseOptions = {};
  }

  // this is the case where we have a CustomQuery, we need to check if we got
  // options passed in, and if we did, merge them in
  if (options) {
    var keys = Object.keys(options);
    for (var i = 0; i &#x3c; keys.length; ++i) {
      var k = keys[i];
      this._mongooseOptions[k] = options[k];
    }
  }

  if (collection) {
    this.mongooseCollection = collection;
  }

  if (model) {
    this.model = model;
    this.schema = model.schema;
  }

  // this is needed because map reduce returns a model that can be queried, but
  // all of the queries on said model should be lean
  if (this.model &#x26;&#x26; this.model._mapreduce) {
    this.lean();
  }

  // inherit mquery
  mquery.call(this, this.mongooseCollection, options);

  if (conditions) {
    this.find(conditions);
  }

  if (this.schema) {
    var kareemOptions = {
      useErrorHandlers: true,
      numCallbackParams: 1
    };
    this._count = this.model.hooks.createWrapper(&#x27;count&#x27;,
        Query.prototype._count, this, kareemOptions);
    this._execUpdate = this.model.hooks.createWrapper(&#x27;update&#x27;,
        Query.prototype._execUpdate, this, kareemOptions);
    this._find = this.model.hooks.createWrapper(&#x27;find&#x27;,
        Query.prototype._find, this, kareemOptions);
    this._findOne = this.model.hooks.createWrapper(&#x27;findOne&#x27;,
        Query.prototype._findOne, this, kareemOptions);
    this._findOneAndRemove = this.model.hooks.createWrapper(&#x27;findOneAndRemove&#x27;,
        Query.prototype._findOneAndRemove, this, kareemOptions);
    this._findOneAndUpdate = this.model.hooks.createWrapper(&#x27;findOneAndUpdate&#x27;,
        Query.prototype._findOneAndUpdate, this, kareemOptions);
    this._replaceOne = this.model.hooks.createWrapper(&#x27;replaceOne&#x27;,
        Query.prototype._replaceOne, this, kareemOptions);
    this._updateMany = this.model.hooks.createWrapper(&#x27;updateMany&#x27;,
        Query.prototype._updateMany, this, kareemOptions);
    this._updateOne = this.model.hooks.createWrapper(&#x27;updateOne&#x27;,
        Query.prototype._updateOne, this, kareemOptions);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.query.prototype" id="apidoc.module.mongoose.query.prototype">module mongoose.query.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.query.prototype._applyPaths" id="apidoc.element.mongoose.query.prototype._applyPaths">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_applyPaths
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function applyPaths() {
  this._fields = this._fields || {};
  helpers.applyPaths(this._fields, this.model.schema);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
Query.prototype._find = function(callback) {
if (this._castError) {
  callback(this._castError);
  return this;
}

this.<span class="apidocCodeKeywordSpan">_applyPaths</span>();
this._fields = this._castFields(this._fields);

var fields = this._fieldsForExec();
var options = this._mongooseOptions;
var _this = this;

var cb = function(err, docs) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype._castFields" id="apidoc.element.mongoose.query.prototype._castFields">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_castFields
        <span class="apidocSignatureSpan">(fields)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _castFields(fields) {
  var selected,
      elemMatchKeys,
      keys,
      key,
      out,
      i;

  if (fields) {
    keys = Object.keys(fields);
    elemMatchKeys = [];
    i = keys.length;

    // collect $elemMatch args
    while (i--) {
      key = keys[i];
      if (fields[key].$elemMatch) {
        selected || (selected = {});
        selected[key] = fields[key];
        elemMatchKeys.push(key);
      }
    }
  }

  if (selected) {
    // they passed $elemMatch, cast em
    try {
      out = this.cast(this.model, selected);
    } catch (err) {
      return err;
    }

    // apply the casted field args
    i = elemMatchKeys.length;
    while (i--) {
      key = elemMatchKeys[i];
      fields[key] = out[key];
    }
  }

  return fields;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Query.prototype._find = function(callback) {
if (this._castError) {
  callback(this._castError);
  return this;
}

this._applyPaths();
this._fields = this.<span class="apidocCodeKeywordSpan">_castFields</span>(this._fields);

var fields = this._fieldsForExec();
var options = this._mongooseOptions;
var _this = this;

var cb = function(err, docs) {
  if (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype._castUpdate" id="apidoc.element.mongoose.query.prototype._castUpdate">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_castUpdate
        <span class="apidocSignatureSpan">(obj, overwrite)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _castUpdate(obj, overwrite) {
  var strict;
  if (&#x27;strict&#x27; in this._mongooseOptions) {
    strict = this._mongooseOptions.strict;
  } else if (this.schema &#x26;&#x26; this.schema.options) {
    strict = this.schema.options.strict;
  } else {
    strict = true;
  }
  return castUpdate(this.schema, obj, {
    overwrite: overwrite,
    strict: strict
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// validate the update part of the query
var castedDoc;
try {
  var $options = {retainKeyOrder: true};
  if (options &#x26;&#x26; options.minimize) {
    $options.minimize = true;
  }
  castedDoc = query.<span class="apidocCodeKeywordSpan">_castUpdate</span>(utils.clone(doc, $options),
    (options &#x26;&#x26; options.overwrite) || op === &#x27;replaceOne&#x27;);
} catch (err) {
  query._castError = castedQuery;
  if (callback) {
    callback(err);
    return query;
  } else if (!options || !options.dontThrowCastError) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype._count" id="apidoc.element.mongoose.query.prototype._count">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_count
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_count = function (callback) {
  try {
    this.cast(this.model);
  } catch (err) {
    process.nextTick(function() {
      callback(err);
    });
    return this;
  }

  var conds = this._conditions;
  var options = this._optionsForExec();

  this._collection.count(conds, options, utils.tick(callback));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 }

 this.op = &#x27;count&#x27;;
 if (!callback) {
   return this;
 }

 this.<span class="apidocCodeKeywordSpan">_count</span>(callback);

 return this;
};

/**
* Declares or executes a distict() operation.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype._execUpdate" id="apidoc.element.mongoose.query.prototype._execUpdate">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_execUpdate
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_execUpdate = function (callback) {
  var schema = this.model.schema;
  var doValidate;
  var _this;

  var castedQuery = this._conditions;
  var castedDoc = this._update;
  var options = this.options;

  if (this._castError) {
    callback(this._castError);
    return this;
  }

  if (this.options.runValidators) {
    _this = this;
    doValidate = updateValidators(this, schema, castedDoc, options);
    var _callback = function(err) {
      if (err) {
        return callback(err);
      }

      Query.base.update.call(_this, castedQuery, castedDoc, options, callback);
    };
    try {
      doValidate(_callback);
    } catch (err) {
      process.nextTick(function() {
        callback(err);
      });
    }
    return this;
  }

  Query.base.update.call(this, castedQuery, castedDoc, options, callback);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!query._update) {
    query._update = castedDoc;
  }

  // Hooks
  if (callback) {
    if (op === &#x27;update&#x27;) {
      return query.<span class="apidocCodeKeywordSpan">_execUpdate</span>(callback);
    }
    return query[&#x27;_&#x27; + op](callback);
  }

  return Query.base[op].call(query, castedQuery, castedDoc, options, callback);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype._find" id="apidoc.element.mongoose.query.prototype._find">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_find
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_find = function (callback) {
  if (this._castError) {
    callback(this._castError);
    return this;
  }

  this._applyPaths();
  this._fields = this._castFields(this._fields);

  var fields = this._fieldsForExec();
  var options = this._mongooseOptions;
  var _this = this;

  var cb = function(err, docs) {
    if (err) {
      return callback(err);
    }

    if (docs.length === 0) {
      return callback(null, docs);
    }

    if (!options.populate) {
      return options.lean === true
          ? callback(null, docs)
          : completeMany(_this.model, docs, fields, null, callback);
    }

    var pop = helpers.preparePopulationOptionsMQ(_this, options);
    pop.__noPromise = true;
    _this.model.populate(docs, pop, function(err, docs) {
      if (err) return callback(err);
      return options.lean === true
          ? callback(null, docs)
          : completeMany(_this.model, docs, fields, pop, callback);
    });
  };

  return Query.base.find.call(this, {}, cb);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 }

 // if we don&#x27;t have a callback, then just return the query object
 if (!callback) {
   return Query.base.find.call(this);
 }

 this.<span class="apidocCodeKeywordSpan">_find</span>(callback);

 return this;
};

/**
* Merges another Query or conditions object into this one.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype._findAndModify" id="apidoc.element.mongoose.query.prototype._findAndModify">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_findAndModify
        <span class="apidocSignatureSpan">(type, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_findAndModify = function (type, callback) {
  if (typeof callback !== &#x27;function&#x27;) {
    throw new Error(&#x27;Expected callback in _findAndModify&#x27;);
  }

  var model = this.model;
  var schema = model.schema;
  var _this = this;
  var castedQuery;
  var castedDoc;
  var fields;
  var opts;
  var doValidate;

  castedQuery = castQuery(this);
  if (castedQuery instanceof Error) {
    return callback(castedQuery);
  }

  opts = this._optionsForExec(model);

  if (&#x27;strict&#x27; in opts) {
    this._mongooseOptions.strict = opts.strict;
  }

  if (type === &#x27;remove&#x27;) {
    opts.remove = true;
  } else {
    if (!(&#x27;new&#x27; in opts)) {
      opts.new = false;
    }
    if (!(&#x27;upsert&#x27; in opts)) {
      opts.upsert = false;
    }
    if (opts.upsert || opts[&#x27;new&#x27;]) {
      opts.remove = false;
    }

    castedDoc = castDoc(this, opts.overwrite);
    castedDoc = setDefaultsOnInsert(this, schema, castedDoc, opts);
    if (!castedDoc) {
      if (opts.upsert) {
        // still need to do the upsert to empty doc
        var doc = utils.clone(castedQuery);
        delete doc._id;
        castedDoc = {$set: doc};
      } else {
        return this.findOne(callback);
      }
    } else if (castedDoc instanceof Error) {
      return callback(castedDoc);
    } else {
      // In order to make MongoDB 2.6 happy (see
      // https://jira.mongodb.org/browse/SERVER-12266 and related issues)
      // if we have an actual update document but $set is empty, junk the $set.
      if (castedDoc.$set &#x26;&#x26; Object.keys(castedDoc.$set).length === 0) {
        delete castedDoc.$set;
      }
    }

    doValidate = updateValidators(this, schema, castedDoc, opts);
  }

  this._applyPaths();

  var options = this._mongooseOptions;

  if (this._fields) {
    fields = utils.clone(this._fields);
    opts.fields = this._castFields(fields);
    if (opts.fields instanceof Error) {
      return callback(opts.fields);
    }
  }

  if (opts.sort) convertSortToArray(opts);

  var cb = function(err, doc, res) {
    if (err) {
      return callback(err);
    }

    if (!doc || (utils.isObject(doc) &#x26;&#x26; Object.keys(doc).length === 0)) {
      if (opts.rawResult) {
        return callback(null, res);
      }
      // opts.passRawResult will be deprecated soon
      if (opts.passRawResult) {
        return callback(null, null, decorateResult(res));
      }
      return callback(null, null);
    }

    if (!options.populate) {
      if (options.lean === true) {
        return _completeOneLean(doc, res, opts, callback);
      }
      return completeOne(_this.model, doc, res, opts, fields, null, callback);
    }

    var pop = helpers.preparePopulationOptionsMQ(_this, options);
    pop.__noPromise = true;
    _this.model.populate(doc, pop, function(err, doc) {
      if (err) {
        return callback(err);
      }

      if (options.lean === true) {
        return _completeOneLean(doc, res, opts, callback);
      }
      return completeOne(_this.model, doc, res, opts, fields, pop, callback);
    });
  };

  if (opts.runValidators &#x26;&#x26; doValidate) {
    var _callback = function(error) {
      if (error) {
        return callback(error);
      }
      _this._collection.findAndModify(castedQuery, castedDoc, opts, utils.tick(function(error, res) {
        return cb(error, res ? res.value : res, res);
      }));
    };

    try {
      doValidate(_callback);
    } catch (error) {
      callback(error);
    }
  } else {
    this._collection.findAndModify(castedQuery, castedDoc, opts, utils.tick(function(error, res) {
      return cb(error, res ? res.value : res, res);
    }));
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Thunk around findOneAndUpdate()
*
* @param {Function} [callback]
* @api private
*/

Query.prototype._findOneAndUpdate = function(callback) {
 this.<span class="apidocCodeKeywordSpan">_findAndModify</span>(&#x27;update&#x27;, callback);
 return this;
};

/**
* Issues a mongodb [findAndModify](http://www.mongodb.org/display/DOCS/findAndModify+Command) remove command.
*
* Finds a matching document, removes it, passing the found document (if any) to the callback. Executes immediately if `callback`
is passed.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype._findOne" id="apidoc.element.mongoose.query.prototype._findOne">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_findOne
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_findOne = function (callback) {
  if (this._castError) {
    return callback(this._castError);
  }

  this._applyPaths();
  this._fields = this._castFields(this._fields);

  var options = this._mongooseOptions;
  var projection = this._fieldsForExec();
  var _this = this;

  // don&#x27;t pass in the conditions because we already merged them in
  Query.base.findOne.call(_this, {}, function(err, doc) {
    if (err) {
      return callback(err);
    }
    if (!doc) {
      return callback(null, null);
    }

    if (!options.populate) {
      return options.lean === true
          ? callback(null, doc)
          : completeOne(_this.model, doc, null, {}, projection, null, callback);
    }

    var pop = helpers.preparePopulationOptionsMQ(_this, options);
    pop.__noPromise = true;
    _this.model.populate(doc, pop, function(err, doc) {
      if (err) {
        return callback(err);
      }
      return options.lean === true
          ? callback(null, doc)
          : completeOne(_this.model, doc, null, {}, projection, pop, callback);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 }

 if (!callback) {
   // already merged in the conditions, don&#x27;t need to send them in.
   return Query.base.findOne.call(this);
 }

 this.<span class="apidocCodeKeywordSpan">_findOne</span>(callback);

 return this;
};

/**
* Thunk around count()
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype._findOneAndRemove" id="apidoc.element.mongoose.query.prototype._findOneAndRemove">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_findOneAndRemove
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_findOneAndRemove = function (callback) {
  Query.base.findOneAndRemove.call(this, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

 options &#x26;&#x26; this.setOptions(options);

 if (!callback) {
   return this;
 }

 this.<span class="apidocCodeKeywordSpan">_findOneAndRemove</span>(callback);

 return this;
};

/*!
* Thunk around findOneAndRemove()
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype._findOneAndUpdate" id="apidoc.element.mongoose.query.prototype._findOneAndUpdate">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_findOneAndUpdate
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_findOneAndUpdate = function (callback) {
  this._findAndModify(&#x27;update&#x27;, callback);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   this.setOptions(options);
 }

 if (!callback) {
   return this;
 }

 return this.<span class="apidocCodeKeywordSpan">_findOneAndUpdate</span>(callback);
};

/*!
* Thunk around findOneAndUpdate()
*
* @param {Function} [callback]
* @api private
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype._mergeUpdate" id="apidoc.element.mongoose.query.prototype._mergeUpdate">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_mergeUpdate
        <span class="apidocSignatureSpan">(doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_mergeUpdate = function (doc) {
  if (!this._update) this._update = {};
  if (doc instanceof Query) {
    if (doc._update) {
      utils.mergeClone(this._update, doc._update);
    }
  } else {
    utils.mergeClone(this._update, doc);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (mquery.canMerge(criteria)) {
  this.merge(criteria);
}

// apply doc
if (doc) {
  this.<span class="apidocCodeKeywordSpan">_mergeUpdate</span>(doc);
}

if (options) {
  options = utils.clone(options, { retainKeyOrder: true });
  if (options.projection) {
    this.select(options.projection);
    delete options.projection;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype._optionsForExec" id="apidoc.element.mongoose.query.prototype._optionsForExec">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_optionsForExec
        <span class="apidocSignatureSpan">(model)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_optionsForExec = function (model) {
  var options = Query.base._optionsForExec.call(this);

  delete options.populate;
  delete options.retainKeyOrder;
  model = model || this.model;

  if (!model) {
    return options;
  }

  if (!(&#x27;safe&#x27; in options) &#x26;&#x26; model.schema.options.safe) {
    options.safe = model.schema.options.safe;
  }

  if (!(&#x27;readPreference&#x27; in options) &#x26;&#x26; model.schema.options.read) {
    options.readPreference = model.schema.options.read;
  }

  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   process.nextTick(function() {
     callback(err);
   });
   return this;
 }

 var conds = this._conditions;
 var options = this.<span class="apidocCodeKeywordSpan">_optionsForExec</span>();

 this._collection.count(conds, options, utils.tick(callback));
};

/**
* Specifying this query as a `count` query.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype._replaceOne" id="apidoc.element.mongoose.query.prototype._replaceOne">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_replaceOne
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_replaceOne = function (callback) {
  var schema = this.model.schema;
  var doValidate;
  var _this;

  var castedQuery = this._conditions;
  var castedDoc = this._update;
  var options = this.options;

  if (this._castError) {
    callback(this._castError);
    return this;
  }

  if (this.options.runValidators) {
    _this = this;
    doValidate = updateValidators(this, schema, castedDoc, options);
    var _callback = function(err) {
      if (err) {
        return callback(err);
      }

      Query.base.updateMany.call(_this, castedQuery, castedDoc, options, callback);
    };
    try {
      doValidate(_callback);
    } catch (err) {
      process.nextTick(function() {
        callback(err);
      });
    }
    return this;
  }

  Query.base.replaceOne.call(this, castedQuery, castedDoc, options, callback);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype._updateForExec" id="apidoc.element.mongoose.query.prototype._updateForExec">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_updateForExec
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateForExec = function () {
  var update = utils.clone(this._update, {
    retainKeyOrder: true,
    transform: false,
    depopulate: true
  });
  var ops = Object.keys(update);
  var i = ops.length;
  var ret = {};

  while (i--) {
    var op = ops[i];

    if (this.options.overwrite) {
      ret[op] = update[op];
      continue;
    }

    if (&#x27;$&#x27; !== op[0]) {
      // fix up $set sugar
      if (!ret.$set) {
        if (update.$set) {
          ret.$set = update.$set;
        } else {
          ret.$set = {};
        }
      }
      ret.$set[op] = update[op];
      ops.splice(i, 1);
      if (!~ops.indexOf(&#x27;$set&#x27;)) ops.push(&#x27;$set&#x27;);
    } else if (&#x27;$set&#x27; === op) {
      if (!ret.$set) {
        ret[op] = update[op];
      }
    } else {
      ret[op] = update[op];
    }
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// if doc is undefined at this point, this means this function is being
// executed by exec(not always see below). Grab the update doc from here in
// order to validate
// This could also be somebody calling update() or update({}). Probably not a
// common use case, check for _update to make sure we don&#x27;t do anything bad
if (!doc &#x26;&#x26; query._update) {
  doc = query.<span class="apidocCodeKeywordSpan">_updateForExec</span>();
}

if (mquery.canMerge(conditions)) {
  query.merge(conditions);
}

// validate the selector part of the query
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype._updateMany" id="apidoc.element.mongoose.query.prototype._updateMany">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_updateMany
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateMany = function (callback) {
  var schema = this.model.schema;
  var doValidate;
  var _this;

  var castedQuery = this._conditions;
  var castedDoc = this._update;
  var options = this.options;

  if (this._castError) {
    callback(this._castError);
    return this;
  }

  if (this.options.runValidators) {
    _this = this;
    doValidate = updateValidators(this, schema, castedDoc, options);
    var _callback = function(err) {
      if (err) {
        return callback(err);
      }

      Query.base.updateMany.call(_this, castedQuery, castedDoc, options, callback);
    };
    try {
      doValidate(_callback);
    } catch (err) {
      process.nextTick(function() {
        callback(err);
      });
    }
    return this;
  }

  Query.base.updateMany.call(this, castedQuery, castedDoc, options, callback);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype._updateOne" id="apidoc.element.mongoose.query.prototype._updateOne">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>_updateOne
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_updateOne = function (callback) {
  var schema = this.model.schema;
  var doValidate;
  var _this;

  var castedQuery = this._conditions;
  var castedDoc = this._update;
  var options = this.options;

  if (this._castError) {
    callback(this._castError);
    return this;
  }

  if (this.options.runValidators) {
    _this = this;
    doValidate = updateValidators(this, schema, castedDoc, options);
    var _callback = function(err) {
      if (err) {
        return callback(err);
      }

      Query.base.updateOne.call(_this, castedQuery, castedDoc, options, callback);
    };
    try {
      doValidate(_callback);
    } catch (err) {
      process.nextTick(function() {
        callback(err);
      });
    }
    return this;
  }

  Query.base.updateOne.call(this, castedQuery, castedDoc, options, callback);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.box" id="apidoc.element.mongoose.query.prototype.box">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>box
        <span class="apidocSignatureSpan">(ll, ur)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">box = function (ll, ur) {
  if (!Array.isArray(ll) &#x26;&#x26; utils.isObject(ll)) {
    ur = ll.ur;
    ll = ll.ll;
  }
  return Query.base.box.call(this, ll, ur);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*/

/**
* Defines a `$within` or `$geoWithin` argument for geo-spatial queries.
*
* ####Example
*
*     query.where(path).within().<span class="apidocCodeKeywordSpan">box</span>()
*     query.where(path).within().circle()
*     query.where(path).within().geometry()
*
*     query.where(&#x27;loc&#x27;).within({ center: [50,50], radius: 10, unique: true, spherical: true });
*     query.where(&#x27;loc&#x27;).within({ box: [[40.73, -73.9], [40.7, -73.988]] });
*     query.where(&#x27;loc&#x27;).within({ polygon: [[],[],[],[]] });
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.cast" id="apidoc.element.mongoose.query.prototype.cast">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>cast
        <span class="apidocSignatureSpan">(model, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cast = function (model, obj) {
  obj || (obj = this._conditions);

  try {
    return cast(model.schema, obj, {
      upsert: this.options &#x26;&#x26; this.options.upsert,
      strict: (this.options &#x26;&#x26; this.options.strict) ||
        (model.schema.options &#x26;&#x26; model.schema.options.strict)
    });
  } catch (err) {
    // CastError, assign model
    if (typeof err.setModel === &#x27;function&#x27;) {
      err.setModel(model);
    }
    throw err;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  doc[i] = obj[i];
} else {
  if (obj[i] === null) {
    doc[i] = null;
  } else if (obj[i] !== undefined) {
    if (schema) {
      try {
        doc[i] = schema.<span class="apidocCodeKeywordSpan">cast</span>(obj[i], self, true);
      } catch (e) {
        self.invalidate(e.path, new ValidatorError({
          path: e.path,
          message: e.message,
          type: &#x27;cast&#x27;,
          value: e.value
        }));
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.catch" id="apidoc.element.mongoose.query.prototype.catch">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>catch
        <span class="apidocSignatureSpan">(reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catch = function (reject) {
  return this.exec().then(null, reject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Promise.prototype.then = util.deprecate(Promise.prototype.then,
 &#x27;Mongoose: mpromise (mongoose\&#x27;s default promise library) is deprecated, &#x27; +
 &#x27;plug in your own promise library instead: &#x27; +
 &#x27;http://mongoosejs.com/docs/promises.html&#x27;);

/**
* ES6-style `.<span class="apidocCodeKeywordSpan">catch</span>()` shorthand
*
* @method catch
* @memberOf Promise
* @param {Function} onReject
* @return {Promise}
* @api public
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.center" id="apidoc.element.mongoose.query.prototype.center">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>center
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">center = function () {
  var path, val;

  if (1 === arguments.length) {
    this._ensurePath(&#x27;circle&#x27;);
    path = this._path;
    val = arguments[0];
  } else if (2 === arguments.length) {
    path = arguments[0];
    val = arguments[1];
  } else {
    throw new TypeError(&#x22;Invalid argument&#x22;);
  }

  if (!(&#x27;radius&#x27; in val &#x26;&#x26; val.center))
    throw new Error(&#x27;center and radius are required&#x27;);

  var conds = this._conditions[path] || (this._conditions[path] = {});

  var type = val.spherical
    ? &#x27;$centerSphere&#x27;
    : &#x27;$center&#x27;;

  var wKey = this._geoComparison || $withinCmd;
  conds[wKey] = {};
  conds[wKey][type] = [val.center, val.radius];

  if (&#x27;unique&#x27; in val)
    conds[wKey].$uniqueDocs = !! val.unique;

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.centerSphere" id="apidoc.element.mongoose.query.prototype.centerSphere">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>centerSphere
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">centerSphere = function () {
  if (arguments[0] &#x26;&#x26; arguments[0].constructor.name === &#x27;Object&#x27;) {
    arguments[0].spherical = true;
  }

  if (arguments[1] &#x26;&#x26; arguments[1].constructor.name === &#x27;Object&#x27;) {
    arguments[1].spherical = true;
  }

  Query.base.circle.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* _DEPRECATED_ Specifies a $centerSphere condition
*
* **Deprecated.** Use [circle](#query_Query-circle) instead.
*
* ####Example
*
*     var area = { center: [50, 50], radius: 10 };
*     query.where(&#x27;loc&#x27;).within().<span class="apidocCodeKeywordSpan">centerSphere</span>(area);
*
* @deprecated
* @param {String} [path]
* @param {Object} val
* @return {Query} this
* @see http://www.mongodb.org/display/DOCS/Geospatial+Indexing
* @see $centerSphere http://docs.mongodb.org/manual/reference/operator/centerSphere/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.collation" id="apidoc.element.mongoose.query.prototype.collation">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>collation
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collation = function (value) {
  if (this.options == null) {
    this.options = {};
  }
  this.options.collation = value;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
 * Adds a collation
 *
 * ####Example:
 *
 *     Model.aggregate(..).<span class="apidocCodeKeywordSpan">collation</span>({ locale: &#x27;en_US&#x27;, strength: 1 }).exec
();
 *
 * @param {Object} collation options
 * @param {Boolean} value
 * @see mongodb http://mongodb.github.io/node-mongodb-native/2.2/api/Collection.html#aggregate
 */

Aggregate.prototype.collation = function(collation) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.constructor" id="apidoc.element.mongoose.query.prototype.constructor">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>constructor
        <span class="apidocSignatureSpan">(conditions, options, model, collection)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Query(conditions, options, model, collection) {
  // this stuff is for dealing with custom queries created by #toConstructor
  if (!this._mongooseOptions) {
    this._mongooseOptions = {};
  }

  // this is the case where we have a CustomQuery, we need to check if we got
  // options passed in, and if we did, merge them in
  if (options) {
    var keys = Object.keys(options);
    for (var i = 0; i &#x3c; keys.length; ++i) {
      var k = keys[i];
      this._mongooseOptions[k] = options[k];
    }
  }

  if (collection) {
    this.mongooseCollection = collection;
  }

  if (model) {
    this.model = model;
    this.schema = model.schema;
  }

  // this is needed because map reduce returns a model that can be queried, but
  // all of the queries on said model should be lean
  if (this.model &#x26;&#x26; this.model._mapreduce) {
    this.lean();
  }

  // inherit mquery
  mquery.call(this, this.mongooseCollection, options);

  if (conditions) {
    this.find(conditions);
  }

  if (this.schema) {
    var kareemOptions = {
      useErrorHandlers: true,
      numCallbackParams: 1
    };
    this._count = this.model.hooks.createWrapper(&#x27;count&#x27;,
        Query.prototype._count, this, kareemOptions);
    this._execUpdate = this.model.hooks.createWrapper(&#x27;update&#x27;,
        Query.prototype._execUpdate, this, kareemOptions);
    this._find = this.model.hooks.createWrapper(&#x27;find&#x27;,
        Query.prototype._find, this, kareemOptions);
    this._findOne = this.model.hooks.createWrapper(&#x27;findOne&#x27;,
        Query.prototype._findOne, this, kareemOptions);
    this._findOneAndRemove = this.model.hooks.createWrapper(&#x27;findOneAndRemove&#x27;,
        Query.prototype._findOneAndRemove, this, kareemOptions);
    this._findOneAndUpdate = this.model.hooks.createWrapper(&#x27;findOneAndUpdate&#x27;,
        Query.prototype._findOneAndUpdate, this, kareemOptions);
    this._replaceOne = this.model.hooks.createWrapper(&#x27;replaceOne&#x27;,
        Query.prototype._replaceOne, this, kareemOptions);
    this._updateMany = this.model.hooks.createWrapper(&#x27;updateMany&#x27;,
        Query.prototype._updateMany, this, kareemOptions);
    this._updateOne = this.model.hooks.createWrapper(&#x27;updateOne&#x27;,
        Query.prototype._updateOne, this, kareemOptions);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (obj.constructor) {
  switch (exports.getFunctionName(obj.constructor)) {
    case &#x27;Object&#x27;:
      return cloneObject(obj, options);
    case &#x27;Date&#x27;:
      return new obj.<span class="apidocCodeKeywordSpan">constructor</span>(+obj);
    case &#x27;RegExp&#x27;:
      return cloneRegExp(obj);
    default:
      // ignore
      break;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.count" id="apidoc.element.mongoose.query.prototype.count">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>count
        <span class="apidocSignatureSpan">(conditions, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">count = function (conditions, callback) {
  if (typeof conditions === &#x27;function&#x27;) {
    callback = conditions;
    conditions = undefined;
  }

  if (mquery.canMerge(conditions)) {
    this.merge(conditions);
  }

  this.op = &#x27;count&#x27;;
  if (!callback) {
    return this;
  }

  this._count(callback);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Counts number of matching documents in a database collection.
*
* ####Example:
*
*     Adventure.<span class="apidocCodeKeywordSpan">count</span>({ type: &#x27;jungle&#x27; }, function (err, count) {
*       if (err) ..
*       console.log(&#x27;there are %d jungle adventures&#x27;, count);
*     });
*
* @param {Object} conditions
* @param {Function} [callback]
* @return {Query}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.cursor" id="apidoc.element.mongoose.query.prototype.cursor">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>cursor
        <span class="apidocSignatureSpan">(opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function cursor(opts) {
  this._applyPaths();
  this._fields = this._castFields(this._fields);
  this.setOptions({ fields: this._fieldsForExec() });
  if (opts) {
    this.setOptions(opts);
  }

  try {
    this.cast(this.model);
  } catch (err) {
    return (new QueryCursor(this, this.options))._markError(err);
  }

  return new QueryCursor(this, this.options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Sets the cursor option option for the aggregation query (ignored for &#x3c; 2.6.0).
* Note the different syntax below: .exec() returns a cursor object, and no callback
* is necessary.
*
* ####Example:
*
*     var cursor = Model.aggregate(..).<span class="apidocCodeKeywordSpan">cursor</span>({ batchSize: 1000 }).exec();
*     cursor.each(function(error, doc) {
*       // use doc
*     });
*
* @param {Object} options set the cursor batch size
* @see mongodb http://mongodb.github.io/node-mongodb-native/2.0/api/AggregationCursor.html
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.deleteMany" id="apidoc.element.mongoose.query.prototype.deleteMany">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>deleteMany
        <span class="apidocSignatureSpan">(cond, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteMany = function (cond, callback) {
  if (typeof cond === &#x27;function&#x27;) {
    callback = cond;
    cond = null;
  }

  var cb = typeof callback === &#x27;function&#x27;;

  try {
    this.cast(this.model);
  } catch (err) {
    if (cb) return process.nextTick(callback.bind(null, err));
    return this;
  }

  return Query.base.deleteMany.call(this, cond, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Deletes the first document that matches `conditions` from the collection.
* Behaves like `remove()`, but deletes all documents that match `conditions`
* regardless of the `justOne` option.
*
* ####Example:
*
*     Character.<span class="apidocCodeKeywordSpan">deleteMany</span>({ name: /Stark/, age: { $gte: 18 } }, function (err) {});
*
* ####Note:
*
* Like `Model.remove()`, this function does **not** trigger `pre(&#x27;remove&#x27;)` or `post(&#x27;remove&#x27;)` hooks.
*
* @param {Object} conditions
* @param {Function} [callback]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.deleteOne" id="apidoc.element.mongoose.query.prototype.deleteOne">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>deleteOne
        <span class="apidocSignatureSpan">(cond, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deleteOne = function (cond, callback) {
  if (typeof cond === &#x27;function&#x27;) {
    callback = cond;
    cond = null;
  }

  var cb = typeof callback === &#x27;function&#x27;;

  try {
    this.cast(this.model);
  } catch (err) {
    if (cb) return process.nextTick(callback.bind(null, err));
    return this;
  }

  return Query.base.deleteOne.call(this, cond, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Deletes the first document that matches `conditions` from the collection.
* Behaves like `remove()`, but deletes at most one document regardless of the
* `justOne` option.
*
* ####Example:
*
*     Character.<span class="apidocCodeKeywordSpan">deleteOne</span>({ name: &#x27;Eddard Stark&#x27; }, function (err) {});
*
* ####Note:
*
* Like `Model.remove()`, this function does **not** trigger `pre(&#x27;remove&#x27;)` or `post(&#x27;remove&#x27;)` hooks.
*
* @param {Object} conditions
* @param {Function} [callback]
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.distinct" id="apidoc.element.mongoose.query.prototype.distinct">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>distinct
        <span class="apidocSignatureSpan">(field, conditions, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">distinct = function (field, conditions, callback) {
  if (!callback) {
    if (typeof conditions === &#x27;function&#x27;) {
      callback = conditions;
      conditions = undefined;
    } else if (typeof field === &#x27;function&#x27;) {
      callback = field;
      field = undefined;
      conditions = undefined;
    }
  }

  conditions = utils.toObject(conditions);

  if (mquery.canMerge(conditions)) {
    this.merge(conditions);
  }

  try {
    this.cast(this.model);
  } catch (err) {
    if (!callback) {
      throw err;
    }
    callback(err);
    return this;
  }

  return Query.base.distinct.call(this, {}, field, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Creates a Query for a `distinct` operation.
*
* Passing a `callback` immediately executes the query.
*
* ####Example
*
*     Link.<span class="apidocCodeKeywordSpan">distinct</span>(&#x27;url&#x27;, { clicks: {$gt: 100}}, function (err, result) {
*       if (err) return handleError(err);
*
*       assert(Array.isArray(result));
*       console.log(&#x27;unique urls with more than 100 clicks&#x27;, result);
*     })
*
*     var query = Link.distinct(&#x27;url&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.exec" id="apidoc.element.mongoose.query.prototype.exec">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>exec
        <span class="apidocSignatureSpan">(op, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function exec(op, callback) {
  var Promise = PromiseProvider.get();
  var _this = this;

  if (typeof op === &#x27;function&#x27;) {
    callback = op;
    op = null;
  } else if (typeof op === &#x27;string&#x27;) {
    this.op = op;
  }

  var _results;
  var promise = new Promise.ES6(function(resolve, reject) {
    if (!_this.op) {
      resolve();
      return;
    }

    _this[_this.op].call(_this, function(error, res) {
      if (error) {
        reject(error);
        return;
      }
      _results = arguments;
      resolve(res);
    });
  });

  if (callback) {
    promise.then(
      function() {
        callback.apply(null, _results);
        return null;
      },
      function(error) {
        callback(error);
      }).
      catch(function(error) {
        // If we made it here, we must have an error in the callback re:
        // gh-4500, so we need to emit.
        setImmediate(function() {
          _this.model.emit(&#x27;error&#x27;, error);
        });
      });
  }

  return promise;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* ES6 Promise wrapper constructor.
*
* Promises are returned from executed queries. Example:
*
*     var query = Candy.find({ bar: true });
*     var promise = query.<span class="apidocCodeKeywordSpan">exec</span>();
*
* DEPRECATED. Mongoose 5.0 will use native promises by default (or bluebird,
* if native promises are not present) but still
* support plugging in your own ES6-compatible promises library. Mongoose 5.0
* will **not** support mpromise.
*
* @param {Function} fn a function which will be called when the promise is resolved that accepts `fn(err, ...){}` as signature
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.find" id="apidoc.element.mongoose.query.prototype.find">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>find
        <span class="apidocSignatureSpan">(conditions, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">find = function (conditions, callback) {
  if (typeof conditions === &#x27;function&#x27;) {
    callback = conditions;
    conditions = {};
  }

  conditions = utils.toObject(conditions);

  if (mquery.canMerge(conditions)) {
    this.merge(conditions);
  }

  prepareDiscriminatorCriteria(this);

  try {
    this.cast(this.model);
    this._castError = null;
  } catch (err) {
    this._castError = err;
  }

  // if we don&#x27;t have a callback, then just return the query object
  if (!callback) {
    return Query.base.find.call(this);
  }

  this._find(callback);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  //
});
```

Or we can find documents from the same collection

```js
MyModel.<span class="apidocCodeKeywordSpan">find</span>({}, function (err, docs) {
  // docs.forEach
});
```

You can also `findOne`, `findById`, `update`, etc. For more details check out [the docs](http://mongoosejs.com/docs/queries.html
).

**Important!** If you opened a separate connection using `mongoose.createConnection()` but attempt to access the model through `
mongoose.model(&#x27;ModelName&#x27;)` it will not work as expected since it is not hooked up to an active db connection. In this
 case access your model through the connection you created:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.findOne" id="apidoc.element.mongoose.query.prototype.findOne">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>findOne
        <span class="apidocSignatureSpan">(conditions, projection, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findOne = function (conditions, projection, options, callback) {
  if (typeof conditions === &#x27;function&#x27;) {
    callback = conditions;
    conditions = null;
    projection = null;
    options = null;
  } else if (typeof projection === &#x27;function&#x27;) {
    callback = projection;
    options = null;
    projection = null;
  } else if (typeof options === &#x27;function&#x27;) {
    callback = options;
    options = null;
  }

  // make sure we don&#x27;t send in the whole Document to merge()
  conditions = utils.toObject(conditions);

  this.op = &#x27;findOne&#x27;;

  if (options) {
    this.setOptions(options);
  }

  if (projection) {
    this.select(projection);
  }

  if (mquery.canMerge(conditions)) {
    this.merge(conditions);
  } else if (conditions != null) {
    throw new Error(&#x27;Invalid argument to findOne(): &#x27; +
      util.inspect(conditions));
  }

  prepareDiscriminatorCriteria(this);

  try {
    this.cast(this.model);
    this._castError = null;
  } catch (err) {
    this._castError = err;
  }

  if (!callback) {
    // already merged in the conditions, don&#x27;t need to send them in.
    return Query.base.findOne.call(this);
  }

  this._findOne(callback);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Checks if `path` was selected in the source query which initialized this document.
*
* ####Example
*
*     Thing.<span class="apidocCodeKeywordSpan">findOne</span>().select(&#x27;name&#x27;).exec(function (err, doc) {
*        doc.isSelected(&#x27;name&#x27;) // true
*        doc.isSelected(&#x27;age&#x27;)  // false
*     })
*
* @param {String} path
* @return {Boolean}
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.findOneAndRemove" id="apidoc.element.mongoose.query.prototype.findOneAndRemove">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>findOneAndRemove
        <span class="apidocSignatureSpan">(conditions, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findOneAndRemove = function (conditions, options, callback) {
  this.op = &#x27;findOneAndRemove&#x27;;
  this._validate();

  switch (arguments.length) {
    case 2:
      if (typeof options === &#x27;function&#x27;) {
        callback = options;
        options = {};
      }
      break;
    case 1:
      if (typeof conditions === &#x27;function&#x27;) {
        callback = conditions;
        conditions = undefined;
        options = undefined;
      }
      break;
  }

  if (mquery.canMerge(conditions)) {
    this.merge(conditions);
  }

  options &#x26;&#x26; this.setOptions(options);

  if (!callback) {
    return this;
  }

  this._findOneAndRemove(callback);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
* - `maxTimeMS`: puts a time limit on the query - requires mongodb &#x3e;= 2.6.0
* - `select`: sets the document fields to return
*
* ####Examples:
*
*     A.<span class="apidocCodeKeywordSpan">findOneAndRemove</span>(conditions, options, callback) // executes
*     A.findOneAndRemove(conditions, options)  // return Query
*     A.findOneAndRemove(conditions, callback) // executes
*     A.findOneAndRemove(conditions) // returns Query
*     A.findOneAndRemove()           // returns Query
*
* Values are cast to their appropriate types when using the findAndModify helpers.
* However, the below are never executed.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.findOneAndUpdate" id="apidoc.element.mongoose.query.prototype.findOneAndUpdate">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>findOneAndUpdate
        <span class="apidocSignatureSpan">(criteria, doc, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findOneAndUpdate = function (criteria, doc, options, callback) {
  this.op = &#x27;findOneAndUpdate&#x27;;
  this._validate();

  switch (arguments.length) {
    case 3:
      if (typeof options === &#x27;function&#x27;) {
        callback = options;
        options = {};
      }
      break;
    case 2:
      if (typeof doc === &#x27;function&#x27;) {
        callback = doc;
        doc = criteria;
        criteria = undefined;
      }
      options = undefined;
      break;
    case 1:
      if (typeof criteria === &#x27;function&#x27;) {
        callback = criteria;
        criteria = options = doc = undefined;
      } else {
        doc = criteria;
        criteria = options = undefined;
      }
  }

  if (mquery.canMerge(criteria)) {
    this.merge(criteria);
  }

  // apply doc
  if (doc) {
    this._mergeUpdate(doc);
  }

  if (options) {
    options = utils.clone(options, { retainKeyOrder: true });
    if (options.projection) {
      this.select(options.projection);
      delete options.projection;
    }
    if (options.fields) {
      this.select(options.fields);
      delete options.fields;
    }

    this.setOptions(options);
  }

  if (!callback) {
    return this;
  }

  return this._findOneAndUpdate(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* Finds a matching document, updates it according to the `update` arg, passing any `options`, and returns the found document (if
 any) to the callback. The query executes immediately if `callback` is passed else a Query object is returned.
*
* ####Options:
*
* - `new`: bool - if true, return the modified document rather than the original. defaults to false (changed in 4.0)
* - `upsert`: bool - creates the object if it doesn&#x27;t exist. defaults to false.
* - `fields`: {Object|String} - Field selection. Equivalent to `.select(fields).<span class="apidocCodeKeywordSpan">findOneAndUpdate
</span>()`
* - `maxTimeMS`: puts a time limit on the query - requires mongodb &#x3e;= 2.6.0
* - `sort`: if multiple docs are found by the conditions, sets the sort order to choose which doc to update
* - `runValidators`: if true, runs [update validators](/docs/validation.html#update-validators) on this command. Update validators
 validate the update operation against the model&#x27;s schema.
* - `setDefaultsOnInsert`: if this and `upsert` are true, mongoose will apply the [defaults](http://mongoosejs.com/docs/defaults
.html) specified in the model&#x27;s schema if a new document is created. This option only works on MongoDB &#x3e;= 2.4 because
it relies on [MongoDB&#x27;s `$setOnInsert` operator](https://docs.mongodb.org/v2.4/reference/operator/update/setOnInsert/).
* - `passRawResult`: if true, passes the [raw result from the MongoDB driver as the third callback parameter](http://mongodb.github
.io/node-mongodb-native/2.0/api/Collection.html#findAndModify)
*
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.getQuery" id="apidoc.element.mongoose.query.prototype.getQuery">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>getQuery
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getQuery = function () {
  return this._conditions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Returns the current query conditions as a JSON object.
 *
 * ####Example:
 *
 *     var query = new Query();
 *     query.find({ a: 1 }).where(&#x27;b&#x27;).gt(2);
 *     query.<span class="apidocCodeKeywordSpan">getQuery</span>(); // { a: 1, b: { $gt: 2 } }
 *
 * @return {Object} current query conditions
 * @api public
 */

Query.prototype.getQuery = function() {
return this._conditions;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.getUpdate" id="apidoc.element.mongoose.query.prototype.getUpdate">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>getUpdate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getUpdate = function () {
  return this._update;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
 * Returns the current update operations as a JSON object.
 *
 * ####Example:
 *
 *     var query = new Query();
 *     query.update({}, { $set: { a: 5 } });
 *     query.<span class="apidocCodeKeywordSpan">getUpdate</span>(); // { $set: { a: 5 } }
 *
 * @return {Object} current update operations
 * @api public
 */

Query.prototype.getUpdate = function() {
return this._update;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.lean" id="apidoc.element.mongoose.query.prototype.lean">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>lean
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">lean = function (v) {
  this._mongooseOptions.lean = arguments.length ? !!v : true;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     // include all properties except for `length`
*     Adventure.findById(id, &#x27;-length&#x27;).exec(function (err, adventure) {});
*
*     // passing options (in this case return the raw js objects, not mongoose documents by passing `lean`
*     Adventure.findById(id, &#x27;name&#x27;, { lean: true }, function (err, doc) {});
*
*     // same as above
*     Adventure.findById(id, &#x27;name&#x27;).<span class="apidocCodeKeywordSpan">lean</span>().exec(function (err, doc) {});
*
* @param {Object|String|Number} id value of `_id` to query by
* @param {Object} [projection] optional fields to return (http://bit.ly/1HotzBo)
* @param {Object} [options] optional
* @param {Function} [callback]
* @return {Query}
* @see field selection #query_Query-select
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.maxscan" id="apidoc.element.mongoose.query.prototype.maxscan">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>maxscan
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">maxscan = function (v) {
  this._validate(method);
  this.options[method] = v;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.merge" id="apidoc.element.mongoose.query.prototype.merge">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>merge
        <span class="apidocSignatureSpan">(source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">merge = function (source) {
  if (!source) {
    return this;
  }

  var opts = { retainKeyOrder: this.options.retainKeyOrder, overwrite: true };

  if (source instanceof Query) {
    // if source has a feature, apply it to ourselves

    if (source._conditions) {
      utils.merge(this._conditions, source._conditions, opts);
    }

    if (source._fields) {
      this._fields || (this._fields = {});
      utils.merge(this._fields, source._fields, opts);
    }

    if (source.options) {
      this.options || (this.options = {});
      utils.merge(this.options, source.options, opts);
    }

    if (source._update) {
      this._update || (this._update = {});
      utils.mergeClone(this._update, source._update);
    }

    if (source._distinct) {
      this._distinct = source._distinct;
    }

    return this;
  }

  // plain object
  utils.merge(this._conditions, source, opts);

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

if (isVirtual &#x26;&#x26; virtual.options &#x26;&#x26; virtual.options.options) {
  currentOptions.options = utils.clone(virtual.options.options, {
    retainKeyOrder: true
  });
}
utils.<span class="apidocCodeKeywordSpan">merge</span>(currentOptions, options);
if (schema &#x26;&#x26; !discriminatorKey) {
  currentOptions.model = Model;
}
options.model = Model;

available[modelName] = {
  Model: Model,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.mongooseOptions" id="apidoc.element.mongoose.query.prototype.mongooseOptions">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>mongooseOptions
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mongooseOptions = function (v) {
  if (arguments.length &#x3e; 0) {
    this._mongooseOptions = v;
  }
  return this._mongooseOptions;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.near" id="apidoc.element.mongoose.query.prototype.near">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>near
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">near = function () {
  var params = [];
  var sphere = this._mongooseOptions.nearSphere;

  // TODO refactor

  if (arguments.length === 1) {
    if (Array.isArray(arguments[0])) {
      params.push({center: arguments[0], spherical: sphere});
    } else if (typeof arguments[0] === &#x27;string&#x27;) {
      // just passing a path
      params.push(arguments[0]);
    } else if (utils.isObject(arguments[0])) {
      if (typeof arguments[0].spherical !== &#x27;boolean&#x27;) {
        arguments[0].spherical = sphere;
      }
      params.push(arguments[0]);
    } else {
      throw new TypeError(&#x27;invalid argument&#x27;);
    }
  } else if (arguments.length === 2) {
    if (typeof arguments[0] === &#x27;number&#x27; &#x26;&#x26; typeof arguments[1] === &#x27;number&#x27;) {
      params.push({center: [arguments[0], arguments[1]], spherical: sphere});
    } else if (typeof arguments[0] === &#x27;string&#x27; &#x26;&#x26; Array.isArray(arguments[1])) {
      params.push(arguments[0]);
      params.push({center: arguments[1], spherical: sphere});
    } else if (typeof arguments[0] === &#x27;string&#x27; &#x26;&#x26; utils.isObject(arguments[1])) {
      params.push(arguments[0]);
      if (typeof arguments[1].spherical !== &#x27;boolean&#x27;) {
        arguments[1].spherical = sphere;
      }
      params.push(arguments[1]);
    } else {
      throw new TypeError(&#x27;invalid argument&#x27;);
    }
  } else if (arguments.length === 3) {
    if (typeof arguments[0] === &#x27;string&#x27; &#x26;&#x26; typeof arguments[1] === &#x27;number&#x27;
        &#x26;&#x26; typeof arguments[2] === &#x27;number&#x27;) {
      params.push(arguments[0]);
      params.push({center: [arguments[1], arguments[2]], spherical: sphere});
    } else {
      throw new TypeError(&#x27;invalid argument&#x27;);
    }
  } else {
    throw new TypeError(&#x27;invalid argument&#x27;);
  }

  return Query.base.near.apply(this, params);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* ####NOTE:
*
* **MUST** be used as the first operator in the pipeline.
*
* ####Examples:
*
*     aggregate.<span class="apidocCodeKeywordSpan">near</span>({
*       near: [40.724, -73.997],
*       distanceField: &#x22;dist.calculated&#x22;, // required
*       maxDistance: 0.008,
*       query: { type: &#x22;public&#x22; },
*       includeLocs: &#x22;dist.location&#x22;,
*       uniqueDocs: true,
*       num: 5
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.nearSphere" id="apidoc.element.mongoose.query.prototype.nearSphere">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>nearSphere
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nearSphere = function () {
  this._mongooseOptions.nearSphere = true;
  this.near.apply(this, arguments);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* _DEPRECATED_ Specifies a `$nearSphere` condition
*
* ####Example
*
*     query.where(&#x27;loc&#x27;).<span class="apidocCodeKeywordSpan">nearSphere</span>({ center: [10, 10], maxDistance: 5 });
*
* **Deprecated.** Use `query.near()` instead with the `spherical` option set to `true`.
*
* ####Example
*
*     query.where(&#x27;loc&#x27;).near({ center: [10, 10], spherical: true });
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.populate" id="apidoc.element.mongoose.query.prototype.populate">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>populate
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">populate = function () {
  if (arguments.length === 0) {
    return this;
  }

  var res = utils.populate.apply(null, arguments);
  var opts = this._mongooseOptions;

  if (!utils.isObject(opts.populate)) {
    opts.populate = {};
  }

  var pop = opts.populate;

  for (var i = 0; i &#x3c; res.length; ++i) {
    var path = res[i].path;
    if (pop[path] &#x26;&#x26; pop[path].populate &#x26;&#x26; res[i].populate) {
      res[i].populate = pop[path].populate.concat(res[i].populate);
    }
    pop[res[i].path] = res[i];
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Populates document references, executing the `callback` when complete.
* If you want to use promises instead, use this function with
* [`execPopulate()`](#document_Document-execPopulate)
*
* ####Example:
*
*     doc
*     .<span class="apidocCodeKeywordSpan">populate</span>(&#x27;company&#x27;)
*     .populate({
*       path: &#x27;notes&#x27;,
*       match: /airline/,
*       select: &#x27;text&#x27;,
*       model: &#x27;modelName&#x27;
*       options: opts
*     }, function (err, user) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.read" id="apidoc.element.mongoose.query.prototype.read">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>read
        <span class="apidocSignatureSpan">(pref, tags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function read(pref, tags) {
  // first cast into a ReadPreference object to support tags
  var read = readPref.call(readPref, pref, tags);
  return Query.base.read.call(this, read);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Sets the readPreference option for the aggregation query.
*
* ####Example:
*
*     Model.aggregate(..).<span class="apidocCodeKeywordSpan">read</span>(&#x27;primaryPreferred&#x27;).exec(callback)
*
* @param {String} pref one of the listed preference options or their aliases
* @param {Array} [tags] optional tags for this query
* @see mongodb http://docs.mongodb.org/manual/applications/replication/#read-preference
* @see driver http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.remove" id="apidoc.element.mongoose.query.prototype.remove">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>remove
        <span class="apidocSignatureSpan">(cond, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (cond, callback) {
  if (typeof cond === &#x27;function&#x27;) {
    callback = cond;
    cond = null;
  }

  var cb = typeof callback === &#x27;function&#x27;;

  try {
    this.cast(this.model);
  } catch (err) {
    if (cb) return process.nextTick(callback.bind(null, err));
    return this;
  }

  return Query.base.remove.call(this, cond, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

The same goes for removing them:

```js
BlogPost.findById(myId, function (err, post) {
  if (!err) {
    post.comments[0].<span class="apidocCodeKeywordSpan">remove</span>();
    post.save(function (err) {
      // do something
    });
  }
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.replaceOne" id="apidoc.element.mongoose.query.prototype.replaceOne">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>replaceOne
        <span class="apidocSignatureSpan">(conditions, doc, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceOne = function (conditions, doc, options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    // .update(conditions, doc, callback)
    callback = options;
    options = null;
  } else if (typeof doc === &#x27;function&#x27;) {
    // .update(doc, callback);
    callback = doc;
    doc = conditions;
    conditions = {};
    options = null;
  } else if (typeof conditions === &#x27;function&#x27;) {
    // .update(callback)
    callback = conditions;
    conditions = undefined;
    doc = undefined;
    options = undefined;
  } else if (typeof conditions === &#x27;object&#x27; &#x26;&#x26; !doc &#x26;&#x26; !options &#x26;&#x26; !callback) {
    // .update(doc)
    doc = conditions;
    conditions = undefined;
    options = undefined;
    callback = undefined;
  }

  this.setOptions({ overwrite: true });
  return _update(this, &#x27;replaceOne&#x27;, conditions, doc, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Query.base.updateOne.call(this, castedQuery, castedDoc, options, callback);
return this;
};

/*!
 * Internal thunk for .<span class="apidocCodeKeywordSpan">replaceOne</span>()
 *
 * @param {Function} callback
 * @see Model.replaceOne #model_Model.replaceOne
 * @api private
 */
Query.prototype._replaceOne = function(callback) {
var schema = this.model.schema;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.setOptions" id="apidoc.element.mongoose.query.prototype.setOptions">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>setOptions
        <span class="apidocSignatureSpan">(options, overwrite)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOptions = function (options, overwrite) {
  // overwrite is only for internal use
  if (overwrite) {
    // ensure that _mongooseOptions &#x26; options are two different objects
    this._mongooseOptions = (options &#x26;&#x26; utils.clone(options)) || {};
    this.options = options || {};

    if (&#x27;populate&#x27; in options) {
      this.populate(this._mongooseOptions);
    }
    return this;
  }

  if (!(options &#x26;&#x26; options.constructor.name === &#x27;Object&#x27;)) {
    return this;
  }

  if (options &#x26;&#x26; Array.isArray(options.populate)) {
    var populate = options.populate;
    delete options.populate;
    var _numPopulate = populate.length;
    for (var i = 0; i &#x3c; _numPopulate; ++i) {
      this.populate(populate[i]);
    }
  }

  return Query.base.setOptions.call(this, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
} else if (typeof options === &#x27;function&#x27;) {
  callback = options;
  options = null;
}

var mq = new this.Query({}, {}, this, this.collection);
mq.select(projection);
mq.<span class="apidocCodeKeywordSpan">setOptions</span>(options);
if (this.schema.discriminatorMapping &#x26;&#x26; mq.selectedInclusively()) {
  mq.select(this.schema.options.discriminatorKey);
}

if (callback) {
  callback = this.$wrapCallback(callback);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.sort" id="apidoc.element.mongoose.query.prototype.sort">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>sort
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sort = function (arg) {
  if (arguments.length &#x3e; 1) {
    throw new Error(&#x27;sort() only takes 1 Argument&#x27;);
  }

  return Query.base.sort.call(this, arg);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* If an object is passed, values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.
*
* If a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path
 name is prefixed with `-` which will be treated as descending.
*
* ####Examples:
*
*     // these are equivalent
*     aggregate.<span class="apidocCodeKeywordSpan">sort</span>({ field: &#x27;asc&#x27;, test: -1 });
*     aggregate.sort(&#x27;field -test&#x27;);
*
* @see $sort http://docs.mongodb.org/manual/reference/aggregation/sort/
* @param {Object|String} arg
* @return {Aggregate} this
* @api public
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.stream" id="apidoc.element.mongoose.query.prototype.stream">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>stream
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deprecated() {
  warned = exports.printDeprecationMessage(msg, warned, deprecated);
  if (new.target) {
    return Reflect.construct(fn, arguments, new.target);
  }
  return fn.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Returns a Node.js 0.8 style [read stream](http://nodejs.org/docs/v0.8.21/api/stream.html#stream_readable_stream) interface.
*
* ####Example
*
*     // follows the nodejs 0.8 stream api
*     Thing.find({ name: /^hello/ }).<span class="apidocCodeKeywordSpan">stream</span>().pipe(res)
*
*     // manual streaming
*     var stream = Thing.find({ name: /^hello/ }).stream();
*
*     stream.on(&#x27;data&#x27;, function (doc) {
*       // do something with the mongoose document
*     }).on(&#x27;error&#x27;, function (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.tailable" id="apidoc.element.mongoose.query.prototype.tailable">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>tailable
        <span class="apidocSignatureSpan">(val, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tailable = function (val, opts) {
  // we need to support the tailable({ awaitdata : true }) as well as the
  // tailable(true, {awaitdata :true}) syntax that mquery does not support
  if (val &#x26;&#x26; val.constructor.name === &#x27;Object&#x27;) {
    opts = val;
    val = true;
  }

  if (val === undefined) {
    val = true;
  }

  if (opts &#x26;&#x26; typeof opts === &#x27;object&#x27;) {
    for (var key in opts) {
      if (key === &#x27;awaitdata&#x27;) {
        // For backwards compatibility
        this.options[key] = !!opts[key];
      } else {
        this.options[key] = opts[key];
      }
    }
  }

  return Query.base.tailable.call(this, val);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Query.prototype.maxscan = Query.base.maxScan;

/**
* Sets the tailable option (for use with capped collections).
*
* ####Example
*
*     query.<span class="apidocCodeKeywordSpan">tailable</span>() // true
*     query.tailable(true)
*     query.tailable(false)
*
* ####Note
*
* Cannot be used with `distinct()`
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.then" id="apidoc.element.mongoose.query.prototype.then">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>then
        <span class="apidocSignatureSpan">(resolve, reject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">then = function (resolve, reject) {
  return this.exec().then(resolve, reject);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* ####Example:
*
*     aggregate.exec(callback);
*
*     // Because a promise is returned, the `callback` is optional.
*     var promise = aggregate.exec();
*     promise.<span class="apidocCodeKeywordSpan">then</span>(..);
*
* @see Promise #promise_Promise
* @param {Function} [callback]
* @return {Promise}
* @api public
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.toConstructor" id="apidoc.element.mongoose.query.prototype.toConstructor">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>toConstructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toConstructor() {
  var model = this.model;
  var coll = this.mongooseCollection;

  var CustomQuery = function(criteria, options) {
    if (!(this instanceof CustomQuery)) {
      return new CustomQuery(criteria, options);
    }
    this._mongooseOptions = utils.clone(p._mongooseOptions);
    Query.call(this, criteria, options || null, model, coll);
  };

  util.inherits(CustomQuery, Query);

  // set inherited defaults
  var p = CustomQuery.prototype;

  p.options = {};

  p.setOptions(this.options);

  p.op = this.op;
  p._conditions = utils.clone(this._conditions, { retainKeyOrder: true });
  p._fields = utils.clone(this._fields);
  p._update = utils.clone(this._update);
  p._path = this._path;
  p._distinct = this._distinct;
  p._collection = this._collection;
  p._mongooseOptions = this._mongooseOptions;

  return CustomQuery;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
*     // Create a query for adventure movies and read from the primary
*     // node in the replica-set unless it is down, in which case we&#x27;ll
*     // read from a secondary node.
*     var query = Movie.find({ tags: &#x27;adventure&#x27; }).read(&#x27;primaryPreferred&#x27;);
*
*     // create a custom Query constructor based off these settings
*     var Adventure = query.<span class="apidocCodeKeywordSpan">toConstructor</span>();
*
*     // Adventure is now a subclass of mongoose.Query and works the same way but with the
*     // default query parameters and options set.
*     Adventure().exec(callback)
*
*     // further narrow down our query results while still using the previous settings
*     Adventure().where({ name: /^Life/ }).exec(callback);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.update" id="apidoc.element.mongoose.query.prototype.update">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>update
        <span class="apidocSignatureSpan">(conditions, doc, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">update = function (conditions, doc, options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    // .update(conditions, doc, callback)
    callback = options;
    options = null;
  } else if (typeof doc === &#x27;function&#x27;) {
    // .update(doc, callback);
    callback = doc;
    doc = conditions;
    conditions = {};
    options = null;
  } else if (typeof conditions === &#x27;function&#x27;) {
    // .update(callback)
    callback = conditions;
    conditions = undefined;
    doc = undefined;
    options = undefined;
  } else if (typeof conditions === &#x27;object&#x27; &#x26;&#x26; !doc &#x26;&#x26; !options &#x26;&#x26; !callback) {
    // .update(doc)
    doc = conditions;
    conditions = undefined;
    options = undefined;
    callback = undefined;
  }

  return _update(this, &#x27;update&#x27;, conditions, doc, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

/**
* Sends an update command with this document `_id` as the query selector.
*
* ####Example:
*
*     weirdCar.<span class="apidocCodeKeywordSpan">update</span>({$inc: {wheels:1}}, { w: 1 }, callback);
*
* ####Valid options:
*
*  - same as in [Model.update](#model_Model.update)
*
* @see Model.update #model_Model.update
* @param {Object} doc
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.updateMany" id="apidoc.element.mongoose.query.prototype.updateMany">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>updateMany
        <span class="apidocSignatureSpan">(conditions, doc, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateMany = function (conditions, doc, options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    // .update(conditions, doc, callback)
    callback = options;
    options = null;
  } else if (typeof doc === &#x27;function&#x27;) {
    // .update(doc, callback);
    callback = doc;
    doc = conditions;
    conditions = {};
    options = null;
  } else if (typeof conditions === &#x27;function&#x27;) {
    // .update(callback)
    callback = conditions;
    conditions = undefined;
    doc = undefined;
    options = undefined;
  } else if (typeof conditions === &#x27;object&#x27; &#x26;&#x26; !doc &#x26;&#x26; !options &#x26;&#x26; !callback) {
    // .update(doc)
    doc = conditions;
    conditions = undefined;
    options = undefined;
    callback = undefined;
  }

  return _update(this, &#x27;updateMany&#x27;, conditions, doc, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Query.base.update.call(this, castedQuery, castedDoc, options, callback);
return this;
};

/*!
 * Internal thunk for .<span class="apidocCodeKeywordSpan">updateMany</span>()
 *
 * @param {Function} callback
 * @see Model.update #model_Model.update
 * @api private
 */
Query.prototype._updateMany = function(callback) {
var schema = this.model.schema;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.query.prototype.updateOne" id="apidoc.element.mongoose.query.prototype.updateOne">
        function <span class="apidocSignatureSpan">mongoose.query.prototype.</span>updateOne
        <span class="apidocSignatureSpan">(conditions, doc, options, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">updateOne = function (conditions, doc, options, callback) {
  if (typeof options === &#x27;function&#x27;) {
    // .update(conditions, doc, callback)
    callback = options;
    options = null;
  } else if (typeof doc === &#x27;function&#x27;) {
    // .update(doc, callback);
    callback = doc;
    doc = conditions;
    conditions = {};
    options = null;
  } else if (typeof conditions === &#x27;function&#x27;) {
    // .update(callback)
    callback = conditions;
    conditions = undefined;
    doc = undefined;
    options = undefined;
  } else if (typeof conditions === &#x27;object&#x27; &#x26;&#x26; !doc &#x26;&#x26; !options &#x26;&#x26; !callback) {
    // .update(doc)
    doc = conditions;
    conditions = undefined;
    options = undefined;
    callback = undefined;
  }

  return _update(this, &#x27;updateOne&#x27;, conditions, doc, options, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

Query.base.updateMany.call(this, castedQuery, castedDoc, options, callback);
return this;
};

/*!
 * Internal thunk for .<span class="apidocCodeKeywordSpan">updateOne</span>()
 *
 * @param {Function} callback
 * @see Model.update #model_Model.update
 * @api private
 */
Query.prototype._updateOne = function(callback) {
var schema = this.model.schema;
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.querycursor" id="apidoc.module.mongoose.querycursor">module mongoose.querycursor</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.querycursor.querycursor" id="apidoc.element.mongoose.querycursor.querycursor">
        function <span class="apidocSignatureSpan">mongoose.</span>querycursor
        <span class="apidocSignatureSpan">(query, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QueryCursor(query, options) {
  Readable.call(this, { objectMode: true });

  this.cursor = null;
  this.query = query;
  this._transforms = options.transform ? [options.transform] : [];
  var _this = this;
  var model = query.model;
  model.hooks.execPre(&#x27;find&#x27;, query, function() {
    model.collection.find(query._conditions, options, function(err, cursor) {
      if (_this._error) {
        cursor.close(function() {});
        _this.listeners(&#x27;error&#x27;).length &#x3e; 0 &#x26;&#x26; _this.emit(&#x27;error&#x27;, _this._error);
      }
      if (err) {
        return _this.emit(&#x27;error&#x27;, err);
      }
      _this.cursor = cursor;
      _this.emit(&#x27;cursor&#x27;, cursor);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.querycursor.super_" id="apidoc.element.mongoose.querycursor.super_">
        function <span class="apidocSignatureSpan">mongoose.querycursor.</span>super_
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Readable(options) {
  if (!(this instanceof Readable))
    return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options &#x26;&#x26; typeof options.read === &#x27;function&#x27;)
    this._read = options.read;

  Stream.call(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.querycursor.prototype" id="apidoc.module.mongoose.querycursor.prototype">module mongoose.querycursor.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.querycursor.prototype._markError" id="apidoc.element.mongoose.querycursor.prototype._markError">
        function <span class="apidocSignatureSpan">mongoose.querycursor.prototype.</span>_markError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_markError = function (error) {
  this._error = error;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (opts) {
    this.setOptions(opts);
  }

  try {
    this.cast(this.model);
  } catch (err) {
    return (new QueryCursor(this, this.options)).<span class="apidocCodeKeywordSpan">_markError</span>(err);
  }

  return new QueryCursor(this, this.options);
};

// the rest of these are basically to support older Mongoose syntax with mquery
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.querycursor.prototype._read" id="apidoc.element.mongoose.querycursor.prototype._read">
        function <span class="apidocSignatureSpan">mongoose.querycursor.prototype.</span>_read
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_read = function () {
  var _this = this;
  _next(this, function(error, doc) {
    if (error) {
      return _this.emit(&#x27;error&#x27;, error);
    }
    if (!doc) {
      _this.push(null);
      _this.cursor.close(function(error) {
        if (error) {
          return _this.emit(&#x27;error&#x27;, error);
        }
        setTimeout(function() {
          _this.emit(&#x27;close&#x27;);
        }, 0);
      });
      return;
    }
    _this.push(doc);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.querycursor.prototype.close" id="apidoc.element.mongoose.querycursor.prototype.close">
        function <span class="apidocSignatureSpan">mongoose.querycursor.prototype.</span>close
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">close = function (callback) {
  var Promise = PromiseProvider.get();
  var _this = this;
  return new Promise.ES6(function(resolve, reject) {
    _this.cursor.close(function(error) {
      if (error) {
        callback &#x26;&#x26; callback(error);
        reject(error);
        return _this.listeners(&#x27;error&#x27;).length &#x3e; 0 &#x26;&#x26;
          _this.emit(&#x27;error&#x27;, error);
      }
      _this.emit(&#x27;close&#x27;);
      resolve();
      callback &#x26;&#x26; callback();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* For practical reasons, a Connection equals a Db.
*
* @param {Mongoose} base a mongoose instance
* @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
* @event `connecting`: Emitted when `connection.{open,openSet}()` is executed on this connection.
* @event `connected`: Emitted when this connection successfully connects to the db. May be emitted _multiple_ times in `reconnected
` scenarios.
* @event `open`: Emitted after we `connected` and `onOpen` is executed on all of this connections models.
* @event `disconnecting`: Emitted when `connection.<span class="apidocCodeKeywordSpan">close</span>()` was executed.
* @event `disconnected`: Emitted after getting disconnected from the db.
* @event `close`: Emitted after we `disconnected` and `onClose` executed on all of this connections models.
* @event `reconnected`: Emitted after we `connected` and subsequently `disconnected`, followed by successfully another successfull
 connection.
* @event `error`: Emitted when an error occurs on this connection.
* @event `fullsetup`: Emitted in a replica-set scenario, when primary and at least one seconaries specified in the connection string
 are connected.
* @event `all`: Emitted in a replica-set scenario, when all nodes specified in the connection string are connected.
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.querycursor.prototype.eachAsync" id="apidoc.element.mongoose.querycursor.prototype.eachAsync">
        function <span class="apidocSignatureSpan">mongoose.querycursor.prototype.</span>eachAsync
        <span class="apidocSignatureSpan">(fn, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachAsync = function (fn, callback) {
  var Promise = PromiseProvider.get();
  var _this = this;

  var handleNextResult = function(doc, callback) {
    var promise = fn(doc);
    if (promise &#x26;&#x26; typeof promise.then === &#x27;function&#x27;) {
      promise.then(
        function() { callback(null); },
        function(error) { callback(error); });
    } else {
      callback(null);
    }
  };

  var iterate = function(callback) {
    return _next(_this, function(error, doc) {
      if (error) {
        return callback(error);
      }
      if (!doc) {
        return callback(null);
      }
      handleNextResult(doc, function(error) {
        if (error) {
          return callback(error);
        }
        // Make sure to clear the stack re: gh-4697
        setTimeout(function() {
          iterate(callback);
        }, 0);
      });
    });
  };

  return new Promise.ES6(function(resolve, reject) {
    iterate(function(error) {
      if (error) {
        callback &#x26;&#x26; callback(error);
        return reject(error);
      }
      callback &#x26;&#x26; callback(null);
      return resolve();
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.querycursor.prototype.map" id="apidoc.element.mongoose.querycursor.prototype.map">
        function <span class="apidocSignatureSpan">mongoose.querycursor.prototype.</span>map
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">map = function (fn) {
  this._transforms.push(fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    val.length &#x3e; 0 &#x26;&#x26;
    val[0] instanceof Document &#x26;&#x26;
    val[0].constructor.modelName &#x26;&#x26;
    (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName
)) {
  if (this.ownerDocument) {
    popOpts = { model: val[0].constructor };
    this.ownerDocument().populated(this.$__fullPath(path),
      val.<span class="apidocCodeKeywordSpan">map</span>(function(v) { return v._id; }), popOpts);
  } else {
    popOpts = { model: val[0].constructor };
    this.populated(path, val.map(function(v) { return v._id; }), popOpts);
  }
  didPopulate = true;
}
val = schema.applySetters(val, this, false, priorVal);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.querycursor.prototype.next" id="apidoc.element.mongoose.querycursor.prototype.next">
        function <span class="apidocSignatureSpan">mongoose.querycursor.prototype.</span>next
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">next = function (callback) {
  var Promise = PromiseProvider.get();
  var _this = this;
  return new Promise.ES6(function(resolve, reject) {
    _next(_this, function(error, doc) {
      if (error) {
        callback &#x26;&#x26; callback(error);
        return reject(error);
      }
      callback &#x26;&#x26; callback(null, doc);
      resolve(doc);
    });
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      function(error) { callback(error); });
  } else {
    callback(null);
  }
};

var iterate = function(callback) {
  return cursor.<span class="apidocCodeKeywordSpan">next</span>(function(error, doc) {
    if (error) {
      return callback(error);
    }
    if (!doc) {
      return callback(null);
    }
    handleNextResult(doc, function(error) {
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.queryhelpers" id="apidoc.module.mongoose.queryhelpers">module mongoose.queryhelpers</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.queryhelpers.applyPaths" id="apidoc.element.mongoose.queryhelpers.applyPaths">
        function <span class="apidocSignatureSpan">mongoose.queryhelpers.</span>applyPaths
        <span class="apidocSignatureSpan">(fields, schema)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function applyPaths(fields, schema) {
  // determine if query is selecting or excluding fields

  var exclude;
  var keys;
  var ki;

  if (fields) {
    keys = Object.keys(fields);
    ki = keys.length;

    while (ki--) {
      if (keys[ki][0] === &#x27;+&#x27;) continue;
      exclude = fields[keys[ki]] === 0;
      break;
    }
  }

  // if selecting, apply default schematype select:true fields
  // if excluding, apply schematype select:false fields

  var selected = [],
      excluded = [],
      seen = [];

  var analyzePath = function(path, type) {
    if (typeof type.selected !== &#x27;boolean&#x27;) return;

    var plusPath = &#x27;+&#x27; + path;
    if (fields &#x26;&#x26; plusPath in fields) {
      // forced inclusion
      delete fields[plusPath];

      // if there are other fields being included, add this one
      // if no other included fields, leave this out (implied inclusion)
      if (exclude === false &#x26;&#x26; keys.length &#x3e; 1 &#x26;&#x26; !~keys.indexOf(path)) {
        fields[path] = 1;
      }

      return;
    }

    // check for parent exclusions
    var root = path.split(&#x27;.&#x27;)[0];
    if (~excluded.indexOf(root)) return;

    (type.selected ? selected : excluded).push(path);
  };

  var analyzeSchema = function(schema, prefix) {
    prefix || (prefix = &#x27;&#x27;);

    // avoid recursion
    if (~seen.indexOf(schema)) return;
    seen.push(schema);

    schema.eachPath(function(path, type) {
      if (prefix) path = prefix + &#x27;.&#x27; + path;

      analyzePath(path, type);

      // array of subdocs?
      if (type.schema) {
        analyzeSchema(type.schema, path);
      }
    });
  };

  analyzeSchema(schema);

  var i;
  switch (exclude) {
    case true:
      for (i = 0; i &#x3c; excluded.length; ++i) {
        fields[excluded[i]] = 0;
      }
      break;
    case false:
      if (schema &#x26;&#x26;
          schema.paths[&#x27;_id&#x27;] &#x26;&#x26;
          schema.paths[&#x27;_id&#x27;].options &#x26;&#x26;
          schema.paths[&#x27;_id&#x27;].options.select === false) {
        fields._id = 0;
      }
      for (i = 0; i &#x3c; selected.length; ++i) {
        fields[selected[i]] = 1;
      }
      break;
    case undefined:
      // user didn&#x27;t specify fields, implies returning all fields.
      // only need to apply excluded fields
      for (i = 0; i &#x3c; excluded.length; ++i) {
        fields[excluded[i]] = 0;
      }
      break;
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Applies schematype selected options to this query.
* @api private
*/

Query.prototype._applyPaths = function applyPaths() {
 this._fields = this._fields || {};
 helpers.<span class="apidocCodeKeywordSpan">applyPaths</span>(this._fields, this.model.schema);
};

/**
* Returns a Node.js 0.8 style [read stream](http://nodejs.org/docs/v0.8.21/api/stream.html#stream_readable_stream) interface.
*
* ####Example
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.queryhelpers.createModel" id="apidoc.element.mongoose.queryhelpers.createModel">
        function <span class="apidocSignatureSpan">mongoose.queryhelpers.</span>createModel
        <span class="apidocSignatureSpan">(model, doc, fields)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createModel(model, doc, fields) {
  var discriminatorMapping = model.schema
    ? model.schema.discriminatorMapping
    : null;

  var key = discriminatorMapping &#x26;&#x26; discriminatorMapping.isRoot
    ? discriminatorMapping.key
    : null;

  if (key &#x26;&#x26; doc[key] &#x26;&#x26; model.discriminators &#x26;&#x26; model.discriminators[doc[key]]) {
    var discriminator = model.discriminators[doc[key]];
    var _fields = utils.clone(fields);
    exports.applyPaths(_fields, discriminator.schema);
    return new model.discriminators[doc[key]](undefined, _fields, true);
  }

  return new model(undefined, fields, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* @param {Object} obj
* @return {Document}
* @api public
*/

Model.hydrate = function(obj) {
 var model = require(&#x27;./queryhelpers&#x27;).<span class="apidocCodeKeywordSpan">createModel</span>(this, obj);
 model.init(obj);
 return model;
};

/**
* Updates one document in the database without returning it.
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.queryhelpers.preparePopulationOptions" id="apidoc.element.mongoose.queryhelpers.preparePopulationOptions">
        function <span class="apidocSignatureSpan">mongoose.queryhelpers.</span>preparePopulationOptions
        <span class="apidocSignatureSpan">(query, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function preparePopulationOptions(query, options) {
  var pop = utils.object.vals(query.options.populate);

  // lean options should trickle through all queries
  if (options.lean) pop.forEach(makeLean);

  return pop;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.queryhelpers.preparePopulationOptionsMQ" id="apidoc.element.mongoose.queryhelpers.preparePopulationOptionsMQ">
        function <span class="apidocSignatureSpan">mongoose.queryhelpers.</span>preparePopulationOptionsMQ
        <span class="apidocSignatureSpan">(query, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function preparePopulationOptionsMQ(query, options) {
  var pop = utils.object.vals(query._mongooseOptions.populate);

  // lean options should trickle through all queries
  if (options.lean) pop.forEach(makeLean);

  return pop;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (!options.populate) {
  return options.lean === true
      ? callback(null, docs)
      : completeMany(_this.model, docs, fields, null, callback);
}

var pop = helpers.<span class="apidocCodeKeywordSpan">preparePopulationOptionsMQ</span>(_this, options);
pop.__noPromise = true;
_this.model.populate(docs, pop, function(err, docs) {
  if (err) return callback(err);
  return options.lean === true
      ? callback(null, docs)
      : completeMany(_this.model, docs, fields, pop, callback);
});
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.querystream" id="apidoc.module.mongoose.querystream">module mongoose.querystream</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.querystream.querystream" id="apidoc.element.mongoose.querystream.querystream">
        function <span class="apidocSignatureSpan">mongoose.</span>querystream
        <span class="apidocSignatureSpan">(query, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function QueryStream(query, options) {
  Stream.call(this);

  this.query = query;
  this.readable = true;
  this.paused = false;
  this._cursor = null;
  this._destroyed = null;
  this._fields = null;
  this._buffer = null;
  this._inline = T_INIT;
  this._running = false;
  this._transform = options &#x26;&#x26; typeof options.transform === &#x27;function&#x27;
      ? options.transform
      : K;

  // give time to hook up events
  var _this = this;
  process.nextTick(function() {
    _this._init();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.querystream.prototype" id="apidoc.module.mongoose.querystream.prototype">module mongoose.querystream.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.querystream.prototype.__next" id="apidoc.element.mongoose.querystream.prototype.__next">
        function <span class="apidocSignatureSpan">mongoose.querystream.prototype.</span>__next
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__next = function () {
  if (this.paused || this._destroyed) {
    this._running = false;
    return this._running;
  }

  var _this = this;
  _this._inline = T_INIT;

  _this._cursor.nextObject(function cursorcb(err, doc) {
    _this._onNextObject(err, doc);
  });

  // if onNextObject() was already called in this tick
  // return ourselves to the trampoline.
  if (T_CONT === this._inline) {
    return true;
  }
  // onNextObject() hasn&#x27;t fired yet. tell onNextObject
  // that its ok to call _next b/c we are not within
  // the trampoline anymore.
  this._inline = T_IDLE;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
   while (!this.paused &#x26;&#x26; !this._destroyed &#x26;&#x26; (arg = this._buffer.shift())) { // eslint-disable-line no-cond
-assign
     this._onNextObject.apply(this, arg);
   }
 }

 // avoid stack overflows with large result sets.
 // trampoline instead of recursion.
 while (this.<span class="apidocCodeKeywordSpan">__next</span>()) {
 }
};

/**
* Pulls the next doc from the cursor.
*
* @see QueryStream#_next #querystream_QueryStream-_next
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.querystream.prototype._init" id="apidoc.element.mongoose.querystream.prototype._init">
        function <span class="apidocSignatureSpan">mongoose.querystream.prototype.</span>_init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_init = function () {
  if (this._destroyed) {
    return;
  }

  var query = this.query,
      model = query.model,
      options = query._optionsForExec(model),
      _this = this;

  try {
    query.cast(model);
  } catch (err) {
    return _this.destroy(err);
  }

  _this._fields = utils.clone(query._fields);
  options.fields = query._castFields(_this._fields);

  model.collection.find(query._conditions, options, function(err, cursor) {
    if (err) {
      return _this.destroy(err);
    }
    _this._cursor = cursor;
    _this._next();
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 this._transform = options &#x26;&#x26; typeof options.transform === &#x27;function&#x27;
     ? options.transform
     : K;

 // give time to hook up events
 var _this = this;
 process.nextTick(function() {
   _this.<span class="apidocCodeKeywordSpan">_init</span>();
 });
}

/*!
* Inherit from Stream
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.querystream.prototype._next" id="apidoc.element.mongoose.querystream.prototype._next">
        function <span class="apidocSignatureSpan">mongoose.querystream.prototype.</span>_next
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _next() {
  if (this.paused || this._destroyed) {
    this._running = false;
    return this._running;
  }

  this._running = true;

  if (this._buffer &#x26;&#x26; this._buffer.length) {
    var arg;
    while (!this.paused &#x26;&#x26; !this._destroyed &#x26;&#x26; (arg = this._buffer.shift())) { // eslint-disable-line no-cond-assign
      this._onNextObject.apply(this, arg);
    }
  }

  // avoid stack overflows with large result sets.
  // trampoline instead of recursion.
  while (this.__next()) {
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 options.fields = query._castFields(_this._fields);

 model.collection.find(query._conditions, options, function(err, cursor) {
   if (err) {
     return _this.destroy(err);
   }
   _this._cursor = cursor;
   _this.<span class="apidocCodeKeywordSpan">_next</span>();
 });
};

/**
* Trampoline for pulling the next doc from cursor.
*
* @see QueryStream#__next #querystream_QueryStream-__next
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.querystream.prototype._onNextObject" id="apidoc.element.mongoose.querystream.prototype._onNextObject">
        function <span class="apidocSignatureSpan">mongoose.querystream.prototype.</span>_onNextObject
        <span class="apidocSignatureSpan">(err, doc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _onNextObject(err, doc) {
  if (this._destroyed) {
    return;
  }

  if (this.paused) {
    this._buffer || (this._buffer = []);
    this._buffer.push([err, doc]);
    this._running = false;
    return this._running;
  }

  if (err) {
    return this.destroy(err);
  }

  // when doc is null we hit the end of the cursor
  if (!doc) {
    this.emit(&#x27;end&#x27;);
    return this.destroy();
  }

  var opts = this.query._mongooseOptions;

  if (!opts.populate) {
    return opts.lean === true ?
        emit(this, doc) :
        createAndEmit(this, null, doc);
  }

  var _this = this;
  var pop = helpers.preparePopulationOptionsMQ(_this.query, _this.query._mongooseOptions);

  // Hack to work around gh-3108
  pop.forEach(function(option) {
    delete option.model;
  });

  pop.__noPromise = true;
  _this.query.model.populate(doc, pop, function(err, doc) {
    if (err) {
      return _this.destroy(err);
    }
    return opts.lean === true ?
        emit(_this, doc) :
        createAndEmit(_this, pop, doc);
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this._running;
}

var _this = this;
_this._inline = T_INIT;

_this._cursor.nextObject(function cursorcb(err, doc) {
  _this.<span class="apidocCodeKeywordSpan">_onNextObject</span>(err, doc);
});

// if onNextObject() was already called in this tick
// return ourselves to the trampoline.
if (T_CONT === this._inline) {
  return true;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.querystream.prototype.destroy" id="apidoc.element.mongoose.querystream.prototype.destroy">
        function <span class="apidocSignatureSpan">mongoose.querystream.prototype.</span>destroy
        <span class="apidocSignatureSpan">(err)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">destroy = function (err) {
  if (this._destroyed) {
    return;
  }
  this._destroyed = true;
  this._running = false;
  this.readable = false;

  if (this._cursor) {
    this._cursor.close();
  }

  if (err) {
    this.emit(&#x27;error&#x27;, err);
  }

  this.emit(&#x27;close&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    model = query.model,
    options = query._optionsForExec(model),
    _this = this;

try {
  query.cast(model);
} catch (err) {
  return _this.<span class="apidocCodeKeywordSpan">destroy</span>(err);
}

_this._fields = utils.clone(query._fields);
options.fields = query._castFields(_this._fields);

model.collection.find(query._conditions, options, function(err, cursor) {
  if (err) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.querystream.prototype.pause" id="apidoc.element.mongoose.querystream.prototype.pause">
        function <span class="apidocSignatureSpan">mongoose.querystream.prototype.</span>pause
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pause = function () {
  this.paused = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.querystream.prototype.resume" id="apidoc.element.mongoose.querystream.prototype.resume">
        function <span class="apidocSignatureSpan">mongoose.querystream.prototype.</span>resume
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resume = function () {
  this.paused = false;

  if (!this._cursor) {
    // cannot start if not initialized
    return;
  }

  // are we within the trampoline?
  if (T_INIT === this._inline) {
    return;
  }

  if (!this._running) {
    // outside QueryStream control, need manual restart
    return this._next();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.schema" id="apidoc.module.mongoose.schema">module mongoose.schema</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.schema.schema" id="apidoc.element.mongoose.schema.schema">
        function <span class="apidocSignatureSpan">mongoose.</span>schema
        <span class="apidocSignatureSpan">(obj, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Schema(obj, options) {
  if (!(this instanceof Schema)) {
    return new Schema(obj, options);
  }

  this.obj = obj;
  this.paths = {};
  this.subpaths = {};
  this.virtuals = {};
  this.singleNestedPaths = {};
  this.nested = {};
  this.inherits = {};
  this.callQueue = [];
  this._indexes = [];
  this.methods = {};
  this.statics = {};
  this.tree = {};
  this.query = {};
  this.childSchemas = [];

  this.s = {
    hooks: new Kareem(),
    kareemHooks: IS_KAREEM_HOOK
  };

  this.options = this.defaultOptions(options);

  // build paths
  if (obj) {
    this.add(obj);
  }

  // check if _id&#x27;s value is a subdocument (gh-2276)
  var _idSubDoc = obj &#x26;&#x26; obj._id &#x26;&#x26; utils.isObject(obj._id);

  // ensure the documents get an auto _id unless disabled
  var auto_id = !this.paths[&#x27;_id&#x27;] &#x26;&#x26;
      (!this.options.noId &#x26;&#x26; this.options._id) &#x26;&#x26; !_idSubDoc;

  if (auto_id) {
    obj = {_id: {auto: true}};
    obj._id[this.options.typeKey] = Schema.ObjectId;
    this.add(obj);
  }

  // ensure the documents receive an id getter unless disabled
  var autoid = !this.paths[&#x27;id&#x27;] &#x26;&#x26;
      (!this.options.noVirtualId &#x26;&#x26; this.options.id);
  if (autoid) {
    this.virtual(&#x27;id&#x27;).get(idGetter);
  }

  for (var i = 0; i &#x3c; this._defaultMiddleware.length; ++i) {
    var m = this._defaultMiddleware[i];
    this[m.kind](m.hook, !!m.isAsync, m.fn);
  }

  if (this.options.timestamps) {
    this.setupTimestamp(this.options.timestamps);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.ObjectId" id="apidoc.element.mongoose.schema.ObjectId">
        function <span class="apidocSignatureSpan">mongoose.schema.</span>ObjectId
        <span class="apidocSignatureSpan">(key, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ObjectId(key, options) {
  SchemaType.call(this, key, options, &#x27;ObjectID&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*     .unwind(&#x27;tags&#x27;)
*     .exec(callback)
*
* ####Note:
*
* - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).
* - Requires MongoDB &#x3e;= 2.1
* - Mongoose does **not** cast pipeline stages. `new Aggregate({ $match: { _id: &#x27;00000000000000000000000a&#x27; } });` will
 not work unless `_id` is a string in the database. Use `new Aggregate({ $match: { _id: mongoose.Types.<span class="apidocCodeKeywordSpan
">ObjectId</span>(&#x27;00000000000000000000000a&#x27;) } });` instead.
*
* @see MongoDB http://docs.mongodb.org/manual/applications/aggregation/
* @see driver http://mongodb.github.com/node-mongodb-native/api-generated/collection.html#aggregate
* @param {Object|Array} [ops] aggregation operator(s) or operator array
* @api public
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.interpretAsType" id="apidoc.element.mongoose.schema.interpretAsType">
        function <span class="apidocSignatureSpan">mongoose.schema.</span>interpretAsType
        <span class="apidocSignatureSpan">(path, obj, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">interpretAsType = function (path, obj, options) {
  if (obj.constructor) {
    var constructorName = utils.getFunctionName(obj.constructor);
    if (constructorName !== &#x27;Object&#x27;) {
      var oldObj = obj;
      obj = {};
      obj[options.typeKey] = oldObj;
    }
  }

  // Get the type making sure to allow keys named &#x22;type&#x22;
  // and default to mixed if not specified.
  // { type: { type: String, default: &#x27;freshcut&#x27; } }
  var type = obj[options.typeKey] &#x26;&#x26; (options.typeKey !== &#x27;type&#x27; || !obj.type.type)
      ? obj[options.typeKey]
      : {};

  if (utils.getFunctionName(type.constructor) === &#x27;Object&#x27; || type === &#x27;mixed&#x27;) {
    return new MongooseTypes.Mixed(path, obj);
  }

  if (Array.isArray(type) || Array === type || type === &#x27;array&#x27;) {
    // if it was specified through { type } look for `cast`
    var cast = (Array === type || type === &#x27;array&#x27;)
        ? obj.cast
        : type[0];

    if (cast &#x26;&#x26; cast.instanceOfSchema) {
      return new MongooseTypes.DocumentArray(path, cast, obj);
    }

    if (Array.isArray(cast)) {
      return new MongooseTypes.Array(path, Schema.interpretAsType(path, cast, options), obj);
    }

    if (typeof cast === &#x27;string&#x27;) {
      cast = MongooseTypes[cast.charAt(0).toUpperCase() + cast.substring(1)];
    } else if (cast &#x26;&#x26; (!cast[options.typeKey] || (options.typeKey === &#x27;type&#x27; &#x26;&#x26; cast.type.type))
        &#x26;&#x26; utils.getFunctionName(cast.constructor) === &#x27;Object&#x27;) {
      if (Object.keys(cast).length) {
        // The `minimize` and `typeKey` options propagate to child schemas
        // declared inline, like `{ arr: [{ val: { $type: String } }] }`.
        // See gh-3560
        var childSchemaOptions = {minimize: options.minimize};
        if (options.typeKey) {
          childSchemaOptions.typeKey = options.typeKey;
        }
        //propagate &#x27;strict&#x27; option to child schema
        if (options.hasOwnProperty(&#x27;strict&#x27;)) {
          childSchemaOptions.strict = options.strict;
        }
        var childSchema = new Schema(cast, childSchemaOptions);
        childSchema.$implicitlyCreated = true;
        return new MongooseTypes.DocumentArray(path, childSchema, obj);
      } else {
        // Special case: empty object becomes mixed
        return new MongooseTypes.Array(path, MongooseTypes.Mixed, obj);
      }
    }

    if (cast) {
      type = cast[options.typeKey] &#x26;&#x26; (options.typeKey !== &#x27;type&#x27; || !cast.type.type)
          ? cast[options.typeKey]
          : cast;

      name = typeof type === &#x27;string&#x27;
          ? type
          : type.schemaName || utils.getFunctionName(type);

      if (!(name in MongooseTypes)) {
        throw new TypeError(&#x27;Undefined type `&#x27; + name + &#x27;` at array `&#x27; + path +
          &#x27;`&#x27;);
      }
    }

    return new MongooseTypes.Array(path, cast || MongooseTypes.Mixed, obj, options);
  }

  if (type &#x26;&#x26; type.instanceOfSchema) {
    return new MongooseTypes.Embedded(type, path, obj);
  }

  var name;
  if (Buffer.isBuffer(type)) {
    name = &#x27;Buffer&#x27;;
  } else {
    name = typeof type === &#x27;string&#x27;
        ? type
      // If not string, `type` is a function. Outside of IE, function.name
      // gives you the function name. In IE, you need to compute it
        : type.schemaName || utils.getFunctionName(type);
  }

  if (name) {
    name = name.charAt(0).toUpperCase() + name.substring(1);
  }

  if (undefined == MongooseTypes[name]) {
    throw new TypeError(&#x27;Undefined type `&#x27; + name + &#x27;` at `&#x27; + path +
        &#x27;`\n  Did you try nesting Schemas? &#x27; +
        &#x27;You can only nest using refs or arrays.&#x27;);
  }

  return new MongooseTypes[name](path, obj);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var strict = options &#x26;&#x26; &#x27;strict&#x27; in options
  ? options.strict
  : this.$__.strictMode;

  if (adhoc) {
adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
adhocs[path] = Schema.<span class="apidocCodeKeywordSpan">interpretAsType</span>(path, type, this.schema.options);
  }

  if (typeof path !== &#x27;string&#x27;) {
// new Document({ key: val })

if (path === null || path === void 0) {
  var _ = path;
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.schema.prototype" id="apidoc.module.mongoose.schema.prototype">module mongoose.schema.prototype</a></h1>




    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype._getPathType" id="apidoc.element.mongoose.schema.prototype._getPathType">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>_getPathType
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getPathType = function (path) {
  var _this = this;
  var pathschema = _this.path(path);

  if (pathschema) {
    return &#x27;real&#x27;;
  }

  function search(parts, schema) {
    var p = parts.length + 1,
        foundschema,
        trypath;

    while (p--) {
      trypath = parts.slice(0, p).join(&#x27;.&#x27;);
      foundschema = schema.path(trypath);
      if (foundschema) {
        if (foundschema.caster) {
          // array of Mixed?
          if (foundschema.caster instanceof MongooseTypes.Mixed) {
            return { schema: foundschema, pathType: &#x27;mixed&#x27; };
          }

          // Now that we found the array, we need to check if there
          // are remaining document paths to look up for casting.
          // Also we need to handle array.$.path since schema.path
          // doesn&#x27;t work for that.
          // If there is no foundschema.schema we are dealing with
          // a path like array.$
          if (p !== parts.length &#x26;&#x26; foundschema.schema) {
            if (parts[p] === &#x27;$&#x27;) {
              if (p === parts.length - 1) {
                return { schema: foundschema, pathType: &#x27;nested&#x27; };
              }
              // comments.$.comments.$.title
              return search(parts.slice(p + 1), foundschema.schema);
            }
            // this is the last path of the selector
            return search(parts.slice(p), foundschema.schema);
          }
          return {
            schema: foundschema,
            pathType: foundschema.$isSingleNested ? &#x27;nested&#x27; : &#x27;array&#x27;
          };
        }
        return { schema: foundschema, pathType: &#x27;real&#x27; };
      } else if (p === parts.length &#x26;&#x26; schema.nested[trypath]) {
        return { schema: schema, pathType: &#x27;nested&#x27; };
      }
    }
    return { schema: foundschema || schema, pathType: &#x27;undefined&#x27; };
  }

  // look for arrays
  return search(path.split(&#x27;.&#x27;), _this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype._getSchema" id="apidoc.element.mongoose.schema.prototype._getSchema">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>_getSchema
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getSchema = function (path) {
  var _this = this;
  var pathschema = _this.path(path);
  var resultPath = [];

  if (pathschema) {
    pathschema.$fullPath = path;
    return pathschema;
  }

  function search(parts, schema) {
    var p = parts.length + 1,
        foundschema,
        trypath;

    while (p--) {
      trypath = parts.slice(0, p).join(&#x27;.&#x27;);
      foundschema = schema.path(trypath);
      if (foundschema) {
        resultPath.push(trypath);

        if (foundschema.caster) {
          // array of Mixed?
          if (foundschema.caster instanceof MongooseTypes.Mixed) {
            foundschema.caster.$fullPath = resultPath.join(&#x27;.&#x27;);
            return foundschema.caster;
          }

          // Now that we found the array, we need to check if there
          // are remaining document paths to look up for casting.
          // Also we need to handle array.$.path since schema.path
          // doesn&#x27;t work for that.
          // If there is no foundschema.schema we are dealing with
          // a path like array.$
          if (p !== parts.length &#x26;&#x26; foundschema.schema) {
            var ret;
            if (parts[p] === &#x27;$&#x27;) {
              // comments.$.comments.$.title
              ret = search(parts.slice(p + 1), foundschema.schema);
              if (ret) {
                ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||
                  !foundschema.schema.$isSingleNested;
              }
              return ret;
            }
            // this is the last path of the selector
            ret = search(parts.slice(p), foundschema.schema);
            if (ret) {
              ret.$isUnderneathDocArray = ret.$isUnderneathDocArray ||
                !foundschema.schema.$isSingleNested;
            }
            return ret;
          }
        }

        foundschema.$fullPath = resultPath.join(&#x27;.&#x27;);

        return foundschema;
      }
    }
  }

  // look for arrays
  return search(path.split(&#x27;.&#x27;), _this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    modelNameFromQuery = options.model &#x26;&#x26; options.model.modelName || options.model,
    schema, refPath, Model, currentOptions, modelNames, modelName, discriminatorKey, modelForFindSchema;

var originalModel = options.model;
var isVirtual = false;
var isRefPathArray = false;

schema = model.<span class="apidocCodeKeywordSpan">_getSchema</span>(options.path);
var isUnderneathDocArray = schema &#x26;&#x26; schema.$isUnderneathDocArray;
if (isUnderneathDocArray &#x26;&#x26;
    options &#x26;&#x26;
    options.options &#x26;&#x26;
    options.options.sort) {
  return new Error(&#x27;Cannot populate with `sort` on path &#x27; + options.path +
    &#x27; because it is a subproperty of a document array&#x27;);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype._getVirtual" id="apidoc.element.mongoose.schema.prototype._getVirtual">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>_getVirtual
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_getVirtual = function (name) {
  return _getVirtual(this, name);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  function setValue(val) {
return valueFilter(val, options);
  }

  for (var i = 0; i &#x3c; docs.length; ++i) {
if (utils.getValue(o.path, docs[i]) == null &#x26;&#x26;
  !o.originalModel.schema.<span class="apidocCodeKeywordSpan">_getVirtual</span>(o.path)) {
  continue;
}

if (o.isVirtual &#x26;&#x26; !o.justOne &#x26;&#x26; !Array.isArray(rawIds[i])) {
  rawIds[i] = [rawIds[i]];
}
utils.setValue(o.path, rawIds[i], docs[i], setValue);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.add" id="apidoc.element.mongoose.schema.prototype.add">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>add
        <span class="apidocSignatureSpan">(obj, prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function add(obj, prefix) {
  prefix = prefix || &#x27;&#x27;;
  var keys = Object.keys(obj);

  for (var i = 0; i &#x3c; keys.length; ++i) {
    var key = keys[i];

    if (obj[key] == null) {
      throw new TypeError(&#x27;Invalid value for schema path `&#x27; + prefix + key + &#x27;`&#x27;);
    }

    if (Array.isArray(obj[key]) &#x26;&#x26; obj[key].length === 1 &#x26;&#x26; obj[key][0] == null) {
      throw new TypeError(&#x27;Invalid value for schema Array path `&#x27; + prefix + key + &#x27;`&#x27;);
    }

    if (utils.isObject(obj[key]) &#x26;&#x26;
        (!obj[key].constructor || utils.getFunctionName(obj[key].constructor) === &#x27;Object&#x27;) &#x26;&#x26;
        (!obj[key][this.options.typeKey] || (this.options.typeKey === &#x27;type&#x27; &#x26;&#x26; obj[key].type.type))) {
      if (Object.keys(obj[key]).length) {
        // nested object { last: { name: String }}
        this.nested[prefix + key] = true;
        this.add(obj[key], prefix + key + &#x27;.&#x27;);
      } else {
        if (prefix) {
          this.nested[prefix.substr(0, prefix.length - 1)] = true;
        }
        this.path(prefix + key, obj[key]); // mixed type
      }
    } else {
      if (prefix) {
        this.nested[prefix.substr(0, prefix.length - 1)] = true;
      }
      this.path(prefix + key, obj[key]);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Adds a discriminator type.
*
* ####Example:
*
*     function BaseSchema() {
*       Schema.apply(this, arguments);
*
*       this.<span class="apidocCodeKeywordSpan">add</span>({
*         name: String,
*         createdAt: Date
*       });
*     }
*     util.inherits(BaseSchema, Schema);
*
*     var PersonSchema = new BaseSchema();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.clone" id="apidoc.element.mongoose.schema.prototype.clone">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>clone
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clone = function () {
  var s = new Schema(this.obj, this.options);
  // Clone the call queue
  s.callQueue = this.callQueue.map(function(f) { return f; });
  s.methods = utils.clone(this.methods);
  s.statics = utils.clone(this.statics);
  return s;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Aggregate.prototype.exec = function(callback) {
if (!this._model) {
  throw new Error(&#x27;Aggregate not bound to any Model&#x27;);
}
var _this = this;
var Promise = PromiseProvider.get();
var options = utils.<span class="apidocCodeKeywordSpan">clone</span>(this.options);

if (options &#x26;&#x26; options.cursor) {
  if (options.cursor.async) {
    delete options.cursor.async;
    return new Promise.ES6(function(resolve) {
      if (!_this._model.collection.buffer) {
        process.nextTick(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.constructor" id="apidoc.element.mongoose.schema.prototype.constructor">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>constructor
        <span class="apidocSignatureSpan">(obj, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function Schema(obj, options) {
  if (!(this instanceof Schema)) {
    return new Schema(obj, options);
  }

  this.obj = obj;
  this.paths = {};
  this.subpaths = {};
  this.virtuals = {};
  this.singleNestedPaths = {};
  this.nested = {};
  this.inherits = {};
  this.callQueue = [];
  this._indexes = [];
  this.methods = {};
  this.statics = {};
  this.tree = {};
  this.query = {};
  this.childSchemas = [];

  this.s = {
    hooks: new Kareem(),
    kareemHooks: IS_KAREEM_HOOK
  };

  this.options = this.defaultOptions(options);

  // build paths
  if (obj) {
    this.add(obj);
  }

  // check if _id&#x27;s value is a subdocument (gh-2276)
  var _idSubDoc = obj &#x26;&#x26; obj._id &#x26;&#x26; utils.isObject(obj._id);

  // ensure the documents get an auto _id unless disabled
  var auto_id = !this.paths[&#x27;_id&#x27;] &#x26;&#x26;
      (!this.options.noId &#x26;&#x26; this.options._id) &#x26;&#x26; !_idSubDoc;

  if (auto_id) {
    obj = {_id: {auto: true}};
    obj._id[this.options.typeKey] = Schema.ObjectId;
    this.add(obj);
  }

  // ensure the documents receive an id getter unless disabled
  var autoid = !this.paths[&#x27;id&#x27;] &#x26;&#x26;
      (!this.options.noVirtualId &#x26;&#x26; this.options.id);
  if (autoid) {
    this.virtual(&#x27;id&#x27;).get(idGetter);
  }

  for (var i = 0; i &#x3c; this._defaultMiddleware.length; ++i) {
    var m = this._defaultMiddleware[i];
    this[m.kind](m.hook, !!m.isAsync, m.fn);
  }

  if (this.options.timestamps) {
    this.setupTimestamp(this.options.timestamps);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (obj.constructor) {
  switch (exports.getFunctionName(obj.constructor)) {
    case &#x27;Object&#x27;:
      return cloneObject(obj, options);
    case &#x27;Date&#x27;:
      return new obj.<span class="apidocCodeKeywordSpan">constructor</span>(+obj);
    case &#x27;RegExp&#x27;:
      return cloneRegExp(obj);
    default:
      // ignore
      break;
  }
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.defaultOptions" id="apidoc.element.mongoose.schema.prototype.defaultOptions">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>defaultOptions
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">defaultOptions = function (options) {
  if (options &#x26;&#x26; options.safe === false) {
    options.safe = {w: 0};
  }

  if (options &#x26;&#x26; options.safe &#x26;&#x26; options.safe.w === 0) {
    // if you turn off safe writes, then versioning goes off as well
    options.versionKey = false;
  }

  options = utils.options({
    strict: true,
    bufferCommands: true,
    capped: false, // { size, max, autoIndexId }
    versionKey: &#x27;__v&#x27;,
    discriminatorKey: &#x27;__t&#x27;,
    minimize: true,
    autoIndex: null,
    shardKey: null,
    read: null,
    validateBeforeSave: true,
    // the following are only applied at construction time
    noId: false, // deprecated, use { _id: false }
    _id: true,
    noVirtualId: false, // deprecated, use { id: false }
    id: true,
    typeKey: &#x27;type&#x27;,
    retainKeyOrder: false
  }, options);

  if (options.read) {
    options.read = readPref(options.read);
  }

  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
this.childSchemas = [];

this.s = {
  hooks: new Kareem(),
  kareemHooks: IS_KAREEM_HOOK
};

this.options = this.<span class="apidocCodeKeywordSpan">defaultOptions</span>(options);

// build paths
if (obj) {
  this.add(obj);
}

// check if _id&#x27;s value is a subdocument (gh-2276)
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.eachPath" id="apidoc.element.mongoose.schema.prototype.eachPath">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>eachPath
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">eachPath = function (fn) {
  var keys = Object.keys(this.paths),
      len = keys.length;

  for (var i = 0; i &#x3c; len; ++i) {
    fn(keys[i], this.paths[keys[i]]);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var analyzeSchema = function(schema, prefix) {
    prefix || (prefix = &#x27;&#x27;);

    // avoid recursion
    if (~seen.indexOf(schema)) return;
    seen.push(schema);

    schema.<span class="apidocCodeKeywordSpan">eachPath</span>(function(path, type) {
if (prefix) path = prefix + &#x27;.&#x27; + path;

analyzePath(path, type);

// array of subdocs?
if (type.schema) {
  analyzeSchema(type.schema, path);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.get" id="apidoc.element.mongoose.schema.prototype.get">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>get
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (key) {
  return this.options[key];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// a setter
Comment.path(&#x27;name&#x27;).set(function (v) {
  return capitalize(v);
});

// middleware
Comment.pre(&#x27;save&#x27;, function (next) {
  notify(this.<span class="apidocCodeKeywordSpan">get</span>(&#x27;email&#x27;));
  next();
});
```

Take a look at the example in `examples/schema.js` for an end-to-end example of a typical setup.

### Accessing a Model
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.hasMixedParent" id="apidoc.element.mongoose.schema.prototype.hasMixedParent">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>hasMixedParent
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasMixedParent = function (path) {
  var subpaths = path.split(/\./g);
  path = &#x27;&#x27;;
  for (var i = 0; i &#x3c; subpaths.length; ++i) {
    path = i &#x3e; 0 ? path + &#x27;.&#x27; + subpaths[i] : subpaths[i];
    if (path in this.paths &#x26;&#x26;
        this.paths[path] instanceof MongooseTypes.Mixed) {
      return true;
    }
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.index" id="apidoc.element.mongoose.schema.prototype.index">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>index
        <span class="apidocSignatureSpan">(fields, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">index = function (fields, options) {
  options || (options = {});

  if (options.expires) {
    utils.expires(options);
  }

  this._indexes.push([fields, options]);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Defines an index (most likely compound) for this schema.
*
* ####Example
*
*     schema.<span class="apidocCodeKeywordSpan">index</span>({ first: 1, last: -1 })
*
* @param {Object} fields
* @param {Object} [options] Options to pass to [MongoDB driver&#x27;s `createIndex()` function](http://mongodb.github.io/node-mongodb
-native/2.0/api/Collection.html#createIndex)
* @param {String} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert
 `expires` option into seconds for the `expireAfterSeconds` in the above link.
* @api public
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.indexedPaths" id="apidoc.element.mongoose.schema.prototype.indexedPaths">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>indexedPaths
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function indexedPaths() {
  if (this._indexedpaths) {
    return this._indexedpaths;
  }
  this._indexedpaths = this.indexes();
  return this._indexedpaths;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.indexes" id="apidoc.element.mongoose.schema.prototype.indexes">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>indexes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">indexes = function () {
  &#x27;use strict&#x27;;

  var indexes = [];
  var seenPrefix = {};

  var collectIndexes = function(schema, prefix) {
    if (seenPrefix[prefix]) {
      return;
    }
    seenPrefix[prefix] = true;

    prefix = prefix || &#x27;&#x27;;
    var key, path, index, field, isObject, options, type;
    var keys = Object.keys(schema.paths);

    for (var i = 0; i &#x3c; keys.length; ++i) {
      key = keys[i];
      path = schema.paths[key];

      if ((path instanceof MongooseTypes.DocumentArray) || path.$isSingleNested) {
        collectIndexes(path.schema, key + &#x27;.&#x27;);
      } else {
        index = path._index;

        if (index !== false &#x26;&#x26; index !== null &#x26;&#x26; index !== undefined) {
          field = {};
          isObject = utils.isObject(index);
          options = isObject ? index : {};
          type = typeof index === &#x27;string&#x27; ? index :
              isObject ? index.type :
                  false;

          if (type &#x26;&#x26; ~Schema.indexTypes.indexOf(type)) {
            field[prefix + key] = type;
          } else if (options.text) {
            field[prefix + key] = &#x27;text&#x27;;
            delete options.text;
          } else {
            field[prefix + key] = 1;
          }

          delete options.type;
          if (!(&#x27;background&#x27; in options)) {
            options.background = true;
          }

          indexes.push([field, options]);
        }
      }
    }

    if (prefix) {
      fixSubIndexPaths(schema, prefix);
    } else {
      schema._indexes.forEach(function(index) {
        if (!(&#x27;background&#x27; in index[1])) {
          index[1].background = true;
        }
      });
      indexes = indexes.concat(schema._indexes);
    }
  };

  collectIndexes(this);
  return indexes;

<span class="apidocCodeCommentSpan">  /*!
   * Checks for indexes added to subdocs using Schema.index().
   * These indexes need their paths prefixed properly.
   *
   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]
   */
</span>
  function fixSubIndexPaths(schema, prefix) {
    var subindexes = schema._indexes,
        len = subindexes.length,
        indexObj,
        newindex,
        klen,
        keys,
        key,
        i = 0,
        j;

    for (i = 0; i &#x3c; len; ++i) {
      indexObj = subindexes[i][0];
      keys = Object.keys(indexObj);
      klen = keys.length;
      newindex = {};

      // use forward iteration, order matters
      for (j = 0; j &#x3c; klen; ++j) {
        key = keys[j];
        newindex[prefix + key] = indexObj[key];
      }

      indexes.push([newindex, subindexes[i][1]]);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    callback &#x26;&#x26; callback();
    resolve();
  });
});
};

function _ensureIndexes(model, options, callback) {
var indexes = model.schema.<span class="apidocCodeKeywordSpan">indexes</span>();
if (!indexes.length) {
  setImmediate(function() {
    callback &#x26;&#x26; callback();
  });
  return;
}
// Indexes are created one-by-one to support how MongoDB &#x3c; 2.4 deals
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.loadClass" id="apidoc.element.mongoose.schema.prototype.loadClass">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>loadClass
        <span class="apidocSignatureSpan">(model, virtualsOnly)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadClass = function (model, virtualsOnly) {
  if (model === Object.prototype ||
      model === Function.prototype ||
      model.prototype.hasOwnProperty(&#x27;$isMongooseModelPrototype&#x27;)) {
    return this;
  }

  // Add static methods
  if (!virtualsOnly) {
    Object.getOwnPropertyNames(model).forEach(function(name) {
      if (name.match(/^(length|name|prototype)$/)) {
        return;
      }
      var method = Object.getOwnPropertyDescriptor(model, name);
      if (typeof method.value === &#x27;function&#x27;) this.static(name, method.value);
    }, this);
  }

  // Add methods and virtuals
  Object.getOwnPropertyNames(model.prototype).forEach(function(name) {
    if (name.match(/^(constructor)$/)) {
      return;
    }
    var method = Object.getOwnPropertyDescriptor(model.prototype, name);
    if (!virtualsOnly) {
      if (typeof method.value === &#x27;function&#x27;) {
        this.method(name, method.value);
      }
    }
    if (typeof method.get === &#x27;function&#x27;) {
      this.virtual(name).get(method.get);
    }
    if (typeof method.set === &#x27;function&#x27;) {
      this.virtual(name).set(method.set);
    }
  }, this);

  return (this.loadClass(Object.getPrototypeOf(model)));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  schema.add(o);
}

var model;
if (typeof name === &#x27;function&#x27; &#x26;&#x26; name.prototype instanceof Model) {
  model = name;
  name = model.name;
  schema.<span class="apidocCodeKeywordSpan">loadClass</span>(model, true);
  model.prototype.$isMongooseModelPrototype = true;
} else {
  // generate new class
  model = function model(doc, fields, skipId) {
    if (!(this instanceof model)) {
      return new model(doc, fields, skipId);
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.method" id="apidoc.element.mongoose.schema.prototype.method">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>method
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">method = function (name, fn) {
  if (typeof name !== &#x27;string&#x27;) {
    for (var i in name) {
      this.methods[i] = name[i];
    }
  } else {
    this.methods[name] = fn;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/**
* Adds an instance method to documents constructed from Models compiled from this schema.
*
* ####Example
*
*     var schema = kittySchema = new Schema(..);
*
*     schema.<span class="apidocCodeKeywordSpan">method</span>(&#x27;meow&#x27;, function () {
*       console.log(&#x27;meeeeeoooooooooooow&#x27;);
*     })
*
*     var Kitty = mongoose.model(&#x27;Kitty&#x27;, schema);
*
*     var fizz = new Kitty;
*     fizz.meow(); // meeeeeooooooooooooow
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.path" id="apidoc.element.mongoose.schema.prototype.path">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>path
        <span class="apidocSignatureSpan">(path, obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">path = function (path, obj) {
  if (obj === undefined) {
    if (this.paths[path]) {
      return this.paths[path];
    }
    if (this.subpaths[path]) {
      return this.subpaths[path];
    }
    if (this.singleNestedPaths[path]) {
      return this.singleNestedPaths[path];
    }

    // subpaths?
    return /\.\d+\.?.*$/.test(path)
        ? getPositionalPath(this, path)
        : undefined;
  }

  // some path names conflict with document methods
  if (reserved[path]) {
    throw new Error(&#x27;`&#x27; + path + &#x27;` may not be used as a schema pathname&#x27;);
  }

  if (warnings[path]) {
    console.log(&#x27;WARN: &#x27; + warnings[path]);
  }

  // update the tree
  var subpaths = path.split(/\./),
      last = subpaths.pop(),
      branch = this.tree;

  subpaths.forEach(function(sub, i) {
    if (!branch[sub]) {
      branch[sub] = {};
    }
    if (typeof branch[sub] !== &#x27;object&#x27;) {
      var msg = &#x27;Cannot set nested path `&#x27; + path + &#x27;`. &#x27;
          + &#x27;Parent path `&#x27;
          + subpaths.slice(0, i).concat([sub]).join(&#x27;.&#x27;)
          + &#x27;` already set to type &#x27; + branch[sub].name
          + &#x27;.&#x27;;
      throw new Error(msg);
    }
    branch = branch[sub];
  });

  branch[last] = utils.clone(obj);

  this.paths[path] = Schema.interpretAsType(path, obj, this.options);

  if (this.paths[path].$isSingleNested) {
    for (var key in this.paths[path].schema.paths) {
      this.singleNestedPaths[path + &#x27;.&#x27; + key] =
          this.paths[path].schema.paths[key];
    }
    for (key in this.paths[path].schema.singleNestedPaths) {
      this.singleNestedPaths[path + &#x27;.&#x27; + key] =
          this.paths[path].schema.singleNestedPaths[key];
    }

    this.childSchemas.push(this.paths[path].schema);
  } else if (this.paths[path].$isMongooseDocumentArray) {
    this.childSchemas.push(this.paths[path].schema);
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
age: { type: Number, min: 18, index: true },
bio: { type: String, match: /[a-z]/ },
date: { type: Date, default: Date.now },
buff: Buffer
});

// a setter
Comment.<span class="apidocCodeKeywordSpan">path</span>(&#x27;name&#x27;).set(function (v) {
return capitalize(v);
});

// middleware
Comment.pre(&#x27;save&#x27;, function (next) {
notify(this.get(&#x27;email&#x27;));
next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.pathType" id="apidoc.element.mongoose.schema.prototype.pathType">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>pathType
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pathType = function (path) {
  if (path in this.paths) {
    return &#x27;real&#x27;;
  }
  if (path in this.virtuals) {
    return &#x27;virtual&#x27;;
  }
  if (path in this.nested) {
    return &#x27;nested&#x27;;
  }
  if (path in this.subpaths) {
    return &#x27;real&#x27;;
  }
  if (path in this.singleNestedPaths) {
    return &#x27;real&#x27;;
  }

  if (/\.\d+\.|\.\d+$/.test(path)) {
    return getPositionalPathType(this, path);
  }
  return &#x27;adhocOrUndefined&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  return this;
}
  }

  function _handleIndex(i) {
key = keys[i];
var pathName = prefix + key;
pathtype = this.schema.<span class="apidocCodeKeywordSpan">pathType</span>(pathName);

if (path[key] !== null
    &#x26;&#x26; path[key] !== void 0
      // need to know if plain object - no Buffer, ObjectId, ref, etc
    &#x26;&#x26; utils.isObject(path[key])
    &#x26;&#x26; (!path[key].constructor || utils.getFunctionName(path[key].constructor) === &#x27;Object&#x27;)
    &#x26;&#x26; pathtype !== &#x27;virtual&#x27;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.plugin" id="apidoc.element.mongoose.schema.prototype.plugin">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>plugin
        <span class="apidocSignatureSpan">(fn, opts)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">plugin = function (fn, opts) {
  fn(this, opts);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.post" id="apidoc.element.mongoose.schema.prototype.post">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>post
        <span class="apidocSignatureSpan">(method, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">post = function (method, fn) {
  if (IS_KAREEM_HOOK[method]) {
    this.s.hooks.post.apply(this.s.hooks, arguments);
    return this;
  }
  // assuming that all callbacks with arity &#x3c; 2 are synchronous post hooks
  if (fn.length &#x3c; 2) {
    return this.queue(&#x27;on&#x27;, [arguments[0], function(doc) {
      return fn.call(doc, doc);
    }]);
  }

  if (fn.length === 3) {
    this.s.hooks.post(method + &#x27;:error&#x27;, fn);
    return this;
  }

  return this.queue(&#x27;post&#x27;, [arguments[0], function(next) {
    // wrap original function so that the callback goes last,
    // for compatibility with old code that is using synchronous post hooks
    var _this = this;
    var args = Array.prototype.slice.call(arguments, 1);
    fn.call(this, this, function(err) {
      return next.apply(_this, [err].concat(args));
    });
  }]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 return this.queue(&#x27;pre&#x27;, arguments);
};

/**
* Defines a post hook for the document
*
*     var schema = new Schema(..);
*     schema.<span class="apidocCodeKeywordSpan">post</span>(&#x27;save&#x27;, function (doc) {
*       console.log(&#x27;this fired after a document was saved&#x27;);
*     });
*
*     shema.post(&#x27;find&#x27;, function(docs) {
*       console.log(&#x27;this fired after you run a find query&#x27;);
*     });
*
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.pre" id="apidoc.element.mongoose.schema.prototype.pre">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>pre
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pre = function () {
  var name = arguments[0];
  if (IS_KAREEM_HOOK[name]) {
    this.s.hooks.pre.apply(this.s.hooks, arguments);
    return this;
  }
  return this.queue(&#x27;pre&#x27;, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

// a setter
Comment.path(&#x27;name&#x27;).set(function (v) {
  return capitalize(v);
});

// middleware
Comment.<span class="apidocCodeKeywordSpan">pre</span>(&#x27;save&#x27;, function (next) {
  notify(this.get(&#x27;email&#x27;));
  next();
});
```

Take a look at the example in `examples/schema.js` for an end-to-end example of a typical setup.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.queue" id="apidoc.element.mongoose.schema.prototype.queue">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>queue
        <span class="apidocSignatureSpan">(name, args)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">queue = function (name, args) {
  this.callQueue.push([name, args]);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Schema.prototype.pre = function() {
 var name = arguments[0];
 if (IS_KAREEM_HOOK[name]) {
   this.s.hooks.pre.apply(this.s.hooks, arguments);
   return this;
 }
 return this.<span class="apidocCodeKeywordSpan">queue</span>(&#x27;pre&#x27;, arguments);
};

/**
* Defines a post hook for the document
*
*     var schema = new Schema(..);
*     schema.post(&#x27;save&#x27;, function (doc) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.remove" id="apidoc.element.mongoose.schema.prototype.remove">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>remove
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (path) {
  if (typeof path === &#x27;string&#x27;) {
    path = [path];
  }
  if (Array.isArray(path)) {
    path.forEach(function(name) {
      if (this.path(name)) {
        delete this.paths[name];

        var pieces = name.split(&#x27;.&#x27;);
        var last = pieces.pop();
        var branch = this.tree;
        for (var i = 0; i &#x3c; pieces.length; ++i) {
          branch = branch[pieces[i]];
        }
        delete branch[last];
      }
    }, this);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

The same goes for removing them:

```js
BlogPost.findById(myId, function (err, post) {
  if (!err) {
    post.comments[0].<span class="apidocCodeKeywordSpan">remove</span>();
    post.save(function (err) {
      // do something
    });
  }
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.requiredPaths" id="apidoc.element.mongoose.schema.prototype.requiredPaths">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>requiredPaths
        <span class="apidocSignatureSpan">(invalidate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function requiredPaths(invalidate) {
  if (this._requiredpaths &#x26;&#x26; !invalidate) {
    return this._requiredpaths;
  }

  var paths = Object.keys(this.paths),
      i = paths.length,
      ret = [];

  while (i--) {
    var path = paths[i];
    if (this.paths[path].isRequired) {
      ret.push(path);
    }
  }
  this._requiredpaths = ret;
  return this._requiredpaths;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.$__.strictMode = fields;
  fields = undefined;
} else {
  this.$__.strictMode = this.schema.options &#x26;&#x26; this.schema.options.strict;
  this.$__.selected = fields;
}

var required = this.schema.<span class="apidocCodeKeywordSpan">requiredPaths</span>();
for (var i = 0; i &#x3c; required.length; ++i) {
  this.$__.activePaths.require(required[i]);
}

this.$__.emitter.setMaxListeners(0);
this._doc = this.$__buildDoc(obj, fields, skipId);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.set" id="apidoc.element.mongoose.schema.prototype.set">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>set
        <span class="apidocSignatureSpan">(key, value, _tags)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (key, value, _tags) {
  if (arguments.length === 1) {
    return this.options[key];
  }

  switch (key) {
    case &#x27;read&#x27;:
      this.options[key] = readPref(value, _tags);
      break;
    case &#x27;safe&#x27;:
      this.options[key] = value === false
          ? {w: 0}
          : value;
      break;
    case &#x27;timestamps&#x27;:
      this.setupTimestamp(value);
      this.options[key] = value;
      break;
    default:
      this.options[key] = value;
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
age: { type: Number, min: 18, index: true },
bio: { type: String, match: /[a-z]/ },
date: { type: Date, default: Date.now },
buff: Buffer
});

// a setter
Comment.path(&#x27;name&#x27;).<span class="apidocCodeKeywordSpan">set</span>(function (v) {
return capitalize(v);
});

// middleware
Comment.pre(&#x27;save&#x27;, function (next) {
notify(this.get(&#x27;email&#x27;));
next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.setupTimestamp" id="apidoc.element.mongoose.schema.prototype.setupTimestamp">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>setupTimestamp
        <span class="apidocSignatureSpan">(timestamps)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setupTimestamp = function (timestamps) {
  if (timestamps) {
    var createdAt = timestamps.createdAt || &#x27;createdAt&#x27;;
    var updatedAt = timestamps.updatedAt || &#x27;updatedAt&#x27;;
    var schemaAdditions = {};

    var parts = createdAt.split(&#x27;.&#x27;);
    var i;
    var cur = schemaAdditions;
    for (i = 0; i &#x3c; parts.length; ++i) {
      cur[parts[i]] = (i &#x3c; parts.length - 1 ?
        cur[parts[i]] || {} :
        Date);
    }

    parts = updatedAt.split(&#x27;.&#x27;);
    cur = schemaAdditions;
    for (i = 0; i &#x3c; parts.length; ++i) {
      cur[parts[i]] = (i &#x3c; parts.length - 1 ?
        cur[parts[i]] || {} :
        Date);
    }

    this.add(schemaAdditions);

    this.pre(&#x27;save&#x27;, function(next) {
      var defaultTimestamp = new Date();
      var auto_id = this._id &#x26;&#x26; this._id.auto;

      if (!this.get(createdAt) &#x26;&#x26; this.isSelected(createdAt)) {
        this.set(createdAt, auto_id ? this._id.getTimestamp() : defaultTimestamp);
      }

      if (this.isNew || this.isModified()) {
        this.set(updatedAt, this.isNew ? this.get(createdAt) : defaultTimestamp);
      }

      next();
    });

    var genUpdates = function(currentUpdate, overwrite) {
      var now = new Date();
      var updates = {};
      if (overwrite) {
        if (!currentUpdate[updatedAt]) {
          updates[updatedAt] = now;
        }
        if (!currentUpdate[createdAt]) {
          updates[createdAt] = now;
        }
        return updates;
      }
      updates = { $set: {} };
      currentUpdate = currentUpdate || {};

      updates.$set[updatedAt] = now;

      if (currentUpdate[createdAt]) {
        delete currentUpdate[createdAt];
      }
      if (currentUpdate.$set &#x26;&#x26; currentUpdate.$set[createdAt]) {
        delete currentUpdate.$set[createdAt];
      }

      updates.$setOnInsert = {};
      updates.$setOnInsert[createdAt] = now;

      return updates;
    };

    this.methods.initializeTimestamps = function() {
      if (!this.get(createdAt)) {
        this.set(createdAt, new Date());
      }
      if (!this.get(updatedAt)) {
        this.set(updatedAt, new Date());
      }
      return this;
    };

    this.pre(&#x27;findOneAndUpdate&#x27;, function(next) {
      var overwrite = this.options.overwrite;
      this.findOneAndUpdate({}, genUpdates(this.getUpdate(), overwrite), {
        overwrite: overwrite
      });
      applyTimestampsToChildren(this);
      next();
    });

    this.pre(&#x27;update&#x27;, function(next) {
      var overwrite = this.options.overwrite;
      this.update({}, genUpdates(this.getUpdate(), overwrite), {
        overwrite: overwrite
      });
      applyTimestampsToChildren(this);
      next();
    });
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

 for (var i = 0; i &#x3c; this._defaultMiddleware.length; ++i) {
   var m = this._defaultMiddleware[i];
   this[m.kind](m.hook, !!m.isAsync, m.fn);
 }

 if (this.options.timestamps) {
   this.<span class="apidocCodeKeywordSpan">setupTimestamp</span>(this.options.timestamps);
 }
}

/*!
* Returns this documents _id cast to a string.
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.static" id="apidoc.element.mongoose.schema.prototype.static">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>static
        <span class="apidocSignatureSpan">(name, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">static = function (name, fn) {
  if (typeof name !== &#x27;string&#x27;) {
    for (var i in name) {
      this.statics[i] = name[i];
    }
  } else {
    this.statics[name] = fn;
  }
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

/**
* Adds static &#x22;class&#x22; methods to Models compiled from this schema.
*
* ####Example
*
*     var schema = new Schema(..);
*     schema.<span class="apidocCodeKeywordSpan">static</span>(&#x27;findByName&#x27;, function (name, callback) {
*       return this.find({ name: name }, callback);
*     });
*
*     var Drink = mongoose.model(&#x27;Drink&#x27;, schema);
*     Drink.findByName(&#x27;sanpellegrino&#x27;, function (err, drinks) {
*       //
*     });
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.virtual" id="apidoc.element.mongoose.schema.prototype.virtual">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>virtual
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">virtual = function (name, options) {
  if (options &#x26;&#x26; options.ref) {
    if (!options.localField) {
      throw new Error(&#x27;Reference virtuals require `localField` option&#x27;);
    }

    if (!options.foreignField) {
      throw new Error(&#x27;Reference virtuals require `foreignField` option&#x27;);
    }

    this.pre(&#x27;init&#x27;, function(next, obj) {
      if (name in obj) {
        if (!this.$$populatedVirtuals) {
          this.$$populatedVirtuals = {};
        }

        if (options.justOne) {
          this.$$populatedVirtuals[name] = Array.isArray(obj[name]) ?
            obj[name][0] :
            obj[name];
        } else {
          this.$$populatedVirtuals[name] = Array.isArray(obj[name]) ?
            obj[name] :
            obj[name] == null ? [] : [obj[name]];
        }

        delete obj[name];
      }
      if (this.ownerDocument) {
        next();
        return this;
      } else {
        next();
      }
    });

    var virtual = this.virtual(name);
    virtual.options = options;
    return virtual.
      get(function() {
        if (!this.$$populatedVirtuals) {
          this.$$populatedVirtuals = {};
        }
        if (name in this.$$populatedVirtuals) {
          return this.$$populatedVirtuals[name];
        }
        return null;
      }).
      set(function(v) {
        if (!this.$$populatedVirtuals) {
          this.$$populatedVirtuals = {};
        }
        this.$$populatedVirtuals[name] = v;
      });
  }

  var virtuals = this.virtuals;
  var parts = name.split(&#x27;.&#x27;);

  if (this.pathType(name) === &#x27;real&#x27;) {
    throw new Error(&#x27;Virtual path &#x22;&#x27; + name + &#x27;&#x22;&#x27; +
      &#x27; conflicts with a real path in the schema&#x27;);
  }

  virtuals[name] = parts.reduce(function(mem, part, i) {
    mem[part] || (mem[part] = (i === parts.length - 1)
        ? new VirtualType(options, name)
        : {});
    return mem[part];
  }, this.tree);

  return virtuals[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  this.add(obj);
}

// ensure the documents receive an id getter unless disabled
var autoid = !this.paths[&#x27;id&#x27;] &#x26;&#x26;
    (!this.options.noVirtualId &#x26;&#x26; this.options.id);
if (autoid) {
  this.<span class="apidocCodeKeywordSpan">virtual</span>(&#x27;id&#x27;).get(idGetter);
}

for (var i = 0; i &#x3c; this._defaultMiddleware.length; ++i) {
  var m = this._defaultMiddleware[i];
  this[m.kind](m.hook, !!m.isAsync, m.fn);
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schema.prototype.virtualpath" id="apidoc.element.mongoose.schema.prototype.virtualpath">
        function <span class="apidocSignatureSpan">mongoose.schema.prototype.</span>virtualpath
        <span class="apidocSignatureSpan">(name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">virtualpath = function (name) {
  return this.virtuals[name];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (!mixed) {
    if (strict === &#x27;throw&#x27;) {
      throw new StrictModeError(path);
    }
    return this;
  }
} else if (pathType === &#x27;virtual&#x27;) {
  schema = this.schema.<span class="apidocCodeKeywordSpan">virtualpath</span>(path);
  schema.applySetters(val, this);
  return this;
} else {
  schema = this.$__path(path);
}

var pathToMark;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.schematype" id="apidoc.module.mongoose.schematype">module mongoose.schematype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.schematype.schematype" id="apidoc.element.mongoose.schematype.schematype">
        function <span class="apidocSignatureSpan">mongoose.</span>schematype
        <span class="apidocSignatureSpan">(path, options, instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function SchemaType(path, options, instance) {
  this.path = path;
  this.instance = instance;
  this.validators = [];
  this.setters = [];
  this.getters = [];
  this.options = options;
  this._index = null;
  this.selected;

  for (var i in options) {
    if (this[i] &#x26;&#x26; typeof this[i] === &#x27;function&#x27;) {
      // { unique: true, index: true }
      if (i === &#x27;index&#x27; &#x26;&#x26; this._index) {
        continue;
      }

      var opts = Array.isArray(options[i])
          ? options[i]
          : [options[i]];

      this[i].apply(this, opts);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.CastError" id="apidoc.element.mongoose.schematype.CastError">
        function <span class="apidocSignatureSpan">mongoose.schematype.</span>CastError
        <span class="apidocSignatureSpan">(type, value, path, reason)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CastError(type, value, path, reason) {
  var stringValue = util.inspect(value);
  stringValue = stringValue.replace(/^&#x27;/, &#x27;&#x22;&#x27;).replace(/&#x27;$/, &#x27;&#x22;&#x27;);
  if (stringValue.charAt(0) !== &#x27;&#x22;&#x27;) {
    stringValue = &#x27;&#x22;&#x27; + stringValue + &#x27;&#x22;&#x27;;
  }
  MongooseError.call(this, &#x27;Cast to &#x27; + type + &#x27; failed for value &#x27; +
    stringValue + &#x27; at path &#x22;&#x27; + path + &#x27;&#x22;&#x27;);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this);
  } else {
    this.stack = new Error().stack;
  }
  this.stringValue = stringValue;
  this.name = &#x27;CastError&#x27;;
  this.kind = type;
  this.value = value;
  this.path = path;
  this.reason = reason;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      this.markModified(path);
      cleanModifiedSubpaths(this, path);
    } else {
      this.set(val, path, constructing);
    }
    return this;
  }
  this.invalidate(path, new MongooseError.<span class="apidocCodeKeywordSpan">CastError</span>(&#x27;Object&#x27;, val, path));
  return this;
}

var schema;
var parts = path.split(&#x27;.&#x27;);

if (pathType === &#x27;adhocOrUndefined&#x27; &#x26;&#x26; strict) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.ValidatorError" id="apidoc.element.mongoose.schematype.ValidatorError">
        function <span class="apidocSignatureSpan">mongoose.schematype.</span>ValidatorError
        <span class="apidocSignatureSpan">(properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function ValidatorError(properties) {
  var msg = properties.message;
  if (!msg) {
    msg = MongooseError.messages.general.default;
  }

  var message = this.formatMessage(msg, properties);
  MongooseError.call(this, message);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this);
  } else {
    this.stack = new Error().stack;
  }
  this.properties = properties;
  this.name = &#x27;ValidatorError&#x27;;
  this.kind = properties.type;
  this.path = properties.path;
  this.value = properties.value;
  this.reason = properties.reason;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype._isRef" id="apidoc.element.mongoose.schematype._isRef">
        function <span class="apidocSignatureSpan">mongoose.schematype.</span>_isRef
        <span class="apidocSignatureSpan">(self, value, doc, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_isRef = function (self, value, doc, init) {
  // fast path
  var ref = init &#x26;&#x26; self.options &#x26;&#x26; self.options.ref;

  if (!ref &#x26;&#x26; doc &#x26;&#x26; doc.$__fullPath) {
    // checks for
    // - this populated with adhoc model and no ref was set in schema OR
    // - setting / pushing values after population
    var path = doc.$__fullPath(self.path);
    var owner = doc.ownerDocument ? doc.ownerDocument() : doc;
    ref = owner.populated(path);
  }

  if (ref) {
    if (value == null) {
      return true;
    }
    if (!Buffer.isBuffer(value) &#x26;&#x26;  // buffers are objects too
        value._bsontype !== &#x27;Binary&#x27; // raw binary value from the db
        &#x26;&#x26; utils.isObject(value)    // might have deselected _id in population query
    ) {
      return true;
    }
  }

  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.schematype.prototype" id="apidoc.module.mongoose.schematype.prototype">module mongoose.schematype.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.applyGetters" id="apidoc.element.mongoose.schematype.prototype.applyGetters">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>applyGetters
        <span class="apidocSignatureSpan">(value, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyGetters = function (value, scope) {
  var v = value,
      getters = this.getters,
      len = getters.length;

  if (!len) {
    return v;
  }

  while (len--) {
    v = getters[len].call(scope, v, this);
  }

  return v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 if (adhoc) {
   obj = adhoc.cast(obj);
 }

 // Check if this path is populated - don&#x27;t apply getters if it is,
 // because otherwise its a nested object. See gh-3357
 if (schema &#x26;&#x26; !this.populated(path)) {
   obj = schema.<span class="apidocCodeKeywordSpan">applyGetters</span>(obj, this);
 }

 return obj;
};

/**
* Returns the schematype for the given `path`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.applySetters" id="apidoc.element.mongoose.schematype.prototype.applySetters">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>applySetters
        <span class="apidocSignatureSpan">(value, scope, init, priorVal, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applySetters = function (value, scope, init, priorVal, options) {
  var v = value,
      setters = this.setters,
      len = setters.length,
      caster = this.caster;

  while (len--) {
    v = setters[len].call(scope, v, this);
  }

  if (Array.isArray(v) &#x26;&#x26; caster &#x26;&#x26; caster.setters) {
    var newVal = [];
    for (var i = 0; i &#x3c; v.length; i++) {
      newVal.push(caster.applySetters(v[i], scope, init, priorVal));
    }
    v = newVal;
  }

  if (v === null || v === undefined) {
    return v;
  }

  // do not cast until all setters are applied #665
  v = this.cast(v, scope, init, priorVal, options);

  return v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (strict === &#x27;throw&#x27;) {
      throw new StrictModeError(path);
    }
    return this;
  }
} else if (pathType === &#x27;virtual&#x27;) {
  schema = this.schema.virtualpath(path);
  schema.<span class="apidocCodeKeywordSpan">applySetters</span>(val, this);
  return this;
} else {
  schema = this.$__path(path);
}

var pathToMark;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.castForQuery" id="apidoc.element.mongoose.schematype.prototype.castForQuery">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>castForQuery
        <span class="apidocSignatureSpan">($conditional, val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">castForQuery = function ($conditional, val) {
  var handler;
  if (arguments.length === 2) {
    handler = this.$conditionalHandlers[$conditional];
    if (!handler) {
      throw new Error(&#x27;Can\&#x27;t use &#x27; + $conditional);
    }
    return handler.call(this, val);
  }
  val = $conditional;
  return this.cast(val);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
          }

          if (geo) {
var numbertype = new Types.Number(&#x27;__QueryCasting__&#x27;);
var value = val[geo];

if (val.$maxDistance != null) {
  val.$maxDistance = numbertype.<span class="apidocCodeKeywordSpan">castForQuery</span>(val.$maxDistance);
}
if (val.$minDistance != null) {
  val.$minDistance = numbertype.castForQuery(val.$minDistance);
}

if (geo === &#x27;$within&#x27;) {
  var withinType = value.$center
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.checkRequired" id="apidoc.element.mongoose.schematype.prototype.checkRequired">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>checkRequired
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">checkRequired = function (val) {
  return val != null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  // in here, `this` refers to the validating document.
  // no validation when this path wasn&#x27;t selected in the query.
  if (&#x27;isSelected&#x27; in this &#x26;&#x26; !this.isSelected(_this.path) &#x26;&#x26; !this.isModified(_this.path)) {
    return true;
  }

  return ((typeof required === &#x27;function&#x27;) &#x26;&#x26; !required.apply(this)) ||
      _this.<span class="apidocCodeKeywordSpan">checkRequired</span>(v, this);
};
this.originalRequiredValue = required;

if (typeof required === &#x27;string&#x27;) {
  message = required;
  required = undefined;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.default" id="apidoc.element.mongoose.schematype.prototype.default">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>default
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">default = function (val) {
  if (arguments.length === 1) {
    if (val === void 0) {
      this.defaultValue = void 0;
      return void 0;
    }
    this.defaultValue = val;
    return this.defaultValue;
  } else if (arguments.length &#x3e; 1) {
    this.defaultValue = utils.args(arguments);
  }
  return this.defaultValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (p in fields) {
    continue;
  }

  def = type.getDefault(_this, false);
  if (typeof def !== &#x27;undefined&#x27;) {
    doc_[piece] = def;
    _this.$__.activePaths.<span class="apidocCodeKeywordSpan">default</span>(p);
  }
} else if (included) {
  // selected field
  def = type.getDefault(_this, false);
  if (typeof def !== &#x27;undefined&#x27;) {
    doc_[piece] = def;
    _this.$__.activePaths.default(p);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.doValidate" id="apidoc.element.mongoose.schematype.prototype.doValidate">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>doValidate
        <span class="apidocSignatureSpan">(value, fn, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doValidate = function (value, fn, scope) {
  var err = false;
  var path = this.path;
  var count = this.validators.length;

  if (!count) {
    return fn(null);
  }

  var validate = function(ok, validatorProperties) {
    if (err) {
      return;
    }
    if (ok === undefined || ok) {
      --count || fn(null);
    } else {
      err = new ValidatorError(validatorProperties);
      fn(err);
    }
  };

  var _this = this;
  this.validators.forEach(function(v) {
    if (err) {
      return;
    }

    var validator = v.validator;
    var ok;

    var validatorProperties = utils.clone(v);
    validatorProperties.path = path;
    validatorProperties.value = value;

    if (validator instanceof RegExp) {
      validate(validator.test(value), validatorProperties);
    } else if (typeof validator === &#x27;function&#x27;) {
      if (value === undefined &#x26;&#x26; !_this.isRequired) {
        validate(true, validatorProperties);
        return;
      }
      if (validatorProperties.isAsync) {
        asyncValidate(validator, scope, value, validatorProperties, validate);
      } else if (validator.length === 2 &#x26;&#x26; !(&#x27;isAsync&#x27; in validatorProperties)) {
        legacyAsyncValidate(validator, scope, value, validatorProperties,
          validate);
      } else {
        try {
          ok = validator.call(scope, value);
        } catch (error) {
          ok = false;
          validatorProperties.reason = error;
        }
        if (ok &#x26;&#x26; typeof ok.then === &#x27;function&#x27;) {
          ok.then(
            function(ok) { validate(ok, validatorProperties); },
            function(error) {
              validatorProperties.reason = error;
              ok = false;
              validate(ok, validatorProperties);
            });
        } else {
          validate(ok, validatorProperties);
        }
      }
    }
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // If user marked as invalid or there was a cast error, don&#x27;t validate
    if (!_this.$isValid(path)) {
      --total || complete();
      return;
    }

    var val = _this.getValue(path);
    p.<span class="apidocCodeKeywordSpan">doValidate</span>(val, function(err) {
      if (err) {
        _this.invalidate(path, err, undefined, true);
      }
      --total || complete();
    }, _this);
  });
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.doValidateSync" id="apidoc.element.mongoose.schematype.prototype.doValidateSync">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>doValidateSync
        <span class="apidocSignatureSpan">(value, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">doValidateSync = function (value, scope) {
  var err = null,
      path = this.path,
      count = this.validators.length;

  if (!count) {
    return null;
  }

  var validate = function(ok, validatorProperties) {
    if (err) {
      return;
    }
    if (ok !== undefined &#x26;&#x26; !ok) {
      err = new ValidatorError(validatorProperties);
    }
  };

  var validators = this.validators;
  if (value === void 0) {
    if (this.validators.length &#x3e; 0 &#x26;&#x26; this.validators[0].type === &#x27;required&#x27;) {
      validators = [this.validators[0]];
    } else {
      return null;
    }
  }

  validators.forEach(function(v) {
    if (err) {
      return;
    }

    var validator = v.validator;
    var validatorProperties = utils.clone(v);
    validatorProperties.path = path;
    validatorProperties.value = value;
    var ok;

    if (validator instanceof RegExp) {
      validate(validator.test(value), validatorProperties);
    } else if (typeof validator === &#x27;function&#x27;) {
      // if not async validators
      if (validator.length !== 2 &#x26;&#x26; !validatorProperties.isAsync) {
        try {
          ok = validator.call(scope, value);
        } catch (error) {
          ok = false;
          validatorProperties.reason = error;
        }
        validate(ok, validatorProperties);
      }
    }
  });

  return err;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    return;
  }
  if (!_this.$isValid(path)) {
    return;
  }

  var val = _this.getValue(path);
  var err = p.<span class="apidocCodeKeywordSpan">doValidateSync</span>(val, _this);
  if (err) {
    _this.invalidate(path, err, undefined, true);
  }
});

var err = _this.$__.validationError;
_this.$__.validationError = undefined;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.get" id="apidoc.element.mongoose.schematype.prototype.get">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>get
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (fn) {
  if (typeof fn !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;A getter must be a function.&#x27;);
  }
  this.getters.push(fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// a setter
Comment.path(&#x27;name&#x27;).set(function (v) {
  return capitalize(v);
});

// middleware
Comment.pre(&#x27;save&#x27;, function (next) {
  notify(this.<span class="apidocCodeKeywordSpan">get</span>(&#x27;email&#x27;));
  next();
});
```

Take a look at the example in `examples/schema.js` for an end-to-end example of a typical setup.

### Accessing a Model
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.getDefault" id="apidoc.element.mongoose.schematype.prototype.getDefault">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>getDefault
        <span class="apidocSignatureSpan">(scope, init)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDefault = function (scope, init) {
  var ret = typeof this.defaultValue === &#x27;function&#x27;
      ? this.defaultValue.call(scope)
      : this.defaultValue;

  if (ret !== null &#x26;&#x26; ret !== undefined) {
    var casted = this.cast(ret, scope, init);
    if (casted &#x26;&#x26; casted.$isSingleNested) {
      casted.$parent = scope;
    }
    return casted;
  }
  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (fields &#x26;&#x26; exclude !== null) {
if (exclude === true) {
  // apply defaults to all non-excluded fields
  if (p in fields) {
    continue;
  }

  def = type.<span class="apidocCodeKeywordSpan">getDefault</span>(_this, false);
  if (typeof def !== &#x27;undefined&#x27;) {
    doc_[piece] = def;
    _this.$__.activePaths.default(p);
  }
} else if (included) {
  // selected field
  def = type.getDefault(_this, false);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.index" id="apidoc.element.mongoose.schematype.prototype.index">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>index
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">index = function (options) {
  this._index = options;
  utils.expires(this._index);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Defines an index (most likely compound) for this schema.
*
* ####Example
*
*     schema.<span class="apidocCodeKeywordSpan">index</span>({ first: 1, last: -1 })
*
* @param {Object} fields
* @param {Object} [options] Options to pass to [MongoDB driver&#x27;s `createIndex()` function](http://mongodb.github.io/node-mongodb
-native/2.0/api/Collection.html#createIndex)
* @param {String} [options.expires=null] Mongoose-specific syntactic sugar, uses [ms](https://www.npmjs.com/package/ms) to convert
 `expires` option into seconds for the `expireAfterSeconds` in the above link.
* @api public
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.required" id="apidoc.element.mongoose.schematype.prototype.required">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>required
        <span class="apidocSignatureSpan">(required, message)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">required = function (required, message) {
  if (required === false) {
    this.validators = this.validators.filter(function(v) {
      return v.validator !== this.requiredValidator;
    }, this);

    this.isRequired = false;
    return this;
  }

  var _this = this;
  this.isRequired = true;

  this.requiredValidator = function(v) {
    // in here, `this` refers to the validating document.
    // no validation when this path wasn&#x27;t selected in the query.
    if (&#x27;isSelected&#x27; in this &#x26;&#x26; !this.isSelected(_this.path) &#x26;&#x26; !this.isModified(_this.path)) {
      return true;
    }

    return ((typeof required === &#x27;function&#x27;) &#x26;&#x26; !required.apply(this)) ||
        _this.checkRequired(v, this);
  };
  this.originalRequiredValue = required;

  if (typeof required === &#x27;string&#x27;) {
    message = required;
    required = undefined;
  }

  var msg = message || MongooseError.messages.general.required;
  this.validators.unshift({
    validator: this.requiredValidator,
    message: msg,
    type: &#x27;required&#x27;
  });

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*           &#x27;username is required if id is specified&#x27;
*         ]
*       }
*     })
*
*     // or through the path API
*
*     Schema.path(&#x27;name&#x27;).<span class="apidocCodeKeywordSpan">required</span>(true);
*
*     // with custom error messaging
*
*     Schema.path(&#x27;name&#x27;).required(true, &#x27;grrr :( &#x27;);
*
*     // or make a path conditionally required based on a function
*     var isOver18 = function() { return this.age &#x3e;= 18; };
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.select" id="apidoc.element.mongoose.schematype.prototype.select">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>select
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function select(val) {
  this.selected = !!val;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

/**
* Checks if `path` was selected in the source query which initialized this document.
*
* ####Example
*
*     Thing.findOne().<span class="apidocCodeKeywordSpan">select</span>(&#x27;name&#x27;).exec(function (err, doc) {
*        doc.isSelected(&#x27;name&#x27;) // true
*        doc.isSelected(&#x27;age&#x27;)  // false
*     })
*
* @param {String} path
* @return {Boolean}
* @api public
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.set" id="apidoc.element.mongoose.schematype.prototype.set">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>set
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (fn) {
  if (typeof fn !== &#x27;function&#x27;) {
    throw new TypeError(&#x27;A setter must be a function.&#x27;);
  }
  this.setters.push(fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
age: { type: Number, min: 18, index: true },
bio: { type: String, match: /[a-z]/ },
date: { type: Date, default: Date.now },
buff: Buffer
});

// a setter
Comment.path(&#x27;name&#x27;).<span class="apidocCodeKeywordSpan">set</span>(function (v) {
return capitalize(v);
});

// middleware
Comment.pre(&#x27;save&#x27;, function (next) {
notify(this.get(&#x27;email&#x27;));
next();
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.sparse" id="apidoc.element.mongoose.schematype.prototype.sparse">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>sparse
        <span class="apidocSignatureSpan">(bool)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">sparse = function (bool) {
  if (this._index === null || this._index === undefined ||
    typeof this._index === &#x27;boolean&#x27;) {
    this._index = {};
  } else if (typeof this._index === &#x27;string&#x27;) {
    this._index = {type: this._index};
  }

  this._index.sparse = bool;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.text" id="apidoc.element.mongoose.schematype.prototype.text">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>text
        <span class="apidocSignatureSpan">(bool)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">text = function (bool) {
  if (this._index === null || this._index === undefined ||
    typeof this._index === &#x27;boolean&#x27;) {
    this._index = {};
  } else if (typeof this._index === &#x27;string&#x27;) {
    this._index = {type: this._index};
  }

  this._index.text = bool;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.unique" id="apidoc.element.mongoose.schematype.prototype.unique">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>unique
        <span class="apidocSignatureSpan">(bool)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unique = function (bool) {
  if (this._index === false) {
    if (!bool) {
      return;
    }
    throw new Error(&#x27;Path &#x22;&#x27; + this.path + &#x27;&#x22; may not have `index` set to &#x27; +
      &#x27;false and `unique` set to true&#x27;);
  }
  if (this._index == null || this._index === true) {
    this._index = {};
  } else if (typeof this._index === &#x27;string&#x27;) {
    this._index = {type: this._index};
  }

  this._index.unique = bool;
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (mod.options.match) {
  match = utils.object.shallowCopy(mod.options.match);
} else {
  match = {};
}

var ids = utils.array.flatten(mod.ids, flatten);
ids = utils.array.<span class="apidocCodeKeywordSpan">unique</span>(ids);

if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {
  --_remaining;
  continue;
}

hasOne = true;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.schematype.prototype.validate" id="apidoc.element.mongoose.schematype.prototype.validate">
        function <span class="apidocSignatureSpan">mongoose.schematype.prototype.</span>validate
        <span class="apidocSignatureSpan">(obj, message, type)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">validate = function (obj, message, type) {
  if (typeof obj === &#x27;function&#x27; || obj &#x26;&#x26; utils.getFunctionName(obj.constructor) === &#x27;RegExp&#x27;) {
    var properties;
    if (message instanceof Object &#x26;&#x26; !type) {
      properties = utils.clone(message);
      if (!properties.message) {
        properties.message = properties.msg;
      }
      properties.validator = obj;
      properties.type = properties.type || &#x27;user defined&#x27;;
    } else {
      if (!message) {
        message = MongooseError.messages.general.default;
      }
      if (!type) {
        type = &#x27;user defined&#x27;;
      }
      properties = {message: message, type: type, validator: obj};
    }
    this.validators.push(properties);
    return this;
  }

  var i,
      length,
      arg;

  for (i = 0, length = arguments.length; i &#x3c; length; i++) {
    arg = arguments[i];
    if (!(arg &#x26;&#x26; utils.getFunctionName(arg.constructor) === &#x27;Object&#x27;)) {
      var msg = &#x27;Invalid validator. Received (&#x27; + typeof arg + &#x27;) &#x27;
          + arg
          + &#x27;. See http://mongoosejs.com/docs/api.html#schematype_SchemaType-validate&#x27;;

      throw new Error(msg);
    }
    this.validate(arg.validator, arg);
  }

  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
*
* ####Note:
*
* This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned
 to your `callback`.
*
* ####Example:
*
*     doc.<span class="apidocCodeKeywordSpan">validate</span>(function (err) {
*       if (err) handleError(err);
*       else // validation passed
*     });
*
* @param {Object} optional options internal options
* @param {Function} callback optional callback called after validation completes, passing an error if one occurred
* @return {Promise} Promise
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.statemachine" id="apidoc.module.mongoose.statemachine">module mongoose.statemachine</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.statemachine.statemachine" id="apidoc.element.mongoose.statemachine.statemachine">
        function <span class="apidocSignatureSpan">mongoose.</span>statemachine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StateMachine() {
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.statemachine.ctor" id="apidoc.element.mongoose.statemachine.ctor">
        function <span class="apidocSignatureSpan">mongoose.statemachine.</span>ctor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ctor = function () {
  var states = utils.args(arguments);

  var ctor = function() {
    StateMachine.apply(this, arguments);
    this.paths = {};
    this.states = {};
    this.stateNames = states;

    var i = states.length,
        state;

    while (i--) {
      state = states[i];
      this.states[state] = {};
    }
  };

  ctor.prototype = new StateMachine();

  states.forEach(function(state) {
    // Changes the `path`&#x27;s state to `state`.
    ctor.prototype[state] = function(path) {
      this._changeState(path, state);
    };
  });

  return ctor;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...


/*!
 * Dependencies
 */

var StateMachine = require(&#x27;./statemachine&#x27;);
var ActiveRoster = StateMachine.<span class="apidocCodeKeywordSpan">ctor</span>(&#x27;require&#x27;, &#x27;modify&#x27;, &#x27;init
&#x27;, &#x27;default&#x27;, &#x27;ignore&#x27;);

module.exports = exports = InternalCache;

function InternalCache() {
this.strictMode = undefined;
this.selected = undefined;
this.shardval = undefined;
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.statemachine.prototype" id="apidoc.module.mongoose.statemachine.prototype">module mongoose.statemachine.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.statemachine.prototype._changeState" id="apidoc.element.mongoose.statemachine.prototype._changeState">
        function <span class="apidocSignatureSpan">mongoose.statemachine.prototype.</span>_changeState
        <span class="apidocSignatureSpan">(path, nextState)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _changeState(path, nextState) {
  var prevBucket = this.states[this.paths[path]];
  if (prevBucket) delete prevBucket[path];

  this.paths[path] = nextState;
  this.states[nextState][path] = true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  };

  ctor.prototype = new StateMachine();

  states.forEach(function(state) {
    // Changes the `path`&#x27;s state to `state`.
    ctor.prototype[state] = function(path) {
      this.<span class="apidocCodeKeywordSpan">_changeState</span>(path, state);
    };
  });

  return ctor;
};

/*!
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.statemachine.prototype._iter" id="apidoc.element.mongoose.statemachine.prototype._iter">
        function <span class="apidocSignatureSpan">mongoose.statemachine.prototype.</span>_iter
        <span class="apidocSignatureSpan">(iterMethod)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function _iter(iterMethod) {
  return function() {
    var numArgs = arguments.length,
        states = utils.args(arguments, 0, numArgs - 1),
        callback = arguments[numArgs - 1];

    if (!states.length) states = this.stateNames;

    var _this = this;

    var paths = states.reduce(function(paths, state) {
      return paths.concat(Object.keys(_this.states[state]));
    }, []);

    return paths[iterMethod](function(path, i, paths) {
      return callback(path, i, paths);
    });
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* @param {String} [state]
* @param {String} [state]
* @param {Function} callback
* @private
*/

StateMachine.prototype.forEach = function forEach() {
 this.forEach = this.<span class="apidocCodeKeywordSpan">_iter</span>(&#x27;forEach&#x27;);
 return this.forEach.apply(this, arguments);
};

/*!
* Maps over the paths that belong to one of the parameter states.
*
* The function profile can look like:
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.statemachine.prototype.clear" id="apidoc.element.mongoose.statemachine.prototype.clear">
        function <span class="apidocSignatureSpan">mongoose.statemachine.prototype.</span>clear
        <span class="apidocSignatureSpan">(state)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clear(state) {
  var keys = Object.keys(this.states[state]),
      i = keys.length,
      path;

  while (i--) {
    path = keys[i];
    delete this.states[state][path];
    delete this.paths[path];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var type = dirt.value;
  if (type &#x26;&#x26; type._atomics) {
    type._atomics = {};
  }
});

// Clear &#x27;dirty&#x27; cache
this.$__.activePaths.<span class="apidocCodeKeywordSpan">clear</span>(&#x27;modify&#x27;);
this.$__.activePaths.clear(&#x27;default&#x27;);
this.$__.validationError = undefined;
this.errors = undefined;
_this = this;
this.schema.requiredPaths().forEach(function(path) {
  _this.$__.activePaths.require(path);
});
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.statemachine.prototype.forEach" id="apidoc.element.mongoose.statemachine.prototype.forEach">
        function <span class="apidocSignatureSpan">mongoose.statemachine.prototype.</span>forEach
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function forEach() {
  this.forEach = this._iter(&#x27;forEach&#x27;);
  return this.forEach.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @api public
 */

Aggregate.prototype.project = function(arg) {
var fields = {};

if (typeof arg === &#x27;object&#x27; &#x26;&#x26; !util.isArray(arg)) {
  Object.keys(arg).<span class="apidocCodeKeywordSpan">forEach</span>(function(field) {
    fields[field] = arg[field];
  });
} else if (arguments.length === 1 &#x26;&#x26; typeof arg === &#x27;string&#x27;) {
  arg.split(/\s+/).forEach(function(field) {
    if (!field) {
      return;
    }
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.statemachine.prototype.map" id="apidoc.element.mongoose.statemachine.prototype.map">
        function <span class="apidocSignatureSpan">mongoose.statemachine.prototype.</span>map
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function map() {
  this.map = this._iter(&#x27;map&#x27;);
  return this.map.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    val.length &#x3e; 0 &#x26;&#x26;
    val[0] instanceof Document &#x26;&#x26;
    val[0].constructor.modelName &#x26;&#x26;
    (schema.options.type[0].ref === val[0].constructor.baseModelName || schema.options.type[0].ref === val[0].constructor.modelName
)) {
  if (this.ownerDocument) {
    popOpts = { model: val[0].constructor };
    this.ownerDocument().populated(this.$__fullPath(path),
      val.<span class="apidocCodeKeywordSpan">map</span>(function(v) { return v._id; }), popOpts);
  } else {
    popOpts = { model: val[0].constructor };
    this.populated(path, val.map(function(v) { return v._id; }), popOpts);
  }
  didPopulate = true;
}
val = schema.applySetters(val, this, false, priorVal);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.statemachine.prototype.some" id="apidoc.element.mongoose.statemachine.prototype.some">
        function <span class="apidocSignatureSpan">mongoose.statemachine.prototype.</span>some
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function some() {
  var _this = this;
  var what = arguments.length ? arguments : this.stateNames;
  return Array.prototype.some.call(what, function(state) {
    return Object.keys(_this.states[state]).length;
  });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 if (typeof obj !== &#x27;object&#x27;) {
   return false;
 }

 k = Object.keys(obj);

 return k.length === 1 &#x26;&#x26; k
         .<span class="apidocCodeKeywordSpan">some</span>(function(key) {
           return key[0] === &#x27;$&#x27;;
         });
}

/*!
* Adds the appropriate `$match` pipeline step to the top of an aggregate&#x27;s
* pipeline, should it&#x27;s model is a non-root discriminator type. This is
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.utils" id="apidoc.module.mongoose.utils">module mongoose.utils</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.utils.PopulateOptions" id="apidoc.element.mongoose.utils.PopulateOptions">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>PopulateOptions
        <span class="apidocSignatureSpan">(path, select, match, options, model, subPopulate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function PopulateOptions(path, select, match, options, model, subPopulate) {
  this.path = path;
  this.match = match;
  this.select = select;
  this.options = options;
  this.model = model;
  if (typeof subPopulate === &#x27;object&#x27;) {
    this.populate = subPopulate;
  }
  this._docs = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.args" id="apidoc.element.mongoose.utils.args">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>args
        <span class="apidocSignatureSpan">(args, slice, sliceEnd)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">args = function (args, slice, sliceEnd) {
  var ret = [];
  var len = args.length;

  if (0 === len) return ret;

  var start = slice &#x3c; 0
    ? Math.max(0, slice + len)
    : slice || 0;

  if (sliceEnd !== undefined) {
    len = sliceEnd &#x3c; 0
      ? sliceEnd + len
      : sliceEnd
  }

  while (len-- &#x3e; start) {
    ret[len - start] = args[len];
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Aggregate}
 * @api public
 */

Aggregate.prototype.append = function() {
var args = (arguments.length === 1 &#x26;&#x26; util.isArray(arguments[0]))
    ? arguments[0]
    : utils.<span class="apidocCodeKeywordSpan">args</span>(arguments);

if (!args.every(isOperator)) {
  throw new Error(&#x27;Arguments must be aggregate pipeline operators&#x27;);
}

this._pipeline = this._pipeline.concat(args);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.clone" id="apidoc.element.mongoose.utils.clone">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>clone
        <span class="apidocSignatureSpan">(obj, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function clone(obj, options) {
  if (obj === undefined || obj === null) {
    return obj;
  }

  if (Array.isArray(obj)) {
    return cloneArray(obj, options);
  }

  if (isMongooseObject(obj)) {
    if (options &#x26;&#x26; options.json &#x26;&#x26; typeof obj.toJSON === &#x27;function&#x27;) {
      return obj.toJSON(options);
    }
    return obj.toObject(options);
  }

  if (obj.constructor) {
    switch (exports.getFunctionName(obj.constructor)) {
      case &#x27;Object&#x27;:
        return cloneObject(obj, options);
      case &#x27;Date&#x27;:
        return new obj.constructor(+obj);
      case &#x27;RegExp&#x27;:
        return cloneRegExp(obj);
      default:
        // ignore
        break;
    }
  }

  if (obj instanceof ObjectId) {
    return new ObjectId(obj.id);
  }
  if (obj instanceof Decimal) {
    if (options &#x26;&#x26; options.flattenDecimals) {
      return obj.toJSON();
    }
    return Decimal.fromString(obj.toString());
  }

  if (!obj.constructor &#x26;&#x26; exports.isObject(obj)) {
    // object created with Object.create(null)
    return cloneObject(obj, options);
  }

  if (obj.valueOf) {
    return obj.valueOf();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Aggregate.prototype.exec = function(callback) {
if (!this._model) {
  throw new Error(&#x27;Aggregate not bound to any Model&#x27;);
}
var _this = this;
var Promise = PromiseProvider.get();
var options = utils.<span class="apidocCodeKeywordSpan">clone</span>(this.options);

if (options &#x26;&#x26; options.cursor) {
  if (options.cursor.async) {
    delete options.cursor.async;
    return new Promise.ES6(function(resolve) {
      if (!_this._model.collection.buffer) {
        process.nextTick(function() {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.decorate" id="apidoc.element.mongoose.utils.decorate">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>decorate
        <span class="apidocSignatureSpan">(destination, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">decorate = function (destination, source) {
  for (var key in source) {
    destination[key] = source[key];
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.deepEqual" id="apidoc.element.mongoose.utils.deepEqual">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>deepEqual
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function deepEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (a instanceof Date &#x26;&#x26; b instanceof Date) {
    return a.getTime() === b.getTime();
  }

  if ((a instanceof ObjectId &#x26;&#x26; b instanceof ObjectId) ||
      (a instanceof Decimal &#x26;&#x26; b instanceof Decimal)) {
    return a.toString() === b.toString();
  }

  if (a instanceof RegExp &#x26;&#x26; b instanceof RegExp) {
    return a.source === b.source &#x26;&#x26;
        a.ignoreCase === b.ignoreCase &#x26;&#x26;
        a.multiline === b.multiline &#x26;&#x26;
        a.global === b.global;
  }

  if (typeof a !== &#x27;object&#x27; &#x26;&#x26; typeof b !== &#x27;object&#x27;) {
    return a == b;
  }

  if (a === null || b === null || a === undefined || b === undefined) {
    return false;
  }

  if (a.prototype !== b.prototype) {
    return false;
  }

  // Handle MongooseNumbers
  if (a instanceof Number &#x26;&#x26; b instanceof Number) {
    return a.valueOf() === b.valueOf();
  }

  if (Buffer.isBuffer(a)) {
    return exports.buffer.areEqual(a, b);
  }

  if (isMongooseObject(a)) {
    a = a.toObject();
  }
  if (isMongooseObject(b)) {
    b = b.toObject();
  }

  try {
    var ka = Object.keys(a),
        kb = Object.keys(b),
        key, i;
  } catch (e) {
    // happens when one is a string literal and the other isn&#x27;t
    return false;
  }

  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length) {
    return false;
  }

  // the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();

  // ~~~cheap key test
  for (i = ka.length - 1; i &#x3e;= 0; i--) {
    if (ka[i] !== kb[i]) {
      return false;
    }
  }

  // equivalent values for every corresponding key, and
  // ~~~possibly expensive deep test
  for (i = ka.length - 1; i &#x3e;= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key])) {
      return false;
    }
  }

  return true;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.each" id="apidoc.element.mongoose.utils.each">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>each
        <span class="apidocSignatureSpan">(arr, fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">each = function (arr, fn) {
  for (var i = 0; i &#x3c; arr.length; ++i) {
    fn(arr[i]);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Sets the cursor option option for the aggregation query (ignored for &#x3c; 2.6.0).
* Note the different syntax below: .exec() returns a cursor object, and no callback
* is necessary.
*
* ####Example:
*
*     var cursor = Model.aggregate(..).cursor({ batchSize: 1000 }).exec();
*     cursor.<span class="apidocCodeKeywordSpan">each</span>(function(error, doc) {
*       // use doc
*     });
*
* @param {Object} options set the cursor batch size
* @see mongodb http://mongodb.github.io/node-mongodb-native/2.0/api/AggregationCursor.html
*/
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.expires" id="apidoc.element.mongoose.utils.expires">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>expires
        <span class="apidocSignatureSpan">(object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function expires(object) {
  if (!(object &#x26;&#x26; object.constructor.name === &#x27;Object&#x27;)) {
    return;
  }
  if (!(&#x27;expires&#x27; in object)) {
    return;
  }

  var when;
  if (typeof object.expires !== &#x27;string&#x27;) {
    when = object.expires;
  } else {
    when = Math.round(ms(object.expires) / 1000);
  }
  object.expireAfterSeconds = when;
  delete object.expires;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @api public
 */

Schema.prototype.index = function(fields, options) {
  options || (options = {});

  if (options.expires) {
    utils.<span class="apidocCodeKeywordSpan">expires</span>(options);
  }

  this._indexes.push([fields, options]);
  return this;
};

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.getFunctionName" id="apidoc.element.mongoose.utils.getFunctionName">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>getFunctionName
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFunctionName = function (fn) {
  if (fn.name) {
    return fn.name;
  }
  return (fn.toString().trim().match(/^function\s*([^\s(]+)/) || [])[1];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  var keys;
  var ki;
  var _this = this;

  // determine if this doc is a result of a query with
  // excluded fields

  if (fields &#x26;&#x26; utils.<span class="apidocCodeKeywordSpan">getFunctionName</span>(fields.constructor) === &#x27;Object&#
x27;) {
keys = Object.keys(fields);
ki = keys.length;

if (ki === 1 &#x26;&#x26; keys[0] === &#x27;_id&#x27;) {
  exclude = !!fields[keys[ki]];
} else {
  while (ki--) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.getValue" id="apidoc.element.mongoose.utils.getValue">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>getValue
        <span class="apidocSignatureSpan">(path, obj, map)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getValue = function (path, obj, map) {
  return mpath.get(path, obj, &#x27;_doc&#x27;, map);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// If doc._id is not null or undefined
if (doc._id !== null &#x26;&#x26; doc._id !== undefined &#x26;&#x26;
  opts &#x26;&#x26; opts.populated &#x26;&#x26; opts.populated.length) {
  var id = String(doc._id);
  for (var i = 0; i &#x3c; opts.populated.length; ++i) {
    var item = opts.populated[i];
    if (item.isVirtual) {
      this.populated(item.path, utils.<span class="apidocCodeKeywordSpan">getValue</span>(item.path, doc), item);
    } else {
      this.populated(item.path, item._docs[id], item);
    }
  }
}

init(this, doc, this._doc);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.isMongooseObject" id="apidoc.element.mongoose.utils.isMongooseObject">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>isMongooseObject
        <span class="apidocSignatureSpan">(v)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isMongooseObject = function (v) {
  Document || (Document = require(&#x27;./document&#x27;));
  MongooseArray || (MongooseArray = require(&#x27;./types&#x27;).Array);
  MongooseBuffer || (MongooseBuffer = require(&#x27;./types&#x27;).Buffer);

  return v instanceof Document ||
      (v &#x26;&#x26; v.isMongooseArray) ||
      (v &#x26;&#x26; v.isMongooseBuffer);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    Array.isArray(value.$geometry.coordinates)) {
  if (value.$maxDistance != null) {
    value.$maxDistance = numbertype.castForQuery(value.$maxDistance);
  }
  if (value.$minDistance != null) {
    value.$minDistance = numbertype.castForQuery(value.$minDistance);
  }
  if (utils.<span class="apidocCodeKeywordSpan">isMongooseObject</span>(value.$geometry)) {
    value.$geometry = value.$geometry.toObject({
      transform: false,
      virtuals: false
    });
  }
  value = value.$geometry.coordinates;
} else if (geo === &#x27;$geoWithin&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.isNullOrUndefined" id="apidoc.element.mongoose.utils.isNullOrUndefined">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>isNullOrUndefined
        <span class="apidocSignatureSpan">(val)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isNullOrUndefined = function (val) {
  return val === null || val === undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @api private
 */

exports.toObject = function toObject(obj) {
Document || (Document = require(&#x27;./document&#x27;));
var ret;

if (exports.<span class="apidocCodeKeywordSpan">isNullOrUndefined</span>(obj)) {
  return obj;
}

if (obj instanceof Document) {
  return obj.toObject();
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.isObject" id="apidoc.element.mongoose.utils.isObject">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>isObject
        <span class="apidocSignatureSpan">(arg)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isObject = function (arg) {
  if (Buffer.isBuffer(arg)) {
    return true;
  }
  return toString.call(arg) === &#x27;[object Object]&#x27;;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @return {Aggregate}
 * @api public
 */

Aggregate.prototype.graphLookup = function(options) {
  var cloneOptions = {};
  if (options) {
if (!utils.<span class="apidocCodeKeywordSpan">isObject</span>(options)) {
  throw new TypeError(&#x27;Invalid graphLookup() argument. Must be an object.&#x27;);
}

utils.mergeClone(cloneOptions, options);
var startWith = cloneOptions.startWith;

if (startWith &#x26;&#x26; typeof startWith === &#x27;string&#x27;) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.merge" id="apidoc.element.mongoose.utils.merge">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>merge
        <span class="apidocSignatureSpan">(to, from, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function merge(to, from, options) {
  options = options || {};
  var keys = Object.keys(from);
  var i = 0;
  var len = keys.length;
  var key;

  if (options.retainKeyOrder) {
    while (i &#x3c; len) {
      key = keys[i++];
      if (to[key] == null) {
        to[key] = from[key];
      } else if (exports.isObject(from[key])) {
        merge(to[key], from[key], options);
      } else if (options.overwrite) {
        to[key] = from[key];
      }
    }
  } else {
    while (len--) {
      key = keys[len];
      if (to[key] == null) {
        to[key] = from[key];
      } else if (exports.isObject(from[key])) {
        merge(to[key], from[key], options);
      } else if (options.overwrite) {
        to[key] = from[key];
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
};

if (isVirtual &#x26;&#x26; virtual.options &#x26;&#x26; virtual.options.options) {
  currentOptions.options = utils.clone(virtual.options.options, {
    retainKeyOrder: true
  });
}
utils.<span class="apidocCodeKeywordSpan">merge</span>(currentOptions, options);
if (schema &#x26;&#x26; !discriminatorKey) {
  currentOptions.model = Model;
}
options.model = Model;

available[modelName] = {
  Model: Model,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.mergeClone" id="apidoc.element.mongoose.utils.mergeClone">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>mergeClone
        <span class="apidocSignatureSpan">(to, fromObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">mergeClone = function (to, fromObj) {
  var keys = Object.keys(fromObj);
  var len = keys.length;
  var i = 0;
  var key;

  while (i &#x3c; len) {
    key = keys[i++];
    if (typeof to[key] === &#x27;undefined&#x27;) {
      // make sure to retain key order here because of a bug handling the $each
      // operator in mongodb 2.4.4
      to[key] = exports.clone(fromObj[key], {retainKeyOrder: 1});
    } else {
      if (exports.isObject(fromObj[key])) {
        var obj = fromObj[key];
        if (isMongooseObject(fromObj[key]) &#x26;&#x26; !fromObj[key].isMongooseBuffer) {
          obj = obj.toObject({ transform: false, virtuals: false });
        }
        if (fromObj[key].isMongooseBuffer) {
          obj = new Buffer(obj);
        }
        exports.mergeClone(to[key], obj);
      } else {
        // make sure to retain key order here because of a bug handling the
        // $each operator in mongodb 2.4.4
        to[key] = exports.clone(fromObj[key], {retainKeyOrder: 1});
      }
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Aggregate.prototype.graphLookup = function(options) {
  var cloneOptions = {};
  if (options) {
if (!utils.isObject(options)) {
  throw new TypeError(&#x27;Invalid graphLookup() argument. Must be an object.&#x27;);
}

utils.<span class="apidocCodeKeywordSpan">mergeClone</span>(cloneOptions, options);
var startWith = cloneOptions.startWith;

if (startWith &#x26;&#x26; typeof startWith === &#x27;string&#x27;) {
  cloneOptions.startWith = cloneOptions.startWith.charAt(0) === &#x27;$&#x27; ?
    cloneOptions.startWith :
    &#x27;$&#x27; + cloneOptions.startWith;
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.options" id="apidoc.element.mongoose.utils.options">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>options
        <span class="apidocSignatureSpan">(defaults, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">options = function (defaults, options) {
  var keys = Object.keys(defaults),
      i = keys.length,
      k;

  options = options || {};

  while (i--) {
    k = keys[i];
    if (!(k in options)) {
      options[k] = defaults[k];
    }
  }

  return options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
}

if (options &#x26;&#x26; options.safe &#x26;&#x26; options.safe.w === 0) {
  // if you turn off safe writes, then versioning goes off as well
  options.versionKey = false;
}

options = utils.<span class="apidocCodeKeywordSpan">options</span>({
  strict: true,
  bufferCommands: true,
  capped: false, // { size, max, autoIndexId }
  versionKey: &#x27;__v&#x27;,
  discriminatorKey: &#x27;__t&#x27;,
  minimize: true,
  autoIndex: null,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.populate" id="apidoc.element.mongoose.utils.populate">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>populate
        <span class="apidocSignatureSpan">(path, select, model, match, options, subPopulate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function populate(path, select, model, match, options, subPopulate) {
  // The order of select/conditions args is opposite Model.find but
  // necessary to keep backward compatibility (select could be
  // an array, string, or object literal).

  // might have passed an object specifying all arguments
  if (arguments.length === 1) {
    if (path instanceof PopulateOptions) {
      return [path];
    }

    if (Array.isArray(path)) {
      return path.map(function(o) {
        return exports.populate(o)[0];
      });
    }

    if (exports.isObject(path)) {
      match = path.match;
      options = path.options;
      select = path.select;
      model = path.model;
      subPopulate = path.populate;
      path = path.path;
    }
  } else if (typeof model !== &#x27;string&#x27; &#x26;&#x26; typeof model !== &#x27;function&#x27;) {
    options = match;
    match = model;
    model = undefined;
  }

  if (typeof path !== &#x27;string&#x27;) {
    throw new TypeError(&#x27;utils.populate: invalid path. Expected string. Got typeof `&#x27; + typeof path + &#x27;`&#x27;);
  }

  if (typeof subPopulate === &#x27;object&#x27;) {
    subPopulate = exports.populate(subPopulate);
  }

  var ret = [];
  var paths = path.split(&#x27; &#x27;);
  options = exports.clone(options, { retainKeyOrder: true });
  for (var i = 0; i &#x3c; paths.length; ++i) {
    ret.push(new PopulateOptions(paths[i], select, match, options, model, subPopulate));
  }

  return ret;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
* Populates document references, executing the `callback` when complete.
* If you want to use promises instead, use this function with
* [`execPopulate()`](#document_Document-execPopulate)
*
* ####Example:
*
*     doc
*     .<span class="apidocCodeKeywordSpan">populate</span>(&#x27;company&#x27;)
*     .populate({
*       path: &#x27;notes&#x27;,
*       match: /airline/,
*       select: &#x27;text&#x27;,
*       model: &#x27;modelName&#x27;
*       options: opts
*     }, function (err, user) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.random" id="apidoc.element.mongoose.utils.random">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>random
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">random = function () {
  return Math.random().toString().substr(3);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
/*!
* Generates a random string
*
* @api private
*/

exports.random = function() {
 return Math.<span class="apidocCodeKeywordSpan">random</span>().toString().substr(3);
};

/*!
* Merges `from` into `to` without overwriting existing properties.
*
* @param {Object} to
* @param {Object} from
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.setValue" id="apidoc.element.mongoose.utils.setValue">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>setValue
        <span class="apidocSignatureSpan">(path, val, obj, map)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setValue = function (path, val, obj, map) {
  mpath.set(path, val, obj, &#x27;_doc&#x27;, map);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  }

  var pathType = this.schema.pathType(path);
  if (pathType === &#x27;nested&#x27; &#x26;&#x26; val) {
    if (utils.isObject(val) &#x26;&#x26;
  (!val.constructor || utils.getFunctionName(val.constructor) === &#x27;Object&#x27;)) {
if (!merge) {
  this.<span class="apidocCodeKeywordSpan">setValue</span>(path, null);
  cleanModifiedSubpaths(this, path);
}

if (Object.keys(val).length === 0) {
  this.setValue(path, {});
  this.markModified(path);
  cleanModifiedSubpaths(this, path);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.tick" id="apidoc.element.mongoose.utils.tick">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>tick
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function tick(callback) {
  if (typeof callback !== &#x27;function&#x27;) {
    return;
  }
  return function() {
    try {
      callback.apply(this, arguments);
    } catch (err) {
      // only nextTick on err to get out of
      // the event loop and avoid state corruption.
      process.nextTick(function() {
        throw err;
      });
    }
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

  var indexFields = index[0];
  var options = index[1];
  _handleSafe(options);

  indexSingleStart(indexFields, options);

  model.collection.ensureIndex(indexFields, options, utils.<span class="apidocCodeKeywordSpan">tick</span>(function(err, name) {
    indexSingleDone(err, indexFields, options, name);
    if (err) {
      return done(err);
    }
    create();
  }));
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.toCollectionName" id="apidoc.element.mongoose.utils.toCollectionName">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>toCollectionName
        <span class="apidocSignatureSpan">(name, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toCollectionName = function (name, options) {
  options = options || {};
  if (name === &#x27;system.profile&#x27;) {
    return name;
  }
  if (name === &#x27;system.indexes&#x27;) {
    return name;
  }
  if (options.pluralization === false) {
    return name;
  }
  return pluralize(name.toLowerCase());
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    ? schema
    : _this.prototype.schema;

var options = s.options || {};

if (!collection) {
  collection = _this.prototype.schema.get(&#x27;collection&#x27;)
      || utils.<span class="apidocCodeKeywordSpan">toCollectionName</span>(_this.modelName, options);
}

var collectionOptions = {
  bufferCommands: s ? options.bufferCommands : true,
  capped: s &#x26;&#x26; options.capped
};
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.utils.toObject" id="apidoc.element.mongoose.utils.toObject">
        function <span class="apidocSignatureSpan">mongoose.utils.</span>toObject
        <span class="apidocSignatureSpan">(obj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toObject(obj) {
  Document || (Document = require(&#x27;./document&#x27;));
  var ret;

  if (exports.isNullOrUndefined(obj)) {
    return obj;
  }

  if (obj instanceof Document) {
    return obj.toObject();
  }

  if (Array.isArray(obj)) {
    ret = [];

    for (var i = 0, len = obj.length; i &#x3c; len; ++i) {
      ret.push(toObject(obj[i]));
    }

    return ret;
  }

  if ((obj.constructor &#x26;&#x26; exports.getFunctionName(obj.constructor) === &#x27;Object&#x27;) ||
      (!obj.constructor &#x26;&#x26; exports.isObject(obj))) {
    ret = {};

    for (var k in obj) {
      ret[k] = toObject(obj[k]);
    }

    return ret;
  }

  return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
  if (value.$maxDistance != null) {
    value.$maxDistance = numbertype.castForQuery(value.$maxDistance);
  }
  if (value.$minDistance != null) {
    value.$minDistance = numbertype.castForQuery(value.$minDistance);
  }
  if (utils.isMongooseObject(value.$geometry)) {
    value.$geometry = value.$geometry.<span class="apidocCodeKeywordSpan">toObject</span>({
      transform: false,
      virtuals: false
    });
  }
  value = value.$geometry.coordinates;
} else if (geo === &#x27;$geoWithin&#x27;) {
  if (value.$geometry) {
...</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.virtualtype" id="apidoc.module.mongoose.virtualtype">module mongoose.virtualtype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.virtualtype.virtualtype" id="apidoc.element.mongoose.virtualtype.virtualtype">
        function <span class="apidocSignatureSpan">mongoose.</span>virtualtype
        <span class="apidocSignatureSpan">(options, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function VirtualType(options, name) {
  this.path = name;
  this.getters = [];
  this.setters = [];
  this.options = options || {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.mongoose.virtualtype.prototype" id="apidoc.module.mongoose.virtualtype.prototype">module mongoose.virtualtype.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.mongoose.virtualtype.prototype.applyGetters" id="apidoc.element.mongoose.virtualtype.prototype.applyGetters">
        function <span class="apidocSignatureSpan">mongoose.virtualtype.prototype.</span>applyGetters
        <span class="apidocSignatureSpan">(value, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyGetters = function (value, scope) {
  var v = value;
  for (var l = this.getters.length - 1; l &#x3e;= 0; l--) {
    v = this.getters[l].call(scope, v, this);
  }
  return v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 if (adhoc) {
   obj = adhoc.cast(obj);
 }

 // Check if this path is populated - don&#x27;t apply getters if it is,
 // because otherwise its a nested object. See gh-3357
 if (schema &#x26;&#x26; !this.populated(path)) {
   obj = schema.<span class="apidocCodeKeywordSpan">applyGetters</span>(obj, this);
 }

 return obj;
};

/**
* Returns the schematype for the given `path`.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.virtualtype.prototype.applySetters" id="apidoc.element.mongoose.virtualtype.prototype.applySetters">
        function <span class="apidocSignatureSpan">mongoose.virtualtype.prototype.</span>applySetters
        <span class="apidocSignatureSpan">(value, scope)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applySetters = function (value, scope) {
  var v = value;
  for (var l = this.setters.length - 1; l &#x3e;= 0; l--) {
    v = this.setters[l].call(scope, v, this);
  }
  return v;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (strict === &#x27;throw&#x27;) {
      throw new StrictModeError(path);
    }
    return this;
  }
} else if (pathType === &#x27;virtual&#x27;) {
  schema = this.schema.virtualpath(path);
  schema.<span class="apidocCodeKeywordSpan">applySetters</span>(val, this);
  return this;
} else {
  schema = this.$__path(path);
}

var pathToMark;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.virtualtype.prototype.get" id="apidoc.element.mongoose.virtualtype.prototype.get">
        function <span class="apidocSignatureSpan">mongoose.virtualtype.prototype.</span>get
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (fn) {
  this.getters.push(fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
// a setter
Comment.path(&#x27;name&#x27;).set(function (v) {
  return capitalize(v);
});

// middleware
Comment.pre(&#x27;save&#x27;, function (next) {
  notify(this.<span class="apidocCodeKeywordSpan">get</span>(&#x27;email&#x27;));
  next();
});
```

Take a look at the example in `examples/schema.js` for an end-to-end example of a typical setup.

### Accessing a Model
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.mongoose.virtualtype.prototype.set" id="apidoc.element.mongoose.virtualtype.prototype.set">
        function <span class="apidocSignatureSpan">mongoose.virtualtype.prototype.</span>set
        <span class="apidocSignatureSpan">(fn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (fn) {
  this.setters.push(fn);
  return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
age: { type: Number, min: 18, index: true },
bio: { type: String, match: /[a-z]/ },
date: { type: Date, default: Date.now },
buff: Buffer
});

// a setter
Comment.path(&#x27;name&#x27;).<span class="apidocCodeKeywordSpan">set</span>(function (v) {
return capitalize(v);
});

// middleware
Comment.pre(&#x27;save&#x27;, function (next) {
notify(this.get(&#x27;email&#x27;));
next();
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
